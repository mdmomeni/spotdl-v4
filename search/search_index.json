{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spotdl-v4 A new and improved version of spotdl Contributing Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment. License This project is Licensed under the MIT License.","title":"Home"},{"location":"#spotdl-v4","text":"A new and improved version of spotdl","title":"Spotdl-v4"},{"location":"#contributing","text":"Interested in contributing? Check out our CONTRIBUTING.md to find resources around contributing along with a guide on how to set up a development environment.","title":"Contributing"},{"location":"#license","text":"This project is Licensed under the MIT License.","title":"License"},{"location":"docs/CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Code Of Conduct"},{"location":"docs/CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"docs/CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"docs/CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"docs/CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"docs/CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at spotdladmins@googlegroups.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"docs/CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"docs/CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"docs/CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"docs/CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"docs/CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"docs/CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"docs/CONTRIBUTING/","text":"Contributing to spotdl First off, thanks for taking the time to contribute! \u2764\ufe0f All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. \ud83c\udf89 And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: Star the project Tweet about it Refer this project in your project's readme Mention the project at local meetups and tell your friends/colleagues Table of Contents I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Linting, Formatting and Type-checking Python Documentation Overview of the Project Structure Join The Project Team I Have a Question If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first. If you then still feel the need to ask a question and need clarification, we recommend the following: Open an Issue . Provide as much context as you can about what you're running into. Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant. We will then take care of the issue as soon as possible. I Want To Contribute Legal Notice When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license. Reporting Bugs Before Submitting a Bug Report A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions? How Do I Submit a Good Bug Report? You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to . We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it's filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone . Suggesting Enhancements This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality . Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions. Before Submitting an Enhancement Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library. How Do I Submit a Good Enhancement Suggestion? Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most spotdl users. You may also want to point out the other projects that solved it better and which could serve as inspiration. Linting, Formatting and Type-checking We use pylint for linting and expect a score above 9 pylint --limit-inference-results 0 --fail-under 9 ./spotdl We use black for code formatting black ./spotdl We use mypy for type-checking and expect no errors at all To install type-stubs the first time around mypy --install-types --non-interactive mypy ./spotdl You can install these basic tools with pip install --force-reinstall --upgrade mypy black pylint Python Documentation Any submitted code is expected to have accompanying documentation pdoc3: generating documentation We generate our documentation with portray pip install portray portray requires that all development packages are installed poetry install -E web generate docs with portray as_html view docs live-time while editing with portray in_browser DocString Formats For functions ``` one-liner about functions purpose ### Args (optional) - arg_name: description ### Returns (optional) - return value description ### Errors (only if there are known unhandled Errors/thrown Errors) - known errors ### Notes (optional) - notes if any ``` For Classes ``` one-liner about class purpose ### Attributes - attribute: description ### Notes (optional) - notes if any ``` For modules/package __init__ ``` at max 3 lines about module/package purpose optional usage example for module/package preferably showcasing most commonly used functionality ``` Notes about pdoc3 DocStrings are Inherited ``` class A: def test(self): \"\"\"Docstring for A.\"\"\" pass class B(A): def test(self): pass # B.test. doc acc. to normal python : None # B.test. doc acc. to normal pdoc3 : Docstring for A. ``` You can write DocStrings for variables with #: comment above the variable #: an example variable to demonstrate DocStrings example_var_1 = 1 You can use the reST directives ..math:: and ..image:: Markdown formatting Markdown is formatted with mdformat-gfm and indexes are auto-generated with mdformat-toc pip install mdformat-gfm mdformat-toc Create an Index using the following comment, the index will be updated when mdformat is run ```markdown ``` Preferably use empty lines between points on ordered & un-ordered lists Format your markdown using mdformat --wrap 95 --number ./ Overview of the Project Structure sub-package purpose utils Contains commonly used functions types Custom data types used in the spotdl project providers Different Providers to obtain info (like song details) from download Download manager console Different user-facing operations like download, preload and web-ui __init__ Contains spotdl class that simplifies the download process Join The Project Team Attribution This guide is based on the contributing-gen . Make your own !","title":"Contributing"},{"location":"docs/CONTRIBUTING/#contributing-to-spotdl","text":"First off, thanks for taking the time to contribute! \u2764\ufe0f All types of contributions are encouraged and valued. See the Table of Contents for different ways to help and details about how this project handles them. Please make sure to read the relevant section before making your contribution. It will make it a lot easier for us maintainers and smooth out the experience for all involved. The community looks forward to your contributions. \ud83c\udf89 And if you like the project, but just don't have time to contribute, that's fine. There are other easy ways to support the project and show your appreciation, which we would also be very happy about: Star the project Tweet about it Refer this project in your project's readme Mention the project at local meetups and tell your friends/colleagues","title":"Contributing to spotdl"},{"location":"docs/CONTRIBUTING/#table-of-contents","text":"I Have a Question I Want To Contribute Reporting Bugs Suggesting Enhancements Linting, Formatting and Type-checking Python Documentation Overview of the Project Structure Join The Project Team","title":"Table of Contents"},{"location":"docs/CONTRIBUTING/#i-have-a-question","text":"If you want to ask a question, we assume that you have read the available Documentation . Before you ask a question, it is best to search for existing Issues that might help you. In case you have found a suitable issue and still need clarification, you can write your question in this issue. It is also advisable to search the internet for answers first. If you then still feel the need to ask a question and need clarification, we recommend the following: Open an Issue . Provide as much context as you can about what you're running into. Provide project and platform versions (nodejs, npm, etc), depending on what seems relevant. We will then take care of the issue as soon as possible.","title":"I Have a Question"},{"location":"docs/CONTRIBUTING/#i-want-to-contribute","text":"","title":"I Want To Contribute"},{"location":"docs/CONTRIBUTING/#legal-notice","text":"When contributing to this project, you must agree that you have authored 100% of the content, that you have the necessary rights to the content and that the content you contribute may be provided under the project license.","title":"Legal Notice "},{"location":"docs/CONTRIBUTING/#reporting-bugs","text":"","title":"Reporting Bugs"},{"location":"docs/CONTRIBUTING/#before-submitting-a-bug-report","text":"A good bug report shouldn't leave others needing to chase you up for more information. Therefore, we ask you to investigate carefully, collect information and describe the issue in detail in your report. Please complete the following steps in advance to help us fix any potential bug as fast as possible. Make sure that you are using the latest version. Determine if your bug is really a bug and not an error on your side e.g. using incompatible environment components/versions (Make sure that you have read the documentation . If you are looking for support, you might want to check this section ). To see if other users have experienced (and potentially already solved) the same issue you are having, check if there is not already a bug report existing for your bug or error in the bug tracker . Also make sure to search the internet (including Stack Overflow) to see if users outside of the GitHub community have discussed the issue. Collect information about the bug: Stack trace (Traceback) OS, Platform and Version (Windows, Linux, macOS, x86, ARM) Version of the interpreter, compiler, SDK, runtime environment, package manager, depending on what seems relevant. Possibly your input and the output Can you reliably reproduce the issue? And can you also reproduce it with older versions?","title":"Before Submitting a Bug Report"},{"location":"docs/CONTRIBUTING/#how-do-i-submit-a-good-bug-report","text":"You must never report security related issues, vulnerabilities or bugs to the issue tracker, or elsewhere in public. Instead sensitive bugs must be sent by email to . We use GitHub issues to track bugs and errors. If you run into an issue with the project: Open an Issue . (Since we can't be sure at this point whether it is a bug or not, we ask you not to talk about a bug yet and not to label the issue.) Explain the behavior you would expect and the actual behavior. Please provide as much context as possible and describe the reproduction steps that someone else can follow to recreate the issue on their own. This usually includes your code. For good bug reports you should isolate the problem and create a reduced test case. Provide the information you collected in the previous section. Once it's filed: The project team will label the issue accordingly. A team member will try to reproduce the issue with your provided steps. If there are no reproduction steps or no obvious way to reproduce the issue, the team will ask you for those steps and mark the issue as needs-repro . Bugs with the needs-repro tag will not be addressed until they are reproduced. If the team is able to reproduce the issue, it will be marked needs-fix , as well as possibly other tags (such as critical ), and the issue will be left to be implemented by someone .","title":"How Do I Submit a Good Bug Report?"},{"location":"docs/CONTRIBUTING/#suggesting-enhancements","text":"This section guides you through submitting an enhancement suggestion for spotdl, including completely new features and minor improvements to existing functionality . Following these guidelines will help maintainers and the community to understand your suggestion and find related suggestions.","title":"Suggesting Enhancements"},{"location":"docs/CONTRIBUTING/#before-submitting-an-enhancement","text":"Make sure that you are using the latest version. Read the documentation carefully and find out if the functionality is already covered, maybe by an individual configuration. Perform a search to see if the enhancement has already been suggested. If it has, add a comment to the existing issue instead of opening a new one. Find out whether your idea fits with the scope and aims of the project. It's up to you to make a strong case to convince the project's developers of the merits of this feature. Keep in mind that we want features that will be useful to the majority of our users and not just a small subset. If you're just targeting a minority of users, consider writing an add-on/plugin library.","title":"Before Submitting an Enhancement"},{"location":"docs/CONTRIBUTING/#how-do-i-submit-a-good-enhancement-suggestion","text":"Enhancement suggestions are tracked as GitHub issues . Use a clear and descriptive title for the issue to identify the suggestion. Provide a step-by-step description of the suggested enhancement in as many details as possible. Describe the current behavior and explain which behavior you expected to see instead and why. At this point you can also tell which alternatives do not work for you. You may want to include screenshots and animated GIFs which help you demonstrate the steps or point out the part which the suggestion is related to. You can use this tool to record GIFs on macOS and Windows, and this tool or this tool on Linux. Explain why this enhancement would be useful to most spotdl users. You may also want to point out the other projects that solved it better and which could serve as inspiration.","title":"How Do I Submit a Good Enhancement Suggestion?"},{"location":"docs/CONTRIBUTING/#linting-formatting-and-type-checking","text":"We use pylint for linting and expect a score above 9 pylint --limit-inference-results 0 --fail-under 9 ./spotdl We use black for code formatting black ./spotdl We use mypy for type-checking and expect no errors at all To install type-stubs the first time around mypy --install-types --non-interactive mypy ./spotdl You can install these basic tools with pip install --force-reinstall --upgrade mypy black pylint","title":"Linting, Formatting and Type-checking"},{"location":"docs/CONTRIBUTING/#python-documentation","text":"Any submitted code is expected to have accompanying documentation","title":"Python Documentation"},{"location":"docs/CONTRIBUTING/#pdoc3-generating-documentation","text":"We generate our documentation with portray pip install portray portray requires that all development packages are installed poetry install -E web generate docs with portray as_html view docs live-time while editing with portray in_browser","title":"pdoc3: generating documentation"},{"location":"docs/CONTRIBUTING/#docstring-formats","text":"For functions ``` one-liner about functions purpose ### Args (optional) - arg_name: description ### Returns (optional) - return value description ### Errors (only if there are known unhandled Errors/thrown Errors) - known errors ### Notes (optional) - notes if any ``` For Classes ``` one-liner about class purpose ### Attributes - attribute: description ### Notes (optional) - notes if any ``` For modules/package __init__ ``` at max 3 lines about module/package purpose optional usage example for module/package preferably showcasing most commonly used functionality ```","title":"DocString Formats"},{"location":"docs/CONTRIBUTING/#notes-about-pdoc3","text":"DocStrings are Inherited ``` class A: def test(self): \"\"\"Docstring for A.\"\"\" pass class B(A): def test(self): pass # B.test. doc acc. to normal python : None # B.test. doc acc. to normal pdoc3 : Docstring for A. ``` You can write DocStrings for variables with #: comment above the variable #: an example variable to demonstrate DocStrings example_var_1 = 1 You can use the reST directives ..math:: and ..image::","title":"Notes about pdoc3"},{"location":"docs/CONTRIBUTING/#markdown-formatting","text":"Markdown is formatted with mdformat-gfm and indexes are auto-generated with mdformat-toc pip install mdformat-gfm mdformat-toc Create an Index using the following comment, the index will be updated when mdformat is run ```markdown ``` Preferably use empty lines between points on ordered & un-ordered lists Format your markdown using mdformat --wrap 95 --number ./","title":"Markdown formatting"},{"location":"docs/CONTRIBUTING/#overview-of-the-project-structure","text":"sub-package purpose utils Contains commonly used functions types Custom data types used in the spotdl project providers Different Providers to obtain info (like song details) from download Download manager console Different user-facing operations like download, preload and web-ui __init__ Contains spotdl class that simplifies the download process","title":"Overview of the Project Structure"},{"location":"docs/CONTRIBUTING/#join-the-project-team","text":"","title":"Join The Project Team"},{"location":"docs/CONTRIBUTING/#attribution","text":"This guide is based on the contributing-gen . Make your own !","title":"Attribution"},{"location":"docs/TROUBLESHOOTING/","text":"Troubleshooting / FAQ Guide As common issues or questions are encountered solutions will be added to this guide. pkg_resources.DistributionNotFound Sometimes not all packages are installed but are required by yt-dlp for example: brotli or websockets Error message pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp Solution pip install brotli websockets yt-dlp -U HTTP Error 404 https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148 Error message HTTP Error for GET to URL with Params: {} returned 404 due to None Solution Update spotdl to the latest version which contains workaround. pip install -U spotdl Failed to install RapidFuzz on termux https://github.com/spotDL/spotify-downloader/issues/1485 https://github.com/maxbachmann/RapidFuzz/issues/195 Error message ld . lld : error : unable to find library - lgcc clang - 13 : error : linker command failed with exit code 1 ( use - v to see invocation ) ninja : build stopped : subcommand failed . or ERROR : Could not build wheels for cmake , ninja , which is required to install pyproject . toml - based projects Solution # Setup its-pointless repo curl -LO https://its-pointless.github.io/setup-pointless-repo.sh bash setup-pointless-repo.sh # Install numpy pkg install numpy # install rapidfuzz (v1.9.1 for now) pip install rapidfuzz == 1 .9.1 # Install spotdl pip install spotdl ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error Error message urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)> Solution https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error RecursionError https://github.com/spotDL/spotify-downloader/issues/1493 Error message RecursionError: maximum recursion depth exceeded Solution Update spotdl pip install spotdl -U spotdl: command not found If you see this error after installing spotdl, that means that the bin folder is not on $PATH Solution .bashrc Add export PATH=~/.local/bin:$PATH at the bottom of ~/.bashrc Then run source ~/.bashrc .zshrc Add export PATH=~/.local/bin:$PATH at the bottom of ~/.zshrc Then run source ~/.zshrc RuntimeWarning This happens when running spotdl using python -m . Error message RuntimeWarning : 'spotdl.__main__' found in sys . modules after import of package 'spotdl' , but prior to execution of 'spotdl.__main__' ; this may result in unpredictable behaviour warn ( RuntimeWarning ( msg )) Solution You can ignore this error or just run spotdl directly Not found '_raw_ecb.so' This error is specific for M1 Macs only. https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738 Error message aise OSError ( \"Cannot load native module ' %s ': %s \" % ( name , \", \" . join ( attempts ))) OSError : Cannot load native module 'Cryptodome.Cipher._raw_ecb' : Not found '_raw_ecb.cpython-39-darwin.so' , Cannot load '_raw_ecb.abi3.so' : dlopen ( / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Util /../ Cipher / _raw_ecb . abi3 . so , 6 ): no suitable image found . Did find : / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Util /../ Cipher / _raw_ecb . abi3 . so : mach - o , but wrong architecture / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Cipher / _raw_ecb . abi3 . so : mach - o , but wrong architecture , Not found '_raw_ecb.so' Solution Possible solutions: https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738 'spotdl' is not recognized Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/ Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python. Error message 'spotdl' is not recognized as an internal or external command, operable program or batch file. Solution Ensure to add to PATH when installing:","title":"Troubleshooting"},{"location":"docs/TROUBLESHOOTING/#troubleshooting-faq-guide","text":"As common issues or questions are encountered solutions will be added to this guide.","title":"Troubleshooting / FAQ Guide"},{"location":"docs/TROUBLESHOOTING/#pkg_resourcesdistributionnotfound","text":"Sometimes not all packages are installed but are required by yt-dlp for example: brotli or websockets","title":"pkg_resources.DistributionNotFound"},{"location":"docs/TROUBLESHOOTING/#error-message","text":"pkg_resources.DistributionNotFound: The 'websockets' distribution was not found and is required by yt-dlp","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution","text":"pip install brotli websockets yt-dlp -U","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#http-error-404","text":"https://github.com/plamere/spotipy/issues/795#issuecomment-1100321148","title":"HTTP Error 404"},{"location":"docs/TROUBLESHOOTING/#error-message_1","text":"HTTP Error for GET to URL with Params: {} returned 404 due to None","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_1","text":"Update spotdl to the latest version which contains workaround. pip install -U spotdl","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#failed-to-install-rapidfuzz-on-termux","text":"https://github.com/spotDL/spotify-downloader/issues/1485 https://github.com/maxbachmann/RapidFuzz/issues/195","title":"Failed to install RapidFuzz on termux"},{"location":"docs/TROUBLESHOOTING/#error-message_2","text":"ld . lld : error : unable to find library - lgcc clang - 13 : error : linker command failed with exit code 1 ( use - v to see invocation ) ninja : build stopped : subcommand failed . or ERROR : Could not build wheels for cmake , ninja , which is required to install pyproject . toml - based projects","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_2","text":"# Setup its-pointless repo curl -LO https://its-pointless.github.io/setup-pointless-repo.sh bash setup-pointless-repo.sh # Install numpy pkg install numpy # install rapidfuzz (v1.9.1 for now) pip install rapidfuzz == 1 .9.1 # Install spotdl pip install spotdl","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#sslsslerror-ssl-certificate_verify_failed","text":"https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error","title":"ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]"},{"location":"docs/TROUBLESHOOTING/#error-message_3","text":"urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:847)>","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_3","text":"https://stackoverflow.com/questions/27835619/urllib-and-ssl-certificate-verify-failed-error","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#recursionerror","text":"https://github.com/spotDL/spotify-downloader/issues/1493","title":"RecursionError"},{"location":"docs/TROUBLESHOOTING/#error-message_4","text":"RecursionError: maximum recursion depth exceeded","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_4","text":"Update spotdl pip install spotdl -U","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#spotdl-command-not-found","text":"If you see this error after installing spotdl, that means that the bin folder is not on $PATH","title":"spotdl: command not found"},{"location":"docs/TROUBLESHOOTING/#solution_5","text":"","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#bashrc","text":"Add export PATH=~/.local/bin:$PATH at the bottom of ~/.bashrc Then run source ~/.bashrc","title":".bashrc"},{"location":"docs/TROUBLESHOOTING/#zshrc","text":"Add export PATH=~/.local/bin:$PATH at the bottom of ~/.zshrc Then run source ~/.zshrc","title":".zshrc"},{"location":"docs/TROUBLESHOOTING/#runtimewarning","text":"This happens when running spotdl using python -m .","title":"RuntimeWarning"},{"location":"docs/TROUBLESHOOTING/#error-message_5","text":"RuntimeWarning : 'spotdl.__main__' found in sys . modules after import of package 'spotdl' , but prior to execution of 'spotdl.__main__' ; this may result in unpredictable behaviour warn ( RuntimeWarning ( msg ))","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_6","text":"You can ignore this error or just run spotdl directly","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#not-found-_raw_ecbso","text":"This error is specific for M1 Macs only. https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738","title":"Not found '_raw_ecb.so'"},{"location":"docs/TROUBLESHOOTING/#error-message_6","text":"aise OSError ( \"Cannot load native module ' %s ': %s \" % ( name , \", \" . join ( attempts ))) OSError : Cannot load native module 'Cryptodome.Cipher._raw_ecb' : Not found '_raw_ecb.cpython-39-darwin.so' , Cannot load '_raw_ecb.abi3.so' : dlopen ( / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Util /../ Cipher / _raw_ecb . abi3 . so , 6 ): no suitable image found . Did find : / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Util /../ Cipher / _raw_ecb . abi3 . so : mach - o , but wrong architecture / opt / homebrew / lib / python3 . 9 / site - packages / Cryptodome / Cipher / _raw_ecb . abi3 . so : mach - o , but wrong architecture , Not found '_raw_ecb.so'","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_7","text":"Possible solutions: https://discord.com/channels/771628785447337985/871006150357823498 https://discord.com/channels/771628785447337985/939475659238043738","title":"Solution"},{"location":"docs/TROUBLESHOOTING/#spotdl-is-not-recognized","text":"Python/(site packages) is not added to PATH correctly. You need to install Python from https://www.python.org/downloads/ Or you are using python from microsoft store. If so uninstall it and restart cmd. If this doesn't work reinstall python.","title":"'spotdl' is not recognized"},{"location":"docs/TROUBLESHOOTING/#error-message_7","text":"'spotdl' is not recognized as an internal or external command, operable program or batch file.","title":"Error message"},{"location":"docs/TROUBLESHOOTING/#solution_8","text":"Ensure to add to PATH when installing:","title":"Solution"},{"location":"reference/spotdl/","text":"Module spotdl Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class View Source \"\"\" Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class \"\"\" import asyncio import concurrent.futures from pathlib import Path from typing import List , Optional , Tuple from spotdl.utils.spotify import SpotifyClient from spotdl.console import console_entry_point from spotdl.download import Downloader from spotdl.utils.search import parse_query from spotdl.types import Song from spotdl._version import __version__ class Spotdl : \"\"\" Spotdl class, which simplifies the process of downloading songs from Spotify. >>> from spotdl import Spotdl >>> spotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret') >>> songs = spotdl.search(['joji - test drive', >>> 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT']) >>> spotdl.download_songs(songs) \"\"\" def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artist} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , ) def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads ) def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs ) Sub-modules spotdl.console spotdl.download spotdl.providers spotdl.types spotdl.utils Classes Spotdl class Spotdl ( client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = 'ffmpeg' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = 'mp3' , threads : int = 4 , output : str = '.' , save_file : Optional [ str ] = None , overwrite : str = 'skip' , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = ' {artist} - {title} ' , log_level : str = 'INFO' , simple_tui : bool = False , loop : Optional [ asyncio . events . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False ) View Source class Spotdl : \"\"\" Spotdl class, which simplifies the process of downloading songs from Spotify. >>> from spotdl import Spotdl >>> spotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret') >>> songs = spotdl.search(['joji - test drive', >>> 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT']) >>> spotdl.download_songs(songs) \"\"\" def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artist} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , ) def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads ) def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs ) Methods download def download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Download and convert song to the output format. Arguments song: Song object Returns A tuple containing the song and the path to the downloaded file if successful. View Source def download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) download_songs def download_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download and convert songs to the output format. Arguments songs: List of Song objects Returns A list of tuples containing the song and the path to the downloaded file if successful. View Source def download_songs ( self , songs : List [ Song ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs ) get_download_urls def get_download_urls ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Optional [ str ]] Get the download urls for a list of songs. Arguments songs: List of Song objects Returns A list of urls if successful. Notes This function is multi-threaded. View Source def get_download_urls ( self , songs : List [ Song ] ) -> List [ Optional[str ] ]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional[str ] ] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ) : song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ) : song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \"{song} generated an exception: {exc}\" ) return urls search def search ( self , query : List [ str ] ) -> List [ spotdl . types . song . Song ] Search for songs. Arguments query: List of search queries Returns A list of Song objects Notes query can be a list of song titles, urls, uris View Source def search ( self , query : List [ str ] ) -> List [ Song ] : \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads )","title":"Index"},{"location":"reference/spotdl/#module-spotdl","text":"Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class View Source \"\"\" Init module for spotdl. This module contains the main entry point for spotdl. And Spotdl class \"\"\" import asyncio import concurrent.futures from pathlib import Path from typing import List , Optional , Tuple from spotdl.utils.spotify import SpotifyClient from spotdl.console import console_entry_point from spotdl.download import Downloader from spotdl.utils.search import parse_query from spotdl.types import Song from spotdl._version import __version__ class Spotdl : \"\"\" Spotdl class, which simplifies the process of downloading songs from Spotify. >>> from spotdl import Spotdl >>> spotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret') >>> songs = spotdl.search(['joji - test drive', >>> 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT']) >>> spotdl.download_songs(songs) \"\"\" def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artist} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , ) def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads ) def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs )","title":"Module spotdl"},{"location":"reference/spotdl/#sub-modules","text":"spotdl.console spotdl.download spotdl.providers spotdl.types spotdl.utils","title":"Sub-modules"},{"location":"reference/spotdl/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/#spotdl","text":"class Spotdl ( client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = 'ffmpeg' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = 'mp3' , threads : int = 4 , output : str = '.' , save_file : Optional [ str ] = None , overwrite : str = 'skip' , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = ' {artist} - {title} ' , log_level : str = 'INFO' , simple_tui : bool = False , loop : Optional [ asyncio . events . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False ) View Source class Spotdl : \"\"\" Spotdl class, which simplifies the process of downloading songs from Spotify. >>> from spotdl import Spotdl >>> spotdl = Spotdl(client_id='your-client-id', client_secret='your-client-secret') >>> songs = spotdl.search(['joji - test drive', >>> 'https://open.spotify.com/track/4cOdK2wGLETKBW3PvgPWqT']) >>> spotdl.download_songs(songs) \"\"\" def __init__ ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , headless : bool = False , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artist} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Spotdl class ### Arguments - client_id: Spotify client id - client_secret: Spotify client secret - user_auth: If true, user will be prompted to authenticate - cache_path: Path to cache directory - no_cache: If true, no cache will be used - headless: If true, no browser will be opened - audio_providers: The audio providers to use. - lyrics_providers: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] # Initialize spotify client SpotifyClient . init ( client_id = client_id , client_secret = client_secret , user_auth = user_auth , cache_path = cache_path , no_cache = no_cache , open_browser = not headless , ) # Initialize downloader self . downloader = Downloader ( audio_providers = audio_providers , lyrics_providers = lyrics_providers , search_query = search_query , ffmpeg = ffmpeg , bitrate = bitrate , ffmpeg_args = ffmpeg_args , output_format = output_format , threads = threads , output = output , save_file = save_file , overwrite = overwrite , cookie_file = cookie_file , filter_results = filter_results , log_level = log_level , simple_tui = simple_tui , loop = loop , restrict = restrict , print_errors = print_errors , sponsor_block = sponsor_block , ) def search ( self , query : List [ str ]) -> List [ Song ]: \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads ) def get_download_urls ( self , songs : List [ Song ]) -> List [ Optional [ str ]]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional [ str ]] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) return urls def download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song ) def download_songs ( self , songs : List [ Song ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs )","title":"Spotdl"},{"location":"reference/spotdl/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/#download","text":"def download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Download and convert song to the output format.","title":"download"},{"location":"reference/spotdl/#arguments","text":"song: Song object","title":"Arguments"},{"location":"reference/spotdl/#returns","text":"A tuple containing the song and the path to the downloaded file if successful. View Source def download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Download and convert song to the output format. ### Arguments - song: Song object ### Returns - A tuple containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_song ( song )","title":"Returns"},{"location":"reference/spotdl/#download_songs","text":"def download_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download and convert songs to the output format.","title":"download_songs"},{"location":"reference/spotdl/#arguments_1","text":"songs: List of Song objects","title":"Arguments"},{"location":"reference/spotdl/#returns_1","text":"A list of tuples containing the song and the path to the downloaded file if successful. View Source def download_songs ( self , songs : List [ Song ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download and convert songs to the output format. ### Arguments - songs: List of Song objects ### Returns - A list of tuples containing the song and the path to the downloaded file if successful. \"\"\" return self . downloader . download_multiple_songs ( songs )","title":"Returns"},{"location":"reference/spotdl/#get_download_urls","text":"def get_download_urls ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Optional [ str ]] Get the download urls for a list of songs.","title":"get_download_urls"},{"location":"reference/spotdl/#arguments_2","text":"songs: List of Song objects","title":"Arguments"},{"location":"reference/spotdl/#returns_2","text":"A list of urls if successful.","title":"Returns"},{"location":"reference/spotdl/#notes","text":"This function is multi-threaded. View Source def get_download_urls ( self , songs : List [ Song ] ) -> List [ Optional[str ] ]: \"\"\" Get the download urls for a list of songs. ### Arguments - songs: List of Song objects ### Returns - A list of urls if successful. ### Notes - This function is multi-threaded. \"\"\" urls : List [ Optional[str ] ] = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = self . downloader . threads ) as executor : future_to_song = { executor . submit ( self . downloader . search , song ) : song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ) : song = future_to_song [ future ] try : data , _ = future . result () urls . append ( data ) except Exception as exc : self . downloader . progress_handler . error ( f \"{song} generated an exception: {exc}\" ) return urls","title":"Notes"},{"location":"reference/spotdl/#search","text":"def search ( self , query : List [ str ] ) -> List [ spotdl . types . song . Song ] Search for songs.","title":"search"},{"location":"reference/spotdl/#arguments_3","text":"query: List of search queries","title":"Arguments"},{"location":"reference/spotdl/#returns_3","text":"A list of Song objects","title":"Returns"},{"location":"reference/spotdl/#notes_1","text":"query can be a list of song titles, urls, uris View Source def search ( self , query : List [ str ] ) -> List [ Song ] : \"\"\" Search for songs. ### Arguments - query: List of search queries ### Returns - A list of Song objects ### Notes - query can be a list of song titles, urls, uris \"\"\" return parse_query ( query , self . downloader . threads )","title":"Notes"},{"location":"reference/spotdl/console/","text":"Module spotdl.console Console module, contains the console entry point and different subcommands. None View Source \"\"\" Console module, contains the console entry point and different subcommands. \"\"\" from spotdl.console.entry_point import console_entry_point Sub-modules spotdl.console.download spotdl.console.entry_point spotdl.console.preload spotdl.console.save spotdl.console.sync spotdl.console.web","title":"Index"},{"location":"reference/spotdl/console/#module-spotdlconsole","text":"Console module, contains the console entry point and different subcommands. None View Source \"\"\" Console module, contains the console entry point and different subcommands. \"\"\" from spotdl.console.entry_point import console_entry_point","title":"Module spotdl.console"},{"location":"reference/spotdl/console/#sub-modules","text":"spotdl.console.download spotdl.console.entry_point spotdl.console.preload spotdl.console.save spotdl.console.sync spotdl.console.web","title":"Sub-modules"},{"location":"reference/spotdl/console/download/","text":"Module spotdl.console.download Download module for the console. None View Source \"\"\" Download module for the console. \"\"\" import traceback import json from typing import List , Optional from pathlib import Path from spotdl.download.downloader import Downloader from spotdl.utils.m3u import create_m3u_file from spotdl.utils.search import get_simple_songs def download ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" try : # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song , _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( songs , save_file , indent = 4 , ensure_ascii = False ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception )) Functions download def download ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : Optional [ pathlib . Path ] = None , m3u_file : Optional [ str ] = None ) -> None Find songs with the provided audio provider and save them to the disk. Arguments query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to or None. m3u_file: Path to the m3u file to save the songs to. View Source def download ( query : List [ str ] , downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" try : # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song, _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( songs , save_file , indent = 4 , ensure_ascii = False ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Download"},{"location":"reference/spotdl/console/download/#module-spotdlconsoledownload","text":"Download module for the console. None View Source \"\"\" Download module for the console. \"\"\" import traceback import json from typing import List , Optional from pathlib import Path from spotdl.download.downloader import Downloader from spotdl.utils.m3u import create_m3u_file from spotdl.utils.search import get_simple_songs def download ( query : List [ str ], downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" try : # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song , _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( songs , save_file , indent = 4 , ensure_ascii = False ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Module spotdl.console.download"},{"location":"reference/spotdl/console/download/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/download/#download","text":"def download ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : Optional [ pathlib . Path ] = None , m3u_file : Optional [ str ] = None ) -> None Find songs with the provided audio provider and save them to the disk.","title":"download"},{"location":"reference/spotdl/console/download/#arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to or None. m3u_file: Path to the m3u file to save the songs to. View Source def download ( query : List [ str ] , downloader : Downloader , save_path : Optional [ Path ] = None , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Find songs with the provided audio provider and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to or None. - m3u_file: Path to the m3u file to save the songs to. \"\"\" try : # Parse the query songs = get_simple_songs ( query ) results = downloader . download_multiple_songs ( songs ) if m3u_file : song_list = [ song for song, _ in results ] create_m3u_file ( m3u_file , song_list , downloader . output , downloader . output_format , False ) if save_path : # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( songs , save_file , indent = 4 , ensure_ascii = False ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Arguments"},{"location":"reference/spotdl/console/entry_point/","text":"Module spotdl.console.entry_point Module that holds the entry point for the console. None View Source \"\"\" Module that holds the entry point for the console. \"\"\" import sys import json import signal import logging import cProfile import pstats from spotdl.console.download import download from spotdl.console.preload import preload from spotdl.console.sync import sync from spotdl.console.save import save from spotdl.download import Downloader from spotdl.utils.config import DEFAULT_CONFIG , ConfigError , get_config from spotdl.utils.ffmpeg import FFmpegError , download_ffmpeg , is_ffmpeg_installed from spotdl.utils.config import get_config_file from spotdl.utils.github import check_for_updates from spotdl.utils.arguments import parse_arguments from spotdl.utils.spotify import SpotifyClient , SpotifyError from spotdl.download.downloader import DownloaderError OPEARTIONS = { \"download\" : download , \"preload\" : preload , \"sync\" : sync , \"save\" : save , } def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"asyncio\" ) . setLevel ( logging . WARNING ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : download_ffmpeg () return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Settings from config file will override the ones from the command line settings = {} for key in DEFAULT_CONFIG : if config . get ( key ) is None : # If the key is not in the arguments dict, use the default value settings [ key ] = arguments . __dict__ . get ( key ) or DEFAULT_CONFIG [ key ] else : settings [ key ] = config [ key ] # Check if ffmpeg is installed if is_ffmpeg_installed () is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl.console.web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query.\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) # Pick the operation to perform # based on the name and run it! OPEARTIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) downloader . progress_handler . close () return None def console_entry_point (): \"\"\" Wrapper around `entry_point` so we can profile the code \"\"\" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point () Variables DEFAULT_CONFIG OPEARTIONS Functions console_entry_point def console_entry_point ( ) Wrapper around entry_point so we can profile the code View Source def console_entry_point () : \" \"\" Wrapper around `entry_point` so we can profile the code \"\" \" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point () entry_point def entry_point ( ) Console entry point for spotdl. This is where the magic happens. View Source def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"asyncio\" ) . setLevel ( logging . WARNING ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : download_ffmpeg () return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Settings from config file will override the ones from the command line settings = {} for key in DEFAULT_CONFIG : if config . get ( key ) is None : # If the key is not in the arguments dict, use the default value settings [ key ] = arguments . __dict__ . get ( key ) or DEFAULT_CONFIG [ key ] else : settings [ key ] = config [ key ] # Check if ffmpeg is installed if is_ffmpeg_installed () is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl . console . web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query.\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) # Pick the operation to perform # based on the name and run it! OPEARTIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) downloader . progress_handler . close () return None","title":"Entry Point"},{"location":"reference/spotdl/console/entry_point/#module-spotdlconsoleentry_point","text":"Module that holds the entry point for the console. None View Source \"\"\" Module that holds the entry point for the console. \"\"\" import sys import json import signal import logging import cProfile import pstats from spotdl.console.download import download from spotdl.console.preload import preload from spotdl.console.sync import sync from spotdl.console.save import save from spotdl.download import Downloader from spotdl.utils.config import DEFAULT_CONFIG , ConfigError , get_config from spotdl.utils.ffmpeg import FFmpegError , download_ffmpeg , is_ffmpeg_installed from spotdl.utils.config import get_config_file from spotdl.utils.github import check_for_updates from spotdl.utils.arguments import parse_arguments from spotdl.utils.spotify import SpotifyClient , SpotifyError from spotdl.download.downloader import DownloaderError OPEARTIONS = { \"download\" : download , \"preload\" : preload , \"sync\" : sync , \"save\" : save , } def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"asyncio\" ) . setLevel ( logging . WARNING ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : download_ffmpeg () return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Settings from config file will override the ones from the command line settings = {} for key in DEFAULT_CONFIG : if config . get ( key ) is None : # If the key is not in the arguments dict, use the default value settings [ key ] = arguments . __dict__ . get ( key ) or DEFAULT_CONFIG [ key ] else : settings [ key ] = config [ key ] # Check if ffmpeg is installed if is_ffmpeg_installed () is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl.console.web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query.\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) # Pick the operation to perform # based on the name and run it! OPEARTIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) downloader . progress_handler . close () return None def console_entry_point (): \"\"\" Wrapper around `entry_point` so we can profile the code \"\"\" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point ()","title":"Module spotdl.console.entry_point"},{"location":"reference/spotdl/console/entry_point/#variables","text":"DEFAULT_CONFIG OPEARTIONS","title":"Variables"},{"location":"reference/spotdl/console/entry_point/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/entry_point/#console_entry_point","text":"def console_entry_point ( ) Wrapper around entry_point so we can profile the code View Source def console_entry_point () : \" \"\" Wrapper around `entry_point` so we can profile the code \"\" \" if \"--profile\" in sys . argv : with cProfile . Profile () as profile : entry_point () stats = pstats . Stats ( profile ) stats . sort_stats ( pstats . SortKey . TIME ) # Use snakeviz to visualize the profile stats . dump_stats ( \"spotdl.profile\" ) else : entry_point ()","title":"console_entry_point"},{"location":"reference/spotdl/console/entry_point/#entry_point","text":"def entry_point ( ) Console entry point for spotdl. This is where the magic happens. View Source def entry_point (): \"\"\" Console entry point for spotdl. This is where the magic happens. \"\"\" # Don't log too much logging . getLogger ( \"requests\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"urllib3\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"spotipy\" ) . setLevel ( logging . WARNING ) logging . getLogger ( \"asyncio\" ) . setLevel ( logging . WARNING ) if getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 : # If the application is frozen, we check for ffmpeg # if it's not present download it create config file if is_ffmpeg_installed () is False : download_ffmpeg () try : get_config () except ConfigError : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) # Download ffmpeg if the `--download-ffmpeg` flag is passed # This is done before the argument parser so it doesn't require `operation` # and `query` to be passed. Exit after downloading ffmpeg if \"--download-ffmpeg\" in sys . argv : download_ffmpeg () return None # Generate the config file if it doesn't exist # or overwrite the current config file if the `--overwrite-config` flag is passed # This is done before the argument parser so it doesn't requires `operation` # and `query` to be passed. exit after downloading ffmpeg if \"--generate-config\" in sys . argv : config_path = get_config_file () with open ( config_path , \"w\" , encoding = \"utf-8\" ) as config_file : json . dump ( DEFAULT_CONFIG , config_file , indent = 4 ) return None # Get information about the current version and display it # Exit after displaying the version if \"--check-for-updates\" in sys . argv : check_for_updates () return None # Parse the arguments arguments = parse_arguments () # Get the config file # It will automatically load if the `load_config` is set to True # in the config file config = {} if arguments . config or ( get_config_file () . exists () and get_config () . get ( \"load_config\" ) ): config = get_config () # Create settings dict # Settings from config file will override the ones from the command line settings = {} for key in DEFAULT_CONFIG : if config . get ( key ) is None : # If the key is not in the arguments dict, use the default value settings [ key ] = arguments . __dict__ . get ( key ) or DEFAULT_CONFIG [ key ] else : settings [ key ] = config [ key ] # Check if ffmpeg is installed if is_ffmpeg_installed () is False : raise FFmpegError ( \"FFmpeg is not installed. Please run `spotdl --download-ffmpeg` to install it, \" \"or `spotdl --ffmpeg /path/to/ffmpeg` to specify the path to ffmpeg.\" ) # Initialize spotify client SpotifyClient . init ( client_id = settings [ \"client_id\" ], client_secret = settings [ \"client_secret\" ], user_auth = settings [ \"user_auth\" ], cache_path = settings [ \"cache_path\" ], no_cache = settings [ \"no_cache\" ], open_browser = not settings [ \"headless\" ], ) # If the application is frozen start web ui # or if the operation is `web` if ( getattr ( sys , \"frozen\" , False ) and len ( sys . argv ) == 1 or arguments . operation == \"web\" ): from spotdl . console . web import ( # pylint: disable=C0415,C0410,W0707,W0611 web , ) # Don't log too much when running web ui & default logging argument if arguments . __dict__ . get ( \"log_level\" ) is None : settings [ \"log_level\" ] = \"CRITICAL\" # Start web ui web ( settings ) return None # Check if save file is present and if it's valid if isinstance ( settings [ \"save_file\" ], str ) and not settings [ \"save_file\" ] . endswith ( \".spotdl\" ): raise DownloaderError ( \"Save file has to end with .spotdl\" ) if arguments . query and \"saved\" in arguments . query and not settings [ \"user_auth\" ]: raise SpotifyError ( \"You must be logged in to use the saved query.\" ) # Initialize the downloader # for download, load and preload operations downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], search_query = settings [ \"search_query\" ], cookie_file = settings [ \"cookie_file\" ], log_level = settings [ \"log_level\" ], simple_tui = settings [ \"simple_tui\" ], restrict = settings [ \"restrict\" ], print_errors = settings [ \"print_errors\" ], sponsor_block = settings [ \"sponsor_block\" ], ) def graceful_exit ( _signal , _frame ): downloader . progress_handler . close () sys . exit ( 0 ) signal . signal ( signal . SIGINT , graceful_exit ) signal . signal ( signal . SIGTERM , graceful_exit ) # Pick the operation to perform # based on the name and run it! OPEARTIONS [ arguments . operation ]( query = arguments . query , save_path = settings [ \"save_file\" ], downloader = downloader , m3u_file = settings [ \"m3u\" ], ) downloader . progress_handler . close () return None","title":"entry_point"},{"location":"reference/spotdl/console/preload/","text":"Module spotdl.console.preload Preload module for the console. None View Source \"\"\" Preload module for the console. \"\"\" import json import concurrent.futures from pathlib import Path from typing import List , Optional from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.m3u import create_m3u_file def preload ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Use audio provider to find the download links for the songs and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to the file to save the metadata to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for { song . display_name } \" ) continue downloader . progress_handler . log ( f \"Found url for { song . display_name } : { data } \" ) save_data . append ({ ** song . json , \"download_url\" : data }) except Exception as exc : downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" ) Functions preload def preload ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Use audio provider to find the download links for the songs and save them to the disk. Arguments query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to the file to save the metadata to. Notes This function is multi-threaded. View Source def preload ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Use audio provider to find the download links for the songs and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to the file to save the metadata to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ) : song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ) : song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for {song.display_name}\" ) continue downloader . progress_handler . log ( f \"Found url for {song.display_name}: {data}\" ) save_data . append ( { ** song . json , \"download_url\" : data } ) except Exception as exc : downloader . progress_handler . error ( f \"{song} generated an exception: {exc}\" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved {len(save_data)} song{'s' if len(save_data) > 1 else ''} to {save_path}\" )","title":"Preload"},{"location":"reference/spotdl/console/preload/#module-spotdlconsolepreload","text":"Preload module for the console. None View Source \"\"\" Preload module for the console. \"\"\" import json import concurrent.futures from pathlib import Path from typing import List , Optional from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.m3u import create_m3u_file def preload ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Use audio provider to find the download links for the songs and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to the file to save the metadata to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ): song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ): song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for { song . display_name } \" ) continue downloader . progress_handler . log ( f \"Found url for { song . display_name } : { data } \" ) save_data . append ({ ** song . json , \"download_url\" : data }) except Exception as exc : downloader . progress_handler . error ( f \" { song } generated an exception: { exc } \" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" )","title":"Module spotdl.console.preload"},{"location":"reference/spotdl/console/preload/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/preload/#preload","text":"def preload ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Use audio provider to find the download links for the songs and save them to the disk.","title":"preload"},{"location":"reference/spotdl/console/preload/#arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to the file to save the metadata to.","title":"Arguments"},{"location":"reference/spotdl/console/preload/#notes","text":"This function is multi-threaded. View Source def preload ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Use audio provider to find the download links for the songs and save them to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to the file to save the metadata to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) save_data = [] with concurrent . futures . ThreadPoolExecutor ( max_workers = downloader . threads ) as executor : future_to_song = { executor . submit ( downloader . search , song ) : song for song in songs } for future in concurrent . futures . as_completed ( future_to_song ) : song = future_to_song [ future ] try : data , _ = future . result () if data is None : downloader . progress_handler . error ( f \"Could not find a match for {song.display_name}\" ) continue downloader . progress_handler . log ( f \"Found url for {song.display_name}: {data}\" ) save_data . append ( { ** song . json , \"download_url\" : data } ) except Exception as exc : downloader . progress_handler . error ( f \"{song} generated an exception: {exc}\" ) # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved {len(save_data)} song{'s' if len(save_data) > 1 else ''} to {save_path}\" )","title":"Notes"},{"location":"reference/spotdl/console/save/","text":"Module spotdl.console.save Save module for the console. None View Source \"\"\" Save module for the console. \"\"\" import json from typing import List , Optional from pathlib import Path from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.m3u import create_m3u_file def save ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) # Convert the songs to JSON save_data = [ song . json for song in songs ] # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) # Create an m3u file if requested if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" ) Functions save def save ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Save metadata from spotify to the disk. Arguments query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the m3u file to save the songs to. Notes This function is multi-threaded. View Source def save ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) # Convert the songs to JSON save_data = [ song.json for song in songs ] # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) # Create an m3u file if requested if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved {len(save_data)} song{'s' if len(save_data) > 1 else ''} to {save_path}\" )","title":"Save"},{"location":"reference/spotdl/console/save/#module-spotdlconsolesave","text":"Save module for the console. None View Source \"\"\" Save module for the console. \"\"\" import json from typing import List , Optional from pathlib import Path from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.m3u import create_m3u_file def save ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) # Convert the songs to JSON save_data = [ song . json for song in songs ] # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) # Create an m3u file if requested if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved { len ( save_data ) } song { 's' if len ( save_data ) > 1 else '' } to { save_path } \" )","title":"Module spotdl.console.save"},{"location":"reference/spotdl/console/save/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/save/#save","text":"def save ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Save metadata from spotify to the disk.","title":"save"},{"location":"reference/spotdl/console/save/#arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the m3u file to save the songs to.","title":"Arguments"},{"location":"reference/spotdl/console/save/#notes","text":"This function is multi-threaded. View Source def save ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Save metadata from spotify to the disk. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the m3u file to save the songs to. ### Notes - This function is multi-threaded. \"\"\" # Parse the query songs = parse_query ( query , downloader . threads ) # Convert the songs to JSON save_data = [ song.json for song in songs ] # Save the songs to a file with open ( save_path , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( save_data , save_file , indent = 4 , ensure_ascii = False ) # Create an m3u file if requested if m3u_file : create_m3u_file ( m3u_file , songs , downloader . output , downloader . output_format , False ) downloader . progress_handler . log ( f \"Saved {len(save_data)} song{'s' if len(save_data) > 1 else ''} to {save_path}\" )","title":"Notes"},{"location":"reference/spotdl/console/sync/","text":"Module spotdl.console.sync Sync module for the console. None View Source \"\"\" Sync module for the console. \"\"\" import glob import traceback from pathlib import Path from typing import List , Optional from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.formatter import create_file_name from spotdl.utils.m3u import create_m3u_file def sync ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Removes the songs that are no longer present in the list and downloads the new ones. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" # Parse the query songs_list = parse_query ( query , downloader . threads ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) # Get all files that are in the output directory parent_dir = Path ( downloader . output ) . parent old_files = [ Path ( file ) for file in glob . glob ( f \" { parent_dir } /*. { downloader . output_format } \" ) ] # Get all output file names new_files = [ create_file_name ( song , downloader . output , downloader . output_format ) for song in songs_list ] # Get all files that are no longer in the query to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the query for file in to_delete : file . unlink () # Download the rest of the songs try : to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ) . exists (): if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting { song . display_name } \" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return downloader . download_multiple_songs ( to_download ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception )) Functions sync def sync ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Removes the songs that are no longer present in the list and downloads the new ones. Arguments query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the file to save the metadata to. View Source def sync ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Removes the songs that are no longer present in the list and downloads the new ones. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" # Parse the query songs_list = parse_query ( query , downloader . threads ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) # Get all files that are in the output directory parent_dir = Path ( downloader . output ). parent old_files = [ Path(file) for file in glob.glob(f\"{parent_dir}/*.{downloader.output_format}\") ] # Get all output file names new_files = [ create_file_name(song, downloader.output, downloader.output_format) for song in songs_list ] # Get all files that are no longer in the query to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the query for file in to_delete : file . unlink () # Download the rest of the songs try : to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ). exists () : if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting {song.display_name}\" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return downloader . download_multiple_songs ( to_download ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Sync"},{"location":"reference/spotdl/console/sync/#module-spotdlconsolesync","text":"Sync module for the console. None View Source \"\"\" Sync module for the console. \"\"\" import glob import traceback from pathlib import Path from typing import List , Optional from spotdl.download.downloader import Downloader from spotdl.utils.search import parse_query from spotdl.utils.formatter import create_file_name from spotdl.utils.m3u import create_m3u_file def sync ( query : List [ str ], downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Removes the songs that are no longer present in the list and downloads the new ones. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" # Parse the query songs_list = parse_query ( query , downloader . threads ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) # Get all files that are in the output directory parent_dir = Path ( downloader . output ) . parent old_files = [ Path ( file ) for file in glob . glob ( f \" { parent_dir } /*. { downloader . output_format } \" ) ] # Get all output file names new_files = [ create_file_name ( song , downloader . output , downloader . output_format ) for song in songs_list ] # Get all files that are no longer in the query to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the query for file in to_delete : file . unlink () # Download the rest of the songs try : to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ) . exists (): if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting { song . display_name } \" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return downloader . download_multiple_songs ( to_download ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Module spotdl.console.sync"},{"location":"reference/spotdl/console/sync/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/sync/#sync","text":"def sync ( query : List [ str ], downloader : spotdl . download . downloader . Downloader , save_path : pathlib . Path , m3u_file : Optional [ str ] = None ) -> None Removes the songs that are no longer present in the list and downloads the new ones.","title":"sync"},{"location":"reference/spotdl/console/sync/#arguments","text":"query: list of strings to search for. downloader: Already initialized downloader instance. save_path: Path to save the songs to. m3u_file: Path to the file to save the metadata to. View Source def sync ( query : List [ str ] , downloader : Downloader , save_path : Path , m3u_file : Optional [ str ] = None , ) -> None : \"\"\" Removes the songs that are no longer present in the list and downloads the new ones. ### Arguments - query: list of strings to search for. - downloader: Already initialized downloader instance. - save_path: Path to save the songs to. - m3u_file: Path to the file to save the metadata to. \"\"\" # Parse the query songs_list = parse_query ( query , downloader . threads ) if m3u_file : create_m3u_file ( m3u_file , songs_list , downloader . output , downloader . output_format , False ) # Get all files that are in the output directory parent_dir = Path ( downloader . output ). parent old_files = [ Path(file) for file in glob.glob(f\"{parent_dir}/*.{downloader.output_format}\") ] # Get all output file names new_files = [ create_file_name(song, downloader.output, downloader.output_format) for song in songs_list ] # Get all files that are no longer in the query to_delete = set ( old_files ) - set ( new_files ) # Delete all files that are no longer in the query for file in to_delete : file . unlink () # Download the rest of the songs try : to_download = [] for song in songs_list : song_path = create_file_name ( song , downloader . output , downloader . output_format ) if Path ( song_path ). exists () : if downloader . overwrite == \"force\" : downloader . progress_handler . log ( f \"Overwriting {song.display_name}\" ) to_download . append ( song ) else : to_download . append ( song ) if len ( to_download ) == 0 : downloader . progress_handler . log ( \"Nothing to do...\" ) return downloader . download_multiple_songs ( to_download ) except Exception as exception : downloader . progress_handler . debug ( traceback . format_exc ()) downloader . progress_handler . error ( str ( exception ))","title":"Arguments"},{"location":"reference/spotdl/console/web/","text":"Module spotdl.console.web Web module for the console. None View Source \"\"\" Web module for the console. \"\"\" import asyncio import logging import os import json import webbrowser from typing import Any , Dict , List , Optional , Tuple , Union from pathlib import Path from fastapi import FastAPI , Response , WebSocket , WebSocketDisconnect , HTTPException from fastapi.responses import FileResponse from fastapi.staticfiles import StaticFiles from fastapi.middleware.cors import CORSMiddleware from pydantic import BaseModel # pylint: disable=E0611 from uvicorn import Config , Server from starlette.types import Scope import nest_asyncio from spotdl.download.downloader import Downloader , DownloaderError from spotdl.download.progress_handler import NAME_TO_LEVEL , ProgressHandler , SongTracker from spotdl.types.song import Song from spotdl.utils.github import download_github_dir from spotdl.utils.search import parse_query from spotdl.utils.search import get_search_results from spotdl.utils.config import get_spotdl_path ALLOWED_ORIGINS = [ \"http://localhost:8800\" , \"https://127.0.0.1:8800\" , \"http://localhost:3000\" , \"http://localhost:8080\" , \"*\" , ] class App : \"\"\" App class that holds the application state. \"\"\" server : Any downloader : Downloader settings : Dict [ str , Any ] loop : asyncio . AbstractEventLoop class SongModel ( BaseModel ): \"\"\" A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int copyright : str duration : int year : int date : str track_number : int tracks_count : int isrc : str song_id : str cover_url : str explicit : bool publisher : str url : str download_url : Optional [ str ] = None class SettingsModel ( BaseModel ): \"\"\" A settings object used for types and validation. \"\"\" log_level : Optional [ str ] cache_path : Optional [ str ] audio_providers : Optional [ List [ str ]] lyrics_providers : Optional [ List [ str ]] ffmpeg : Optional [ str ] variable_bitrate : Optional [ int ] constant_bitrate : Optional [ int ] ffmpeg_args : Optional [ List [ str ]] format : Optional [ str ] save_file : Optional [ str ] m3u : Optional [ str ] output : Optional [ str ] overwrite : Optional [ str ] client_id : Optional [ str ] client_secret : Optional [ str ] user_auth : Optional [ bool ] threads : Optional [ int ] app = App () app . server = FastAPI () app . server . add_middleware ( CORSMiddleware , allow_origins = ALLOWED_ORIGINS , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) nest_asyncio . apply () class WSProgressHandler : \"\"\" Handles all the WebSocket connections. \"\"\" instances : List [ \"WSProgressHandler\" ] = [] def __init__ ( self , websocket : WebSocket , client_id : str ): \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket async def connect ( self ): \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) @classmethod def get ( cls , client_id : str ): \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None async def send_update ( self , message : str ): \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s : %s \" , self . client_id , message ) await self . websocket . send_text ( message ) def update ( self , progress_handler_instance : SongTracker , message : str ): \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message ))) @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ): \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ) . connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s \" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s \" , client_id ) @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query ) @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url ) @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ]) -> List [ Song ]: \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query ) @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ]: \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return get_search_results ( query ) @app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ]: \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/ { client_id } \" ) . absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app . settings [ \"log_level\" ]], simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading { song . name } \" ) logging . warning ( \"Error downloading! %s \" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exc } \" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s \" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exception } \" ) from exception @app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/ { client_id } / { file } \" ) . absolute ()), filename = file , ) @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query )) @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ], ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song . from_dict ( song . dict ()) for song in songs ] ) @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings ) @app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True class SPAStaticFiles ( StaticFiles ): \"\"\" Override the static files to serve the index.html and other assets. \"\"\" async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super () . get_response ( path , scope ) if response . status_code == 404 : response = await super () . get_response ( \".\" , scope ) return response def web ( settings : Dict [ str , Any ]): \"\"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\"\" web_app_dir = str ( get_spotdl_path () . absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . settings = settings app . downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], log_level = settings [ \"log_level\" ], simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close () Variables ALLOWED_ORIGINS NAME_TO_LEVEL app Functions change_output def change_output ( output : str ) -> bool Change output folder Arguments output: The output folder. Returns returns True if the output folder was changed. View Source @ app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True change_settings def change_settings ( settings : spotdl . console . web . SettingsModel ) -> bool Change downloader settings by re-initializing the downloader. Arguments settings: The settings to change. Returns returns True if the settings were changed. View Source @ app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True download_file def download_file ( file : str , client_id : str ) -> starlette . responses . FileResponse Download file using path. Arguments file: The file path. client_id: The client's ID. Returns returns the file response, filename specified to return as attachment. View Source @ app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/{client_id}/{file}\" ) . absolute ()), filename = file , ) download_multiple_objects def download_multiple_objects ( songs : List [ spotdl . console . web . SongModel ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download songs using Song objects. Arguments songs: The list of Song objects. Returns returns a list of Tuple of Song and Path if the song was downloaded. View Source @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ] , ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song.from_dict(song.dict()) for song in songs ] ) download_multiple_search def download_multiple_search ( query : List [ str ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Search for song and download the first result. Arguments query: The query to search. Returns returns a list of Tuple of Song and Path if the song was downloaded. View Source @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query )) download_objects def download_objects ( song : spotdl . console . web . SongModel , return_file : bool = False ) -> Union [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]], starlette . responses . FileResponse ] Download songs using Song objects. Arguments song: The Song object. return_file: If True, return the file instead of the song. Returns returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. View Source @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple[Song, Optional[Path ] ] , FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path download_search def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]], starlette . responses . FileResponse ] Search for song and download the first result. Arguments query: The query to search. return_file: If True, return the file instead of the song. Returns returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. View Source @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple[Song, Optional[Path ] ] , FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path download_url def download_url ( url : str , client_id : str ) -> Optional [ str ] Download songs using Song url. Arguments url: The url to download. client_id: The client's ID. Returns returns the file path if the song was downloaded. View Source @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ] : \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/{client_id}\" ). absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app.settings[\"log_level\" ] ] , simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading {song.name}\" ) logging . warning ( \"Error downloading! %s\" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: {exc}\" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s\" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: {exception}\" ) from exception get_settings def get_settings ( ) -> spotdl . console . web . SettingsModel Return the settings object. Returns returns the settings object. View Source @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings ) query_search def query_search ( query : List [ str ] ) -> List [ spotdl . types . song . Song ] Parse a list of search queries. Arguments query: The query to parse. Returns returns a list of Song objects. View Source @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ] ) -> List [ Song ] : \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query ) search_search def search_search ( query : str ) -> List [ spotdl . types . song . Song ] Parse search term and return list of Song objects. Arguments query: The query to parse. Returns returns a list of Song objects. View Source @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ] : \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return get_search_results ( query ) song_from_search def song_from_search ( query : str ) -> spotdl . types . song . Song Search for a song on spotify using search query. Arguments query: The search query. Returns returns the first result as a Song object. View Source @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query ) song_from_url def song_from_url ( url : str ) -> spotdl . types . song . Song Search for a song on spotify using url. Arguments url: The url to search. Returns returns the first result as a Song object. View Source @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url ) web def web ( settings : Dict [ str , Any ] ) Run the web server. Arguments settings: Settings dictionary, based on the SettingsModel class. View Source def web ( set tings : Dict [ str , Any ] ) : \" \"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\" \" web_app_dir = str ( get_spotdl_path (). absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . set tings = set tings app . downloader = Downloader ( audio_providers = set tings [ \"audio_providers\" ] , lyrics_providers = set tings [ \"lyrics_providers\" ] , ffmpeg = set tings [ \"ffmpeg\" ] , bitrate = set tings [ \"bitrate\" ] , ffmpeg_args = set tings [ \"ffmpeg_args\" ] , output_format = set tings [ \"format\" ] , save_file = set tings [ \"save_file\" ] , threads = set tings [ \"threads\" ] , output = set tings [ \"output\" ] , overwrite = set tings [ \"overwrite\" ] , log_level = set tings [ \"log_level\" ] , simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close () websocket_endpoint def websocket_endpoint ( websocket : starlette . websockets . WebSocket , client_id : str ) Websocket endpoint. Arguments websocket: The WebSocket instance. client_id: The client's ID. View Source @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ) : \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ). connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s\" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s\" , client_id ) Classes App class App ( / , * args , ** kwargs ) View Source class App : \"\"\" App class that holds the application state. \"\"\" server : Any downloader : Downloader settings : Dict [ str , Any ] loop : asyncio . AbstractEventLoop SPAStaticFiles class SPAStaticFiles ( * , directory : Union [ str , ForwardRef ( 'os.PathLike[str]' )] = None , packages : List [ str ] = None , html : bool = False , check_dir : bool = True ) View Source class SPAStaticFiles ( StaticFiles ): \"\"\" Override the static files to serve the index.html and other assets. \"\"\" async def get_response ( self , path: str , scope: Scope ) -> Response: \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super (). get_response ( path , scope ) if response . status_code == 404 : response = await super (). get_response ( \".\" , scope ) return response Ancestors (in MRO) starlette.staticfiles.StaticFiles Methods check_config def check_config ( self ) -> None Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses. View Source async def check_config ( self ) -> None : \"\"\" Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses. \"\"\" if self . directory is None : return try : stat_result = await anyio . to_thread . run_sync ( os . stat , self . directory ) except FileNotFoundError : raise RuntimeError ( f \"StaticFiles directory ' { self . directory } ' does not exist.\" ) if not ( stat . S_ISDIR ( stat_result . st_mode ) or stat . S_ISLNK ( stat_result . st_mode )) : raise RuntimeError ( f \"StaticFiles path ' { self . directory } ' is not a directory.\" ) file_response def file_response ( self , full_path : Union [ str , ForwardRef ( 'os.PathLike[str]' )], stat_result : os . stat_result , scope : MutableMapping [ str , Any ], status_code : int = 200 ) -> starlette . responses . Response View Source def file_response ( self , full_path : PathLike , stat_result : os . stat_result , scope : Scope , status_code : int = 200 , ) -> Response : method = scope [ \"method\" ] request_headers = Headers ( scope = scope ) response = FileResponse ( full_path , status_code = status_code , stat_result = stat_result , method = method ) if self . is_not_modified ( response . headers , request_headers ) : return NotModifiedResponse ( response . headers ) return response get_directories def get_directories ( self , directory : Union [ str , ForwardRef ( 'os.PathLike[str]' )] = None , packages : List [ str ] = None ) -> List [ Union [ str , ForwardRef ( 'os.PathLike[str]' )]] Given directory and packages arguments, return a list of all the directories that should be used for serving static files from. View Source def get_directories ( self , directory : PathLike = None , packages : typing . List [ str ] = None ) -> typing . List [ PathLike ] : \" \"\" Given `directory` and `packages` arguments, return a list of all the directories that should be used for serving static files from. \"\" \" directories = [] if directory is not None : directories . append ( directory ) for package in packages or [] : spec = importlib . util . find_spec ( package ) assert spec is not None , f \"Package {package!r} could not be found.\" assert ( spec . origin is not None ), f \"Directory 'statics' in package {package!r} could not be found.\" package_directory = os . path . normpath ( os . path . join ( spec . origin , \"..\" , \"statics\" ) ) assert os . path . isdir ( package_directory ), f \"Directory 'statics' in package {package!r} could not be found.\" directories . append ( package_directory ) return directories get_path def get_path ( self , scope : MutableMapping [ str , Any ] ) -> str Given the ASGI scope, return the path string to serve up, with OS specific path seperators, and any '..', '.' components removed. View Source def get_path ( self , scope : Scope ) -> str : \" \"\" Given the ASGI scope, return the `path` string to serve up, with OS specific path seperators, and any '..', '.' components removed. \"\" \" return os . path . normpath ( os . path . join ( * scope [ \"path\" ] . split ( \"/\" ))) get_response def get_response ( self , path : str , scope : MutableMapping [ str , Any ] ) -> starlette . responses . Response Serve static files from the SPA. Arguments path: The path to the file. scope: The scope of the request. Returns returns the response. View Source async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super (). get_response ( path , scope ) if response . status_code == 404 : response = await super (). get_response ( \".\" , scope ) return response is_not_modified def is_not_modified ( self , response_headers : starlette . datastructures . Headers , request_headers : starlette . datastructures . Headers ) -> bool Given the request and response headers, return True if an HTTP \"Not Modified\" response could be returned instead. View Source def is_not_modified ( self , response_headers : Headers , request_headers : Headers ) -> bool : \" \"\" Given the request and response headers, return `True` if an HTTP \" Not Modified \" response could be returned instead. \"\" \" try : if_none_match = request_headers [ \"if-none-match\" ] etag = response_headers [ \"etag\" ] if if_none_match == etag : return True except KeyError : pass try : if_modified_since = parsedate ( request_headers [ \"if-modified-since\" ] ) last_modified = parsedate ( response_headers [ \"last-modified\" ] ) if ( if_modified_since is not None and last_modified is not None and if_modified_since >= last_modified ) : return True except KeyError : pass return False lookup_path def lookup_path ( self , path : str ) -> Tuple [ str , Optional [ os . stat_result ]] View Source def lookup_path ( self , path : str ) -> typing . Tuple [ str , typing . Optional [ os . stat_result ]] : for directory in self . all_directories : full_path = os . path . realpath ( os . path . join ( directory , path )) directory = os . path . realpath ( directory ) if os . path . commonprefix ([ full_path , directory ]) != directory : # Don 't allow misbehaving clients to break out of the static files # directory. continue try: return full_path, os.stat(full_path) except (FileNotFoundError, NotADirectoryError): continue return \"\", None SettingsModel class SettingsModel ( __pydantic_self__ , ** data : Any ) View Source class SettingsModel ( BaseModel ) : \"\"\" A settings object used for types and validation. \"\"\" log_level : Optional [ str ] cache_path : Optional [ str ] audio_providers : Optional [ List[str ] ] lyrics_providers : Optional [ List[str ] ] ffmpeg : Optional [ str ] variable_bitrate : Optional [ int ] constant_bitrate : Optional [ int ] ffmpeg_args : Optional [ List[str ] ] format : Optional [ str ] save_file : Optional [ str ] m3u : Optional [ str ] output : Optional [ str ] overwrite : Optional [ str ] client_id : Optional [ str ] client_secret : Optional [ str ] user_auth : Optional [ bool ] threads : Optional [ int ] Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . SongModel class SongModel ( __pydantic_self__ , ** data : Any ) View Source class SongModel ( BaseModel ) : \"\"\" A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int copyright : str duration : int year : int date : str track_number : int tracks_count : int isrc : str song_id : str cover_url : str explicit : bool publisher : str url : str download_url : Optional [ str ] = None Ancestors (in MRO) pydantic.main.BaseModel pydantic.utils.Representation Class variables Config Static methods construct def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values from_orm def from_orm ( obj : Any ) -> 'Model' parse_file def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' parse_obj def parse_obj ( obj : Any ) -> 'Model' parse_raw def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model' schema def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny' schema_json def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode' update_forward_refs def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns. validate def validate ( value : Any ) -> 'Model' Methods copy def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance dict def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. json def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . WSProgressHandler class WSProgressHandler ( websocket : starlette . websockets . WebSocket , client_id : str ) View Source class WSProgressHandler : \"\"\" Handles all the WebSocket connections. \"\"\" instances : List [ \"WSProgressHandler\" ] = [] def __init__ ( self , websocket : WebSocket , client_id : str ) : \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket async def connect ( self ) : \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s\" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) @classmethod def get ( cls , client_id : str ) : \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None async def send_update ( self , message : str ) : \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s: %s\" , self . client_id , message ) await self . websocket . send_text ( message ) def update ( self , progress_handler_instance : SongTracker , message : str ) : \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message ))) Class variables instances Static methods get def get ( client_id : str ) Get a WSProgressHandler instance by client_id. Arguments client_id: The client's ID. View Source @classmethod def get ( cls , client_id : str ) : \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None Methods connect def connect ( self ) Called when a new client connects to the websocket. View Source async def connect ( self ) : \"\"\" Called when a new client connects to the websocket . \"\"\" connection = { \" client_id \" : self . client_id , \" websocket \" : self . websocket } logging . info ( \" Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) send_update def send_update ( self , message : str ) Send an update to the client. Arguments message: The message to send. View Source async def send_update ( self , message : str ) : \"\"\" Send an update to the client . ### Arguments - message : The message to send . \"\"\" logging . debug ( \" Sending %s: %s \" , self . client_id , message ) await self . websocket . send_text ( message ) update def update ( self , progress_handler_instance : spotdl . download . progress_handler . SongTracker , message : str ) Callback function from ProgressHandler's SongTracker, called on every update Arguments progress_handler_instance: The ProgressHandler instance. message: The message to send. View Source def update ( self , progress_handler_instance : SongTracker , message : str ) : \"\"\" Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance : The ProgressHandler instance . - message : The message to send . \"\"\" update_message = { \" song \" : progress_handler_instance . song . json , \" progress \" : progress_handler_instance . progress , \" message \" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message )))","title":"Web"},{"location":"reference/spotdl/console/web/#module-spotdlconsoleweb","text":"Web module for the console. None View Source \"\"\" Web module for the console. \"\"\" import asyncio import logging import os import json import webbrowser from typing import Any , Dict , List , Optional , Tuple , Union from pathlib import Path from fastapi import FastAPI , Response , WebSocket , WebSocketDisconnect , HTTPException from fastapi.responses import FileResponse from fastapi.staticfiles import StaticFiles from fastapi.middleware.cors import CORSMiddleware from pydantic import BaseModel # pylint: disable=E0611 from uvicorn import Config , Server from starlette.types import Scope import nest_asyncio from spotdl.download.downloader import Downloader , DownloaderError from spotdl.download.progress_handler import NAME_TO_LEVEL , ProgressHandler , SongTracker from spotdl.types.song import Song from spotdl.utils.github import download_github_dir from spotdl.utils.search import parse_query from spotdl.utils.search import get_search_results from spotdl.utils.config import get_spotdl_path ALLOWED_ORIGINS = [ \"http://localhost:8800\" , \"https://127.0.0.1:8800\" , \"http://localhost:3000\" , \"http://localhost:8080\" , \"*\" , ] class App : \"\"\" App class that holds the application state. \"\"\" server : Any downloader : Downloader settings : Dict [ str , Any ] loop : asyncio . AbstractEventLoop class SongModel ( BaseModel ): \"\"\" A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int copyright : str duration : int year : int date : str track_number : int tracks_count : int isrc : str song_id : str cover_url : str explicit : bool publisher : str url : str download_url : Optional [ str ] = None class SettingsModel ( BaseModel ): \"\"\" A settings object used for types and validation. \"\"\" log_level : Optional [ str ] cache_path : Optional [ str ] audio_providers : Optional [ List [ str ]] lyrics_providers : Optional [ List [ str ]] ffmpeg : Optional [ str ] variable_bitrate : Optional [ int ] constant_bitrate : Optional [ int ] ffmpeg_args : Optional [ List [ str ]] format : Optional [ str ] save_file : Optional [ str ] m3u : Optional [ str ] output : Optional [ str ] overwrite : Optional [ str ] client_id : Optional [ str ] client_secret : Optional [ str ] user_auth : Optional [ bool ] threads : Optional [ int ] app = App () app . server = FastAPI () app . server . add_middleware ( CORSMiddleware , allow_origins = ALLOWED_ORIGINS , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) nest_asyncio . apply () class WSProgressHandler : \"\"\" Handles all the WebSocket connections. \"\"\" instances : List [ \"WSProgressHandler\" ] = [] def __init__ ( self , websocket : WebSocket , client_id : str ): \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket async def connect ( self ): \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) @classmethod def get ( cls , client_id : str ): \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None async def send_update ( self , message : str ): \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s : %s \" , self . client_id , message ) await self . websocket . send_text ( message ) def update ( self , progress_handler_instance : SongTracker , message : str ): \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message ))) @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ): \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ) . connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s \" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s \" , client_id ) @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query ) @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url ) @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ]) -> List [ Song ]: \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query ) @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ]: \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return get_search_results ( query ) @app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple [ Song , Optional [ Path ]], FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ]: \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/ { client_id } \" ) . absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app . settings [ \"log_level\" ]], simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading { song . name } \" ) logging . warning ( \"Error downloading! %s \" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exc } \" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s \" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: { exception } \" ) from exception @app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/ { client_id } / { file } \" ) . absolute ()), filename = file , ) @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ]) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query )) @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ], ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song . from_dict ( song . dict ()) for song in songs ] ) @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings ) @app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True class SPAStaticFiles ( StaticFiles ): \"\"\" Override the static files to serve the index.html and other assets. \"\"\" async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super () . get_response ( path , scope ) if response . status_code == 404 : response = await super () . get_response ( \".\" , scope ) return response def web ( settings : Dict [ str , Any ]): \"\"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\"\" web_app_dir = str ( get_spotdl_path () . absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . settings = settings app . downloader = Downloader ( audio_providers = settings [ \"audio_providers\" ], lyrics_providers = settings [ \"lyrics_providers\" ], ffmpeg = settings [ \"ffmpeg\" ], bitrate = settings [ \"bitrate\" ], ffmpeg_args = settings [ \"ffmpeg_args\" ], output_format = settings [ \"format\" ], save_file = settings [ \"save_file\" ], threads = settings [ \"threads\" ], output = settings [ \"output\" ], overwrite = settings [ \"overwrite\" ], log_level = settings [ \"log_level\" ], simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close ()","title":"Module spotdl.console.web"},{"location":"reference/spotdl/console/web/#variables","text":"ALLOWED_ORIGINS NAME_TO_LEVEL app","title":"Variables"},{"location":"reference/spotdl/console/web/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/console/web/#change_output","text":"def change_output ( output : str ) -> bool Change output folder","title":"change_output"},{"location":"reference/spotdl/console/web/#arguments","text":"output: The output folder.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns","text":"returns True if the output folder was changed. View Source @ app . server . post ( \"/api/downloader/change_output\" ) def change_output ( output : str ) -> bool : \"\"\" Change output folder ### Arguments - output: The output folder. ### Returns - returns True if the output folder was changed. \"\"\" app . downloader . output = output return True","title":"Returns"},{"location":"reference/spotdl/console/web/#change_settings","text":"def change_settings ( settings : spotdl . console . web . SettingsModel ) -> bool Change downloader settings by re-initializing the downloader.","title":"change_settings"},{"location":"reference/spotdl/console/web/#arguments_1","text":"settings: The settings to change.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_1","text":"returns True if the settings were changed. View Source @ app . server . post ( \"/api/settings/update\" ) def change_settings ( settings : SettingsModel ) -> bool : \"\"\" Change downloader settings by re-initializing the downloader. ### Arguments - settings: The settings to change. ### Returns - returns True if the settings were changed. \"\"\" settings_dict = settings . dict () # Create shallow copy of settings settings_cpy = app . settings . copy () # Update settings with new settings that are not None settings_cpy . update ({ k : v for k , v in settings_dict . items () if v is not None }) logging . debug ( \"Applying settings: %s \" , { settings_cpy }) # Re-initialize downloader app . downloader = Downloader ( audio_providers = settings_cpy [ \"audio_providers\" ], lyrics_providers = settings_cpy [ \"lyrics_providers\" ], ffmpeg = settings_cpy [ \"ffmpeg\" ], bitrate = settings_cpy [ \"bitrate\" ], ffmpeg_args = settings_cpy [ \"ffmpeg_args\" ], output_format = settings_cpy [ \"format\" ], save_file = settings_cpy [ \"save_file\" ], threads = settings_cpy [ \"threads\" ], output = settings_cpy [ \"output\" ], overwrite = settings_cpy [ \"overwrite\" ], log_level = \"CRITICAL\" , simple_tui = True , loop = app . loop , ) return True","title":"Returns"},{"location":"reference/spotdl/console/web/#download_file","text":"def download_file ( file : str , client_id : str ) -> starlette . responses . FileResponse Download file using path.","title":"download_file"},{"location":"reference/spotdl/console/web/#arguments_2","text":"file: The file path. client_id: The client's ID.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_2","text":"returns the file response, filename specified to return as attachment. View Source @ app . server . get ( \"/api/download/file\" ) async def download_file ( file : str , client_id : str ) -> FileResponse : \"\"\" Download file using path. ### Arguments - file: The file path. - client_id: The client's ID. ### Returns - returns the file response, filename specified to return as attachment. \"\"\" return FileResponse ( str (( get_spotdl_path () / f \"web/sessions/{client_id}/{file}\" ) . absolute ()), filename = file , )","title":"Returns"},{"location":"reference/spotdl/console/web/#download_multiple_objects","text":"def download_multiple_objects ( songs : List [ spotdl . console . web . SongModel ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download songs using Song objects.","title":"download_multiple_objects"},{"location":"reference/spotdl/console/web/#arguments_3","text":"songs: The list of Song objects.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_3","text":"returns a list of Tuple of Song and Path if the song was downloaded. View Source @app . server . post ( \"/api/download/multiple_objects\" ) def download_multiple_objects ( songs : List [ SongModel ] , ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download songs using Song objects. ### Arguments - songs: The list of Song objects. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( [ Song.from_dict(song.dict()) for song in songs ] )","title":"Returns"},{"location":"reference/spotdl/console/web/#download_multiple_search","text":"def download_multiple_search ( query : List [ str ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Search for song and download the first result.","title":"download_multiple_search"},{"location":"reference/spotdl/console/web/#arguments_4","text":"query: The query to search.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_4","text":"returns a list of Tuple of Song and Path if the song was downloaded. View Source @app . server . post ( \"/api/download/multiple_search\" ) def download_multiple_search ( query : List [ str ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. ### Returns - returns a list of Tuple of Song and Path if the song was downloaded. \"\"\" return app . downloader . download_multiple_songs ( parse_query ( query ))","title":"Returns"},{"location":"reference/spotdl/console/web/#download_objects","text":"def download_objects ( song : spotdl . console . web . SongModel , return_file : bool = False ) -> Union [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]], starlette . responses . FileResponse ] Download songs using Song objects.","title":"download_objects"},{"location":"reference/spotdl/console/web/#arguments_5","text":"song: The Song object. return_file: If True, return the file instead of the song.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_5","text":"returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. View Source @app . server . post ( \"/api/download/objects\" ) async def download_objects ( song : SongModel , return_file : bool = False ) -> Union [ Tuple[Song, Optional[Path ] ] , FileResponse ]: \"\"\" Download songs using Song objects. ### Arguments - song: The Song object. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song_obj , path = await app . downloader . pool_download ( Song ( ** song . dict ())) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song_obj , path","title":"Returns"},{"location":"reference/spotdl/console/web/#download_search","text":"def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]], starlette . responses . FileResponse ] Search for song and download the first result.","title":"download_search"},{"location":"reference/spotdl/console/web/#arguments_6","text":"query: The query to search. return_file: If True, return the file instead of the song.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_6","text":"returns a Tuple of Song and Path if return_file is True. returns a FileResponse if return_file is False. View Source @app . server . post ( \"/api/downloader/download/search\" ) async def download_search ( query : str , return_file : bool = False ) -> Union [ Tuple[Song, Optional[Path ] ] , FileResponse ]: \"\"\" Search for song and download the first result. ### Arguments - query: The query to search. - return_file: If True, return the file instead of the song. ### Returns - returns a Tuple of Song and Path if return_file is True. - returns a FileResponse if return_file is False. \"\"\" song , path = await app . downloader . pool_download ( Song . from_search_term ( query )) if return_file is True : if path is None : raise ValueError ( \"No file found\" ) return FileResponse ( path ) return song , path","title":"Returns"},{"location":"reference/spotdl/console/web/#download_url","text":"def download_url ( url : str , client_id : str ) -> Optional [ str ] Download songs using Song url.","title":"download_url"},{"location":"reference/spotdl/console/web/#arguments_7","text":"url: The url to download. client_id: The client's ID.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_7","text":"returns the file path if the song was downloaded. View Source @app . server . post ( \"/api/download/url\" ) async def download_url ( url : str , client_id : str ) -> Optional [ str ] : \"\"\" Download songs using Song url. ### Arguments - url: The url to download. - client_id: The client's ID. ### Returns - returns the file path if the song was downloaded. \"\"\" app . downloader . output = str ( ( get_spotdl_path () / f \"web/sessions/{client_id}\" ). absolute () ) # Initiate realtime updates if websocket from client is connected ws_instance = WSProgressHandler . get ( client_id ) if ws_instance is not None : app . downloader . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ app.settings[\"log_level\" ] ] , simple_tui = True , update_callback = ws_instance . update , ) try : # Fetch song metadata song = Song . from_url ( url ) # Download Song _ , path = await app . downloader . pool_download ( song ) if path is None : exc = DownloaderError ( f \"Failure downloading {song.name}\" ) logging . warning ( \"Error downloading! %s\" , exc ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: {exc}\" ) # Strip Filename filename = os . path . basename ( path ) return filename except Exception as exception : logging . warning ( \"Error downloading! %s\" , exception ) raise HTTPException ( status_code = 500 , detail = f \"Error downloading: {exception}\" ) from exception","title":"Returns"},{"location":"reference/spotdl/console/web/#get_settings","text":"def get_settings ( ) -> spotdl . console . web . SettingsModel Return the settings object.","title":"get_settings"},{"location":"reference/spotdl/console/web/#returns_8","text":"returns the settings object. View Source @app . server . get ( \"/api/settings\" ) def get_settings () -> SettingsModel : \"\"\" Return the settings object. ### Returns - returns the settings object. \"\"\" return SettingsModel ( ** app . settings )","title":"Returns"},{"location":"reference/spotdl/console/web/#query_search","text":"def query_search ( query : List [ str ] ) -> List [ spotdl . types . song . Song ] Parse a list of search queries.","title":"query_search"},{"location":"reference/spotdl/console/web/#arguments_8","text":"query: The query to parse.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_9","text":"returns a list of Song objects. View Source @app . server . post ( \"/api/songs/query\" ) def query_search ( query : List [ str ] ) -> List [ Song ] : \"\"\" Parse a list of search queries. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return parse_query ( query )","title":"Returns"},{"location":"reference/spotdl/console/web/#search_search","text":"def search_search ( query : str ) -> List [ spotdl . types . song . Song ] Parse search term and return list of Song objects.","title":"search_search"},{"location":"reference/spotdl/console/web/#arguments_9","text":"query: The query to parse.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_10","text":"returns a list of Song objects. View Source @app . server . get ( \"/api/songs/search\" ) def search_search ( query : str ) -> List [ Song ] : \"\"\" Parse search term and return list of Song objects. ### Arguments - query: The query to parse. ### Returns - returns a list of Song objects. \"\"\" return get_search_results ( query )","title":"Returns"},{"location":"reference/spotdl/console/web/#song_from_search","text":"def song_from_search ( query : str ) -> spotdl . types . song . Song Search for a song on spotify using search query.","title":"song_from_search"},{"location":"reference/spotdl/console/web/#arguments_10","text":"query: The search query.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_11","text":"returns the first result as a Song object. View Source @app . server . get ( \"/api/song/search\" ) def song_from_search ( query : str ) -> Song : \"\"\" Search for a song on spotify using search query. ### Arguments - query: The search query. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_search_term ( query )","title":"Returns"},{"location":"reference/spotdl/console/web/#song_from_url","text":"def song_from_url ( url : str ) -> spotdl . types . song . Song Search for a song on spotify using url.","title":"song_from_url"},{"location":"reference/spotdl/console/web/#arguments_11","text":"url: The url to search.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_12","text":"returns the first result as a Song object. View Source @app . server . get ( \"/api/song/url\" ) def song_from_url ( url : str ) -> Song : \"\"\" Search for a song on spotify using url. ### Arguments - url: The url to search. ### Returns - returns the first result as a Song object. \"\"\" return Song . from_url ( url )","title":"Returns"},{"location":"reference/spotdl/console/web/#web","text":"def web ( settings : Dict [ str , Any ] ) Run the web server.","title":"web"},{"location":"reference/spotdl/console/web/#arguments_12","text":"settings: Settings dictionary, based on the SettingsModel class. View Source def web ( set tings : Dict [ str , Any ] ) : \" \"\" Run the web server. ### Arguments - settings: Settings dictionary, based on the `SettingsModel` class. \"\" \" web_app_dir = str ( get_spotdl_path (). absolute ()) print ( \"Updating web app\" ) # Get web client from CDN (github for now) download_github_dir ( \"https://github.com/spotdl/web-ui/tree/master/dist\" , output_dir = web_app_dir ) # Serve web client SPA app . server . mount ( \"/\" , SPAStaticFiles ( directory = web_app_dir + \"/dist\" , html = True ), name = \"static\" ) loop = asyncio . new_event_loop () app . loop = loop app . set tings = set tings app . downloader = Downloader ( audio_providers = set tings [ \"audio_providers\" ] , lyrics_providers = set tings [ \"lyrics_providers\" ] , ffmpeg = set tings [ \"ffmpeg\" ] , bitrate = set tings [ \"bitrate\" ] , ffmpeg_args = set tings [ \"ffmpeg_args\" ] , output_format = set tings [ \"format\" ] , save_file = set tings [ \"save_file\" ] , threads = set tings [ \"threads\" ] , output = set tings [ \"output\" ] , overwrite = set tings [ \"overwrite\" ] , log_level = set tings [ \"log_level\" ] , simple_tui = True , loop = loop , ) config = Config ( app = app . server , port = 8800 , workers = 1 , loop = loop ) # type: ignore server = Server ( config ) webbrowser . open ( \"http://localhost:8800\" ) loop . run_until_complete ( server . serve ()) app . downloader . progress_handler . close ()","title":"Arguments"},{"location":"reference/spotdl/console/web/#websocket_endpoint","text":"def websocket_endpoint ( websocket : starlette . websockets . WebSocket , client_id : str ) Websocket endpoint.","title":"websocket_endpoint"},{"location":"reference/spotdl/console/web/#arguments_13","text":"websocket: The WebSocket instance. client_id: The client's ID. View Source @app . server . websocket ( \"/api/ws\" ) async def websocket_endpoint ( websocket : WebSocket , client_id : str ) : \"\"\" Websocket endpoint. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" await WSProgressHandler ( websocket , client_id ). connect () try : while True : data = await websocket . receive_text () logging . debug ( \"Client %s said: %s\" , client_id , data ) except WebSocketDisconnect : logging . info ( \"Disconnecting WebSocket: %s\" , client_id )","title":"Arguments"},{"location":"reference/spotdl/console/web/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/console/web/#app","text":"class App ( / , * args , ** kwargs ) View Source class App : \"\"\" App class that holds the application state. \"\"\" server : Any downloader : Downloader settings : Dict [ str , Any ] loop : asyncio . AbstractEventLoop","title":"App"},{"location":"reference/spotdl/console/web/#spastaticfiles","text":"class SPAStaticFiles ( * , directory : Union [ str , ForwardRef ( 'os.PathLike[str]' )] = None , packages : List [ str ] = None , html : bool = False , check_dir : bool = True ) View Source class SPAStaticFiles ( StaticFiles ): \"\"\" Override the static files to serve the index.html and other assets. \"\"\" async def get_response ( self , path: str , scope: Scope ) -> Response: \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super (). get_response ( path , scope ) if response . status_code == 404 : response = await super (). get_response ( \".\" , scope ) return response","title":"SPAStaticFiles"},{"location":"reference/spotdl/console/web/#ancestors-in-mro","text":"starlette.staticfiles.StaticFiles","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/console/web/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/console/web/#check_config","text":"def check_config ( self ) -> None Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses. View Source async def check_config ( self ) -> None : \"\"\" Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses. \"\"\" if self . directory is None : return try : stat_result = await anyio . to_thread . run_sync ( os . stat , self . directory ) except FileNotFoundError : raise RuntimeError ( f \"StaticFiles directory ' { self . directory } ' does not exist.\" ) if not ( stat . S_ISDIR ( stat_result . st_mode ) or stat . S_ISLNK ( stat_result . st_mode )) : raise RuntimeError ( f \"StaticFiles path ' { self . directory } ' is not a directory.\" )","title":"check_config"},{"location":"reference/spotdl/console/web/#file_response","text":"def file_response ( self , full_path : Union [ str , ForwardRef ( 'os.PathLike[str]' )], stat_result : os . stat_result , scope : MutableMapping [ str , Any ], status_code : int = 200 ) -> starlette . responses . Response View Source def file_response ( self , full_path : PathLike , stat_result : os . stat_result , scope : Scope , status_code : int = 200 , ) -> Response : method = scope [ \"method\" ] request_headers = Headers ( scope = scope ) response = FileResponse ( full_path , status_code = status_code , stat_result = stat_result , method = method ) if self . is_not_modified ( response . headers , request_headers ) : return NotModifiedResponse ( response . headers ) return response","title":"file_response"},{"location":"reference/spotdl/console/web/#get_directories","text":"def get_directories ( self , directory : Union [ str , ForwardRef ( 'os.PathLike[str]' )] = None , packages : List [ str ] = None ) -> List [ Union [ str , ForwardRef ( 'os.PathLike[str]' )]] Given directory and packages arguments, return a list of all the directories that should be used for serving static files from. View Source def get_directories ( self , directory : PathLike = None , packages : typing . List [ str ] = None ) -> typing . List [ PathLike ] : \" \"\" Given `directory` and `packages` arguments, return a list of all the directories that should be used for serving static files from. \"\" \" directories = [] if directory is not None : directories . append ( directory ) for package in packages or [] : spec = importlib . util . find_spec ( package ) assert spec is not None , f \"Package {package!r} could not be found.\" assert ( spec . origin is not None ), f \"Directory 'statics' in package {package!r} could not be found.\" package_directory = os . path . normpath ( os . path . join ( spec . origin , \"..\" , \"statics\" ) ) assert os . path . isdir ( package_directory ), f \"Directory 'statics' in package {package!r} could not be found.\" directories . append ( package_directory ) return directories","title":"get_directories"},{"location":"reference/spotdl/console/web/#get_path","text":"def get_path ( self , scope : MutableMapping [ str , Any ] ) -> str Given the ASGI scope, return the path string to serve up, with OS specific path seperators, and any '..', '.' components removed. View Source def get_path ( self , scope : Scope ) -> str : \" \"\" Given the ASGI scope, return the `path` string to serve up, with OS specific path seperators, and any '..', '.' components removed. \"\" \" return os . path . normpath ( os . path . join ( * scope [ \"path\" ] . split ( \"/\" )))","title":"get_path"},{"location":"reference/spotdl/console/web/#get_response","text":"def get_response ( self , path : str , scope : MutableMapping [ str , Any ] ) -> starlette . responses . Response Serve static files from the SPA.","title":"get_response"},{"location":"reference/spotdl/console/web/#arguments_14","text":"path: The path to the file. scope: The scope of the request.","title":"Arguments"},{"location":"reference/spotdl/console/web/#returns_13","text":"returns the response. View Source async def get_response ( self , path : str , scope : Scope ) -> Response : \"\"\" Serve static files from the SPA. ### Arguments - path: The path to the file. - scope: The scope of the request. ### Returns - returns the response. \"\"\" response = await super (). get_response ( path , scope ) if response . status_code == 404 : response = await super (). get_response ( \".\" , scope ) return response","title":"Returns"},{"location":"reference/spotdl/console/web/#is_not_modified","text":"def is_not_modified ( self , response_headers : starlette . datastructures . Headers , request_headers : starlette . datastructures . Headers ) -> bool Given the request and response headers, return True if an HTTP \"Not Modified\" response could be returned instead. View Source def is_not_modified ( self , response_headers : Headers , request_headers : Headers ) -> bool : \" \"\" Given the request and response headers, return `True` if an HTTP \" Not Modified \" response could be returned instead. \"\" \" try : if_none_match = request_headers [ \"if-none-match\" ] etag = response_headers [ \"etag\" ] if if_none_match == etag : return True except KeyError : pass try : if_modified_since = parsedate ( request_headers [ \"if-modified-since\" ] ) last_modified = parsedate ( response_headers [ \"last-modified\" ] ) if ( if_modified_since is not None and last_modified is not None and if_modified_since >= last_modified ) : return True except KeyError : pass return False","title":"is_not_modified"},{"location":"reference/spotdl/console/web/#lookup_path","text":"def lookup_path ( self , path : str ) -> Tuple [ str , Optional [ os . stat_result ]] View Source def lookup_path ( self , path : str ) -> typing . Tuple [ str , typing . Optional [ os . stat_result ]] : for directory in self . all_directories : full_path = os . path . realpath ( os . path . join ( directory , path )) directory = os . path . realpath ( directory ) if os . path . commonprefix ([ full_path , directory ]) != directory : # Don 't allow misbehaving clients to break out of the static files # directory. continue try: return full_path, os.stat(full_path) except (FileNotFoundError, NotADirectoryError): continue return \"\", None","title":"lookup_path"},{"location":"reference/spotdl/console/web/#settingsmodel","text":"class SettingsModel ( __pydantic_self__ , ** data : Any ) View Source class SettingsModel ( BaseModel ) : \"\"\" A settings object used for types and validation. \"\"\" log_level : Optional [ str ] cache_path : Optional [ str ] audio_providers : Optional [ List[str ] ] lyrics_providers : Optional [ List[str ] ] ffmpeg : Optional [ str ] variable_bitrate : Optional [ int ] constant_bitrate : Optional [ int ] ffmpeg_args : Optional [ List[str ] ] format : Optional [ str ] save_file : Optional [ str ] m3u : Optional [ str ] output : Optional [ str ] overwrite : Optional [ str ] client_id : Optional [ str ] client_secret : Optional [ str ] user_auth : Optional [ bool ] threads : Optional [ int ]","title":"SettingsModel"},{"location":"reference/spotdl/console/web/#ancestors-in-mro_1","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/console/web/#class-variables","text":"Config","title":"Class variables"},{"location":"reference/spotdl/console/web/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/console/web/#construct","text":"def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"reference/spotdl/console/web/#from_orm","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/spotdl/console/web/#parse_file","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/spotdl/console/web/#parse_obj","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/spotdl/console/web/#parse_raw","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/spotdl/console/web/#schema","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/spotdl/console/web/#schema_json","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/spotdl/console/web/#update_forward_refs","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/spotdl/console/web/#validate","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/spotdl/console/web/#methods_1","text":"","title":"Methods"},{"location":"reference/spotdl/console/web/#copy","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/spotdl/console/web/#dict","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/spotdl/console/web/#json","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/spotdl/console/web/#songmodel","text":"class SongModel ( __pydantic_self__ , ** data : Any ) View Source class SongModel ( BaseModel ) : \"\"\" A song object used for types and validation. We can't use the Song class directly because FastAPI doesn't support dataclasses. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int copyright : str duration : int year : int date : str track_number : int tracks_count : int isrc : str song_id : str cover_url : str explicit : bool publisher : str url : str download_url : Optional [ str ] = None","title":"SongModel"},{"location":"reference/spotdl/console/web/#ancestors-in-mro_2","text":"pydantic.main.BaseModel pydantic.utils.Representation","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/console/web/#class-variables_1","text":"Config","title":"Class variables"},{"location":"reference/spotdl/console/web/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/spotdl/console/web/#construct_1","text":"def construct ( _fields_set : Optional [ ForwardRef ( 'SetStr' )] = None , ** values : Any ) -> 'Model' Creates a new model setting dict and fields_set from trusted or pre-validated data. Default values are respected, but no other validation is performed. Behaves as if Config.extra = 'allow' was set since it adds all passed values","title":"construct"},{"location":"reference/spotdl/console/web/#from_orm_1","text":"def from_orm ( obj : Any ) -> 'Model'","title":"from_orm"},{"location":"reference/spotdl/console/web/#parse_file_1","text":"def parse_file ( path : Union [ str , pathlib . Path ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_file"},{"location":"reference/spotdl/console/web/#parse_obj_1","text":"def parse_obj ( obj : Any ) -> 'Model'","title":"parse_obj"},{"location":"reference/spotdl/console/web/#parse_raw_1","text":"def parse_raw ( b : Union [ str , bytes ], * , content_type : 'unicode' = None , encoding : 'unicode' = 'utf8' , proto : pydantic . parse . Protocol = None , allow_pickle : bool = False ) -> 'Model'","title":"parse_raw"},{"location":"reference/spotdl/console/web/#schema_1","text":"def schema ( by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' ) -> 'DictStrAny'","title":"schema"},{"location":"reference/spotdl/console/web/#schema_json_1","text":"def schema_json ( * , by_alias : bool = True , ref_template : 'unicode' = '#/definitions/ {model} ' , ** dumps_kwargs : Any ) -> 'unicode'","title":"schema_json"},{"location":"reference/spotdl/console/web/#update_forward_refs_1","text":"def update_forward_refs ( ** localns : Any ) -> None Try to update ForwardRefs on fields based on this Model, globalns and localns.","title":"update_forward_refs"},{"location":"reference/spotdl/console/web/#validate_1","text":"def validate ( value : Any ) -> 'Model'","title":"validate"},{"location":"reference/spotdl/console/web/#methods_2","text":"","title":"Methods"},{"location":"reference/spotdl/console/web/#copy_1","text":"def copy ( self : 'Model' , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , update : 'DictStrAny' = None , deep : bool = False ) -> 'Model' Duplicate a model, optionally choose which fields to include, exclude and change. Parameters: Name Type Description Default include None fields to include in new model None exclude None fields to exclude from new model, as with values this takes precedence over include None update None values to change/add in the new model. Note: the data is not validated before creating the new model: you should trust this data None deep None set to True to make a deep copy of the model None Returns: Type Description None new model instance","title":"copy"},{"location":"reference/spotdl/console/web/#dict_1","text":"def dict ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False ) -> 'DictStrAny' Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.","title":"dict"},{"location":"reference/spotdl/console/web/#json_1","text":"def json ( self , * , include : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , exclude : Union [ ForwardRef ( 'AbstractSetIntStr' ), ForwardRef ( 'MappingIntStrAny' )] = None , by_alias : bool = False , skip_defaults : bool = None , exclude_unset : bool = False , exclude_defaults : bool = False , exclude_none : bool = False , encoder : Optional [ Callable [[ Any ], Any ]] = None , models_as_dict : bool = True , ** dumps_kwargs : Any ) -> 'unicode' Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() .","title":"json"},{"location":"reference/spotdl/console/web/#wsprogresshandler","text":"class WSProgressHandler ( websocket : starlette . websockets . WebSocket , client_id : str ) View Source class WSProgressHandler : \"\"\" Handles all the WebSocket connections. \"\"\" instances : List [ \"WSProgressHandler\" ] = [] def __init__ ( self , websocket : WebSocket , client_id : str ) : \"\"\" Initialize the WebSocket handler. ### Arguments - websocket: The WebSocket instance. - client_id: The client's ID. \"\"\" self . client_id = client_id self . websocket = websocket async def connect ( self ) : \"\"\" Called when a new client connects to the websocket. \"\"\" connection = { \"client_id\" : self . client_id , \"websocket\" : self . websocket } logging . info ( \"Connecting WebSocket: %s\" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self ) @classmethod def get ( cls , client_id : str ) : \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None async def send_update ( self , message : str ) : \"\"\" Send an update to the client. ### Arguments - message: The message to send. \"\"\" logging . debug ( \"Sending %s: %s\" , self . client_id , message ) await self . websocket . send_text ( message ) def update ( self , progress_handler_instance : SongTracker , message : str ) : \"\"\"Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance: The ProgressHandler instance. - message: The message to send. \"\"\" update_message = { \"song\" : progress_handler_instance . song . json , \"progress\" : progress_handler_instance . progress , \"message\" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message )))","title":"WSProgressHandler"},{"location":"reference/spotdl/console/web/#class-variables_2","text":"instances","title":"Class variables"},{"location":"reference/spotdl/console/web/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/spotdl/console/web/#get","text":"def get ( client_id : str ) Get a WSProgressHandler instance by client_id.","title":"get"},{"location":"reference/spotdl/console/web/#arguments_15","text":"client_id: The client's ID. View Source @classmethod def get ( cls , client_id : str ) : \"\"\" Get a WSProgressHandler instance by client_id. ### Arguments - client_id: The client's ID. \"\"\" try : instance = next ( inst for inst in cls . instances if inst . client_id == client_id ) return instance except StopIteration : logging . warning ( \"Error while accessing websocket instance. Websocket not created\" ) return None","title":"Arguments"},{"location":"reference/spotdl/console/web/#methods_3","text":"","title":"Methods"},{"location":"reference/spotdl/console/web/#connect","text":"def connect ( self ) Called when a new client connects to the websocket. View Source async def connect ( self ) : \"\"\" Called when a new client connects to the websocket . \"\"\" connection = { \" client_id \" : self . client_id , \" websocket \" : self . websocket } logging . info ( \" Connecting WebSocket: %s \" , connection ) await self . websocket . accept () WSProgressHandler . instances . append ( self )","title":"connect"},{"location":"reference/spotdl/console/web/#send_update","text":"def send_update ( self , message : str ) Send an update to the client.","title":"send_update"},{"location":"reference/spotdl/console/web/#arguments_16","text":"message: The message to send. View Source async def send_update ( self , message : str ) : \"\"\" Send an update to the client . ### Arguments - message : The message to send . \"\"\" logging . debug ( \" Sending %s: %s \" , self . client_id , message ) await self . websocket . send_text ( message )","title":"Arguments"},{"location":"reference/spotdl/console/web/#update","text":"def update ( self , progress_handler_instance : spotdl . download . progress_handler . SongTracker , message : str ) Callback function from ProgressHandler's SongTracker, called on every update","title":"update"},{"location":"reference/spotdl/console/web/#arguments_17","text":"progress_handler_instance: The ProgressHandler instance. message: The message to send. View Source def update ( self , progress_handler_instance : SongTracker , message : str ) : \"\"\" Callback function from ProgressHandler's SongTracker, called on every update ### Arguments - progress_handler_instance : The ProgressHandler instance . - message : The message to send . \"\"\" update_message = { \" song \" : progress_handler_instance . song . json , \" progress \" : progress_handler_instance . progress , \" message \" : message , } asyncio . run ( self . send_update ( json . dumps ( update_message )))","title":"Arguments"},{"location":"reference/spotdl/download/","text":"Module spotdl.download Download module that holds the downloader and progress handler classes. None View Source \"\"\" Download module that holds the downloader and progress handler classes. \"\"\" from spotdl.download.downloader import Downloader Sub-modules spotdl.download.downloader spotdl.download.progress_handler","title":"Index"},{"location":"reference/spotdl/download/#module-spotdldownload","text":"Download module that holds the downloader and progress handler classes. None View Source \"\"\" Download module that holds the downloader and progress handler classes. \"\"\" from spotdl.download.downloader import Downloader","title":"Module spotdl.download"},{"location":"reference/spotdl/download/#sub-modules","text":"spotdl.download.downloader spotdl.download.progress_handler","title":"Sub-modules"},{"location":"reference/spotdl/download/downloader/","text":"Module spotdl.download.downloader Downloader module, this is where all the downloading pre/post processing happens etc. None View Source \"\"\" Downloader module, this is where all the downloading pre/post processing happens etc. \"\"\" import json import datetime import asyncio import shutil import sys import concurrent.futures import traceback from pathlib import Path from typing import Dict , List , Optional , Tuple , Type from yt_dlp.postprocessor.sponsorblock import SponsorBlockPP from yt_dlp.postprocessor.modify_chapters import ModifyChaptersPP from spotdl.types import Song from spotdl.utils.ffmpeg import FFmpegError , convert_sync , get_ffmpeg_path from spotdl.utils.metadata import embed_metadata , MetadataError from spotdl.utils.formatter import create_file_name , restrict_filename from spotdl.providers.audio.base import AudioProvider from spotdl.providers.lyrics import Genius , MusixMatch , AzLyrics from spotdl.providers.lyrics.base import LyricsProvider from spotdl.providers.audio import YouTube , YouTubeMusic from spotdl.download.progress_handler import NAME_TO_LEVEL , ProgressHandler from spotdl.utils.config import get_errors_path AUDIO_PROVIDERS : Dict [ str , Type [ AudioProvider ]] = { \"youtube\" : YouTube , \"youtube-music\" : YouTubeMusic , } LYRICS_PROVIDERS : Dict [ str , Type [ LyricsProvider ]] = { \"genius\" : Genius , \"musixmatch\" : MusixMatch , \"azlyrics\" : AzLyrics , } SPONSOR_BLOCK_CATEGORIES = { \"sponsor\" : \"Sponsor\" , \"intro\" : \"Intermission/Intro Animation\" , \"outro\" : \"Endcards/Credits\" , \"selfpromo\" : \"Unpaid/Self Promotion\" , \"preview\" : \"Preview/Recap\" , \"filler\" : \"Filler Tangent\" , \"interaction\" : \"Interaction Reminder\" , \"music_offtopic\" : \"Non-Music Section\" , } class DownloaderError ( Exception ): \"\"\" Base class for all exceptions related to downloaders. \"\"\" class Downloader : \"\"\" Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc. \"\"\" def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artists} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: { provider } \" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: { provider } \" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . audio_providers : List [ AudioProvider ] = [] for audio_provider_class in audio_providers_classes : self . audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" ) def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ] def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \" { audio_provider . name } failed to find { song . display_name } \" ) raise LookupError ( f \"No results found for song: { song . display_name } \" ) def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for { song . display_name } on { lyrics_provider . name } \" ) return lyrics self . progress_handler . debug ( f \" { lyrics_provider . name } failed to find lyrics \" f \"for { song . display_name } \" ) raise LookupError ( f \"No lyrics found for song: { song . display_name } \" ) def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping { song . display_name } \" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting { song . display_name } \" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt-dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for { song . display_name } , url: { url } \" ) raise LookupError ( f \"yt-dlp failed to get metadata for: { song . name } - { song . artist } \" ) self . progress_handler . debug ( f \"Downloading { song . display_name } using { url } , \" f \"audio provider: { audio_provider . name } \" ) success , result = convert_sync ( ( download_info [ \"url\" ], download_info [ \"ext\" ]), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_ { datetime . datetime . now () . strftime ( '%Y-%m- %d -%H-%M-%S' ) } .txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### { key } : \\n { str ( value ) . strip () } \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert { song . display_name } , \" f \"you can find error here: { str ( file_name . absolute ()) } \" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_download_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing { len ( chapters ) } sponsor segments for { song . display_name } \" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for { song . display_name } , \" \"lyrics providers: \" f \" { ', ' . join ([ lprovider . name for lprovider in self . lyrics_providers ]) } \" ) lyrics = \"\" try : embed_metadata ( output_file , song , self . output_format , lyrics ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \" { song . display_name } \": { song . download_url } ' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \" { song . url } - { exception . __class__ . __name__ } : { exception } \" ) return song , None Variables AUDIO_PROVIDERS LYRICS_PROVIDERS NAME_TO_LEVEL SPONSOR_BLOCK_CATEGORIES Classes Downloader class Downloader ( audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = 'ffmpeg' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = 'mp3' , threads : int = 4 , output : str = '.' , save_file : Optional [ str ] = None , overwrite : str = 'skip' , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = ' {artists} - {title} ' , log_level : str = 'INFO' , simple_tui : bool = False , loop : Optional [ asyncio . events . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False ) View Source class Downloader : \"\"\" Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc. \"\"\" def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \"{artists} - {title}\" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: {provider}\" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: {provider}\" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . audio_providers : List [ AudioProvider ] = [] for audio_provider_class in audio_providers_classes : self . audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" ) def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ] def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \"{audio_provider.name} failed to find {song.display_name}\" ) raise LookupError ( f \"No results found for song: {song.display_name}\" ) def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for {song.display_name} on {lyrics_provider.name}\" ) return lyrics self . progress_handler . debug ( f \"{lyrics_provider.name} failed to find lyrics \" f \"for {song.display_name}\" ) raise LookupError ( f \"No lyrics found for song: {song.display_name}\" ) def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping {song.display_name}\" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting {song.display_name}\" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt-dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for {song.display_name}, url: {url}\" ) raise LookupError ( f \"yt-dlp failed to get metadata for: {song.name} - {song.artist}\" ) self . progress_handler . debug ( f \"Downloading {song.display_name} using {url}, \" f \"audio provider: {audio_provider.name}\" ) success , result = convert_sync ( ( download_info [ \"url\" ], download_info [ \"ext\" ]), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m- %d -%H-%M-%S')}.txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### {key}: \\n {str(value).strip()} \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert {song.display_name}, \" f \"you can find error here: {str(file_name.absolute())}\" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_download_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing {len(chapters)} sponsor segments for {song.display_name}\" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for {song.display_name}, \" \"lyrics providers: \" f \"{', '.join([lprovider.name for lprovider in self.lyrics_providers])}\" ) lyrics = \"\" try : embed_metadata ( output_file , song , self . output_format , lyrics ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \"{song.display_name}\": {song.download_url}' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \"{song.url} - {exception.__class__.__name__}: {exception}\" ) return song , None Methods download_multiple_songs def download_multiple_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download multiple songs to the temp directory. Arguments songs: The songs to download. Returns list of tuples with the song and the path to the downloaded file if successful. View Source def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self.pool_download(song) for song in songs ] # call all task asynchronously , and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( [ song.json for song, _ in results ] , save_file , indent = 4 ) return results download_song def download_song ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Download a single song. Arguments song: The song to download. Returns tuple with the song and the path to the downloaded file if successful. View Source def download_song ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ( [ song ] ) return results [ 0 ] pool_download def pool_download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Run asynchronous task in a pool to make sure that all processes. Arguments song: The song to download. Returns tuple with the song and the path to the downloaded file if successful. Notes This method calls self.search_and_download in a new thread. View Source async def pool_download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it 's free # only certain amount of tasks can acquire the semaphore at the same time async with self.semaphore: # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn' t # hurt performance . return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) search def search ( self , song : spotdl . types . song . Song ) -> Tuple [ str , spotdl . providers . audio . base . AudioProvider ] Search for a song using all available providers. Arguments song: The song to search for. Returns tuple with download url and audio provider if successful. View Source def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \"{audio_provider.name} failed to find {song.display_name}\" ) raise LookupError ( f \"No results found for song: {song.display_name}\" ) search_and_download def search_and_download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Search for the song and download it. Arguments song: The song to download. Returns tuple with the song and the path to the downloaded file if successful. Notes This function is synchronous. View Source def search_and_download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it 's None extract the current metadata # And reinitialize the song object if song.name is None and song.url: data = song.json new_data = Song.from_url(data[\"url\"]).json data.update((k, v) for k, v in new_data.items() if v is not None) if data.get(\"song_list\"): # Reinitialize the correct song list object data[\"song_list\"] = song.song_list.__class__(**data[\"song_list\"]) # Reinitialize the song object song = Song(**data) # Create the output file path output_file = create_file_name(song, self.output, self.output_format) # Restrict the filename if needed if self.restrict is True: output_file = restrict_filename(output_file) # If the file already exists and we don' t want to overwrite it , # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping {song.display_name}\" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don 't skip if the file exists and overwrite is set to force if output_file.exists() and self.overwrite == \"force\": self.progress_handler.debug(f\"Overwriting {song.display_name}\") # Initalize the progress tracker display_progress_tracker = self.progress_handler.get_new_tracker(song) # Create the output directory if it doesn' t exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt - dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for {song.display_name}, url: {url}\" ) raise LookupError ( f \"yt-dlp failed to get metadata for: {song.name} - {song.artist}\" ) self . progress_handler . debug ( f \"Downloading {song.display_name} using {url}, \" f \"audio provider: {audio_provider.name}\" ) success , result = convert_sync ( ( download_info [ \"url\" ] , download_info [ \"ext\" ] ), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.txt\" ) error_message = \"\" for key , value in result . items () : error_message += f \"### {key}:\\n{str(value).strip()}\\n\\n\" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert {song.display_name}, \" f \"you can find error here: {str(file_name.absolute())}\" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song 's download url if song.download_url is None: song.download_url = download_info[\"webpage_url\"] display_progress_tracker.notify_download_complete() if self.sponsor_block: post_processor = SponsorBlockPP( audio_provider.audio_handler, SPONSOR_BLOCK_CATEGORIES ) _, download_info = post_processor.run(download_info) chapters = download_info[\"sponsorblock_chapters\"] if len(chapters) > 0: self.progress_handler.log( f\"Removing {len(chapters)} sponsor segments for {song.display_name}\" ) modify_chapters = ModifyChaptersPP( audio_provider.audio_handler, remove_sponsor_segments=SPONSOR_BLOCK_CATEGORIES, ) files_to_delete, download_info = modify_chapters.run(download_info) for file_to_delete in files_to_delete: Path(file_to_delete).unlink() try: lyrics = self.search_lyrics(song) except LookupError: self.progress_handler.debug( f\"No lyrics found for {song.display_name}, \" \"lyrics providers: \" f\"{' , '.join([lprovider.name for lprovider in self.lyrics_providers])}\" ) lyrics = \"\" try: embed_metadata(output_file, song, self.output_format, lyrics) except Exception as exception: raise MetadataError( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker.notify_complete() self.progress_handler.log( f' Downloaded \"{song.display_name}\" : { song . download_url }' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \"{song.url} - {exception.__class__.__name__}: {exception}\" ) return song , None search_lyrics def search_lyrics ( self , song : spotdl . types . song . Song ) -> str Search for lyrics using all available providers. Arguments song: The song to search for. Returns lyrics if successful. View Source def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for {song.display_name} on {lyrics_provider.name}\" ) return lyrics self . progress_handler . debug ( f \"{lyrics_provider.name} failed to find lyrics \" f \"for {song.display_name}\" ) raise LookupError ( f \"No lyrics found for song: {song.display_name}\" ) DownloaderError class DownloaderError ( / , * args , ** kwargs ) View Source class DownloaderError ( Exception ): \"\"\" Base class for all exceptions related to downloaders. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Downloader"},{"location":"reference/spotdl/download/downloader/#module-spotdldownloaddownloader","text":"Downloader module, this is where all the downloading pre/post processing happens etc. None View Source \"\"\" Downloader module, this is where all the downloading pre/post processing happens etc. \"\"\" import json import datetime import asyncio import shutil import sys import concurrent.futures import traceback from pathlib import Path from typing import Dict , List , Optional , Tuple , Type from yt_dlp.postprocessor.sponsorblock import SponsorBlockPP from yt_dlp.postprocessor.modify_chapters import ModifyChaptersPP from spotdl.types import Song from spotdl.utils.ffmpeg import FFmpegError , convert_sync , get_ffmpeg_path from spotdl.utils.metadata import embed_metadata , MetadataError from spotdl.utils.formatter import create_file_name , restrict_filename from spotdl.providers.audio.base import AudioProvider from spotdl.providers.lyrics import Genius , MusixMatch , AzLyrics from spotdl.providers.lyrics.base import LyricsProvider from spotdl.providers.audio import YouTube , YouTubeMusic from spotdl.download.progress_handler import NAME_TO_LEVEL , ProgressHandler from spotdl.utils.config import get_errors_path AUDIO_PROVIDERS : Dict [ str , Type [ AudioProvider ]] = { \"youtube\" : YouTube , \"youtube-music\" : YouTubeMusic , } LYRICS_PROVIDERS : Dict [ str , Type [ LyricsProvider ]] = { \"genius\" : Genius , \"musixmatch\" : MusixMatch , \"azlyrics\" : AzLyrics , } SPONSOR_BLOCK_CATEGORIES = { \"sponsor\" : \"Sponsor\" , \"intro\" : \"Intermission/Intro Animation\" , \"outro\" : \"Endcards/Credits\" , \"selfpromo\" : \"Unpaid/Self Promotion\" , \"preview\" : \"Preview/Recap\" , \"filler\" : \"Filler Tangent\" , \"interaction\" : \"Interaction Reminder\" , \"music_offtopic\" : \"Non-Music Section\" , } class DownloaderError ( Exception ): \"\"\" Base class for all exceptions related to downloaders. \"\"\" class Downloader : \"\"\" Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc. \"\"\" def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \" {artists} - {title} \" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: { provider } \" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: { provider } \" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . audio_providers : List [ AudioProvider ] = [] for audio_provider_class in audio_providers_classes : self . audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" ) def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ] def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \" { audio_provider . name } failed to find { song . display_name } \" ) raise LookupError ( f \"No results found for song: { song . display_name } \" ) def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for { song . display_name } on { lyrics_provider . name } \" ) return lyrics self . progress_handler . debug ( f \" { lyrics_provider . name } failed to find lyrics \" f \"for { song . display_name } \" ) raise LookupError ( f \"No lyrics found for song: { song . display_name } \" ) def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping { song . display_name } \" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting { song . display_name } \" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt-dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for { song . display_name } , url: { url } \" ) raise LookupError ( f \"yt-dlp failed to get metadata for: { song . name } - { song . artist } \" ) self . progress_handler . debug ( f \"Downloading { song . display_name } using { url } , \" f \"audio provider: { audio_provider . name } \" ) success , result = convert_sync ( ( download_info [ \"url\" ], download_info [ \"ext\" ]), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_ { datetime . datetime . now () . strftime ( '%Y-%m- %d -%H-%M-%S' ) } .txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### { key } : \\n { str ( value ) . strip () } \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert { song . display_name } , \" f \"you can find error here: { str ( file_name . absolute ()) } \" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_download_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing { len ( chapters ) } sponsor segments for { song . display_name } \" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for { song . display_name } , \" \"lyrics providers: \" f \" { ', ' . join ([ lprovider . name for lprovider in self . lyrics_providers ]) } \" ) lyrics = \"\" try : embed_metadata ( output_file , song , self . output_format , lyrics ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \" { song . display_name } \": { song . download_url } ' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \" { song . url } - { exception . __class__ . __name__ } : { exception } \" ) return song , None","title":"Module spotdl.download.downloader"},{"location":"reference/spotdl/download/downloader/#variables","text":"AUDIO_PROVIDERS LYRICS_PROVIDERS NAME_TO_LEVEL SPONSOR_BLOCK_CATEGORIES","title":"Variables"},{"location":"reference/spotdl/download/downloader/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/download/downloader/#downloader","text":"class Downloader ( audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = 'ffmpeg' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = 'mp3' , threads : int = 4 , output : str = '.' , save_file : Optional [ str ] = None , overwrite : str = 'skip' , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = ' {artists} - {title} ' , log_level : str = 'INFO' , simple_tui : bool = False , loop : Optional [ asyncio . events . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False ) View Source class Downloader : \"\"\" Downloader class, this is where all the downloading pre/post processing happens etc. It handles the downloading/moving songs, multthreading, metadata embedding etc. \"\"\" def __init__ ( self , audio_providers : Optional [ List [ str ]] = None , lyrics_providers : Optional [ List [ str ]] = None , ffmpeg : str = \"ffmpeg\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , output_format : str = \"mp3\" , threads : int = 4 , output : str = \".\" , save_file : Optional [ str ] = None , overwrite : str = \"skip\" , cookie_file : Optional [ str ] = None , filter_results : bool = True , search_query : str = \"{artists} - {title}\" , log_level : str = \"INFO\" , simple_tui : bool = False , loop : Optional [ asyncio . AbstractEventLoop ] = None , restrict : bool = False , print_errors : bool = False , sponsor_block : bool = False , ): \"\"\" Initialize the Downloader class. ### Arguments - audio_provider: Audio providers to use. - lyrics_provider: The lyrics providers to use. - ffmpeg: The ffmpeg executable to use. - variable_bitrate: The variable bitrate to use. - constant_bitrate: The constant bitrate to use. - ffmpeg_args: The ffmpeg arguments to use. - output_format: The output format to use. - threads: The number of threads to use. - output: The output directory to use. - save_file: The save file to use when saving/loading song metadata. - overwrite: The overwrite mode to use (force/skip). - cookie_file: The cookie file to use for yt-dlp. - filter_results: Whether to filter results. - search_query: The search query to use. - log_level: The log level to use. - simple_tui: Whether to use simple tui. - loop: The event loop to use. - restrict: Whether to restrict the filename to ASCII characters. - print_errors: Whether to print errors on exit. - sponsor_block: Whether to remove sponsor segments using sponsor block postprocessor. ### Notes - `search-query` uses the same format as `output`. - if `audio_provider` or `lyrics_provider` is a list, then if no match is found, the next provider in the list will be used. \"\"\" if audio_providers is None : audio_providers = [ \"youtube-music\" ] if lyrics_providers is None : lyrics_providers = [ \"musixmatch\" ] audio_providers_classes : List [ Type [ AudioProvider ]] = [] lyrics_providers_classes : List [ Type [ LyricsProvider ]] = [] for provider in audio_providers : new_audio_provider = AUDIO_PROVIDERS . get ( provider ) if new_audio_provider is None : raise DownloaderError ( f \"Invalid audio provider: {provider}\" ) audio_providers_classes . append ( new_audio_provider ) if len ( audio_providers_classes ) == 0 : raise DownloaderError ( \"No audio providers specified. Please specify at least one.\" ) for provider in lyrics_providers : new_lyrics_provider = LYRICS_PROVIDERS . get ( provider ) if new_lyrics_provider is None : raise DownloaderError ( f \"Invalid lyrics provider: {provider}\" ) lyrics_providers_classes . append ( new_lyrics_provider ) if loop is None : if sys . platform == \"win32\" : # ProactorEventLoop is required on Windows to run subprocess asynchronously # it is default since Python 3.8 but has to be changed for previous versions self . loop = asyncio . ProactorEventLoop () else : self . loop = asyncio . new_event_loop () asyncio . set_event_loop ( self . loop ) else : self . loop = loop # semaphore is required to limit concurrent asyncio executions self . semaphore = asyncio . Semaphore ( threads ) # thread pool executor is used to run blocking (CPU-bound) code from a thread self . thread_executor = concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) # If ffmpeg is the default value and it's not installed # try to use the spotdl's ffmpeg if ffmpeg == \"ffmpeg\" and shutil . which ( \"ffmpeg\" ) is None : ffmpeg_exec = get_ffmpeg_path () if ffmpeg_exec is None : raise DownloaderError ( \"ffmpeg is not installed\" ) ffmpeg = str ( ffmpeg_exec . absolute ()) self . output = output self . output_format = output_format self . save_file = save_file self . threads = threads self . cookie_file = cookie_file self . overwrite = overwrite self . search_query = search_query self . filter_results = filter_results self . ffmpeg = ffmpeg self . bitrate = bitrate self . ffmpeg_args = ffmpeg_args self . restrict = restrict self . print_errors = print_errors self . errors : List [ str ] = [] self . sponsor_block = sponsor_block self . progress_handler = ProgressHandler ( NAME_TO_LEVEL [ log_level ], simple_tui ) self . audio_providers : List [ AudioProvider ] = [] for audio_provider_class in audio_providers_classes : self . audio_providers . append ( audio_provider_class ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) ) self . lyrics_providers : List [ LyricsProvider ] = [] for lyrics_provider_class in lyrics_providers_classes : self . lyrics_providers . append ( lyrics_provider_class ()) self . progress_handler . debug ( \"Downloader initialized\" ) def download_song ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ([ song ]) return results [ 0 ] def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple [ Song , Optional [ Path ]]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self . pool_download ( song ) for song in songs ] # call all task asynchronously, and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ([ song . json for song , _ in results ], save_file , indent = 4 ) return results async def pool_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it's free # only certain amount of tasks can acquire the semaphore at the same time async with self . semaphore : # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn't # hurt performance. return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song ) def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \"{audio_provider.name} failed to find {song.display_name}\" ) raise LookupError ( f \"No results found for song: {song.display_name}\" ) def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for {song.display_name} on {lyrics_provider.name}\" ) return lyrics self . progress_handler . debug ( f \"{lyrics_provider.name} failed to find lyrics \" f \"for {song.display_name}\" ) raise LookupError ( f \"No lyrics found for song: {song.display_name}\" ) def search_and_download ( self , song : Song ) -> Tuple [ Song , Optional [ Path ]]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it's None extract the current metadata # And reinitialize the song object if song . name is None and song . url : data = song . json new_data = Song . from_url ( data [ \"url\" ]) . json data . update (( k , v ) for k , v in new_data . items () if v is not None ) if data . get ( \"song_list\" ): # Reinitialize the correct song list object data [ \"song_list\" ] = song . song_list . __class__ ( ** data [ \"song_list\" ]) # Reinitialize the song object song = Song ( ** data ) # Create the output file path output_file = create_file_name ( song , self . output , self . output_format ) # Restrict the filename if needed if self . restrict is True : output_file = restrict_filename ( output_file ) # If the file already exists and we don't want to overwrite it, # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping {song.display_name}\" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don't skip if the file exists and overwrite is set to force if output_file . exists () and self . overwrite == \"force\" : self . progress_handler . debug ( f \"Overwriting {song.display_name}\" ) # Initalize the progress tracker display_progress_tracker = self . progress_handler . get_new_tracker ( song ) # Create the output directory if it doesn't exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt-dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for {song.display_name}, url: {url}\" ) raise LookupError ( f \"yt-dlp failed to get metadata for: {song.name} - {song.artist}\" ) self . progress_handler . debug ( f \"Downloading {song.display_name} using {url}, \" f \"audio provider: {audio_provider.name}\" ) success , result = convert_sync ( ( download_info [ \"url\" ], download_info [ \"ext\" ]), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m- %d -%H-%M-%S')}.txt\" ) error_message = \"\" for key , value in result . items (): error_message += f \"### {key}: \\n {str(value).strip()} \\n\\n \" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert {song.display_name}, \" f \"you can find error here: {str(file_name.absolute())}\" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song's download url if song . download_url is None : song . download_url = download_info [ \"webpage_url\" ] display_progress_tracker . notify_download_complete () if self . sponsor_block : post_processor = SponsorBlockPP ( audio_provider . audio_handler , SPONSOR_BLOCK_CATEGORIES ) _ , download_info = post_processor . run ( download_info ) chapters = download_info [ \"sponsorblock_chapters\" ] if len ( chapters ) > 0 : self . progress_handler . log ( f \"Removing {len(chapters)} sponsor segments for {song.display_name}\" ) modify_chapters = ModifyChaptersPP ( audio_provider . audio_handler , remove_sponsor_segments = SPONSOR_BLOCK_CATEGORIES , ) files_to_delete , download_info = modify_chapters . run ( download_info ) for file_to_delete in files_to_delete : Path ( file_to_delete ) . unlink () try : lyrics = self . search_lyrics ( song ) except LookupError : self . progress_handler . debug ( f \"No lyrics found for {song.display_name}, \" \"lyrics providers: \" f \"{', '.join([lprovider.name for lprovider in self.lyrics_providers])}\" ) lyrics = \"\" try : embed_metadata ( output_file , song , self . output_format , lyrics ) except Exception as exception : raise MetadataError ( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker . notify_complete () self . progress_handler . log ( f 'Downloaded \"{song.display_name}\": {song.download_url}' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \"{song.url} - {exception.__class__.__name__}: {exception}\" ) return song , None","title":"Downloader"},{"location":"reference/spotdl/download/downloader/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/download/downloader/#download_multiple_songs","text":"def download_multiple_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> List [ Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]]] Download multiple songs to the temp directory.","title":"download_multiple_songs"},{"location":"reference/spotdl/download/downloader/#arguments","text":"songs: The songs to download.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns","text":"list of tuples with the song and the path to the downloaded file if successful. View Source def download_multiple_songs ( self , songs : List [ Song ] ) -> List [ Tuple[Song, Optional[Path ] ]]: \"\"\" Download multiple songs to the temp directory. ### Arguments - songs: The songs to download. ### Returns - list of tuples with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( len ( songs )) tasks = [ self.pool_download(song) for song in songs ] # call all task asynchronously , and wait until all are finished results = list ( self . loop . run_until_complete ( asyncio . gather ( * tasks ))) if self . print_errors : for error in self . errors : self . progress_handler . error ( error ) if self . save_file : with open ( self . save_file , \"w\" , encoding = \"utf-8\" ) as save_file : json . dump ( [ song.json for song, _ in results ] , save_file , indent = 4 ) return results","title":"Returns"},{"location":"reference/spotdl/download/downloader/#download_song","text":"def download_song ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Download a single song.","title":"download_song"},{"location":"reference/spotdl/download/downloader/#arguments_1","text":"song: The song to download.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns_1","text":"tuple with the song and the path to the downloaded file if successful. View Source def download_song ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Download a single song. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. \"\"\" self . progress_handler . set_song_count ( 1 ) results = self . download_multiple_songs ( [ song ] ) return results [ 0 ]","title":"Returns"},{"location":"reference/spotdl/download/downloader/#pool_download","text":"def pool_download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Run asynchronous task in a pool to make sure that all processes.","title":"pool_download"},{"location":"reference/spotdl/download/downloader/#arguments_2","text":"song: The song to download.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns_2","text":"tuple with the song and the path to the downloaded file if successful.","title":"Returns"},{"location":"reference/spotdl/download/downloader/#notes","text":"This method calls self.search_and_download in a new thread. View Source async def pool_download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Run asynchronous task in a pool to make sure that all processes. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This method calls `self.search_and_download` in a new thread. \"\"\" # tasks that cannot acquire semaphore will wait here until it 's free # only certain amount of tasks can acquire the semaphore at the same time async with self.semaphore: # The following function calls blocking code, which would block whole event loop. # Therefore it has to be called in a separate thread via ThreadPoolExecutor. This # is not a problem, since GIL is released for the I/O operations, so it shouldn' t # hurt performance . return await self . loop . run_in_executor ( self . thread_executor , self . search_and_download , song )","title":"Notes"},{"location":"reference/spotdl/download/downloader/#search","text":"def search ( self , song : spotdl . types . song . Song ) -> Tuple [ str , spotdl . providers . audio . base . AudioProvider ] Search for a song using all available providers.","title":"search"},{"location":"reference/spotdl/download/downloader/#arguments_3","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns_3","text":"tuple with download url and audio provider if successful. View Source def search ( self , song : Song ) -> Tuple [ str , AudioProvider ]: \"\"\" Search for a song using all available providers. ### Arguments - song: The song to search for. ### Returns - tuple with download url and audio provider if successful. \"\"\" for audio_provider in self . audio_providers : url = audio_provider . search ( song ) if url : return url , audio_provider self . progress_handler . debug ( f \"{audio_provider.name} failed to find {song.display_name}\" ) raise LookupError ( f \"No results found for song: {song.display_name}\" )","title":"Returns"},{"location":"reference/spotdl/download/downloader/#search_and_download","text":"def search_and_download ( self , song : spotdl . types . song . Song ) -> Tuple [ spotdl . types . song . Song , Optional [ pathlib . Path ]] Search for the song and download it.","title":"search_and_download"},{"location":"reference/spotdl/download/downloader/#arguments_4","text":"song: The song to download.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns_4","text":"tuple with the song and the path to the downloaded file if successful.","title":"Returns"},{"location":"reference/spotdl/download/downloader/#notes_1","text":"This function is synchronous. View Source def search_and_download ( self , song : Song ) -> Tuple [ Song, Optional[Path ] ]: \"\"\" Search for the song and download it. ### Arguments - song: The song to download. ### Returns - tuple with the song and the path to the downloaded file if successful. ### Notes - This function is synchronous. \"\"\" # Check if we have all the metadata # and that the song object is not a placeholder # If it 's None extract the current metadata # And reinitialize the song object if song.name is None and song.url: data = song.json new_data = Song.from_url(data[\"url\"]).json data.update((k, v) for k, v in new_data.items() if v is not None) if data.get(\"song_list\"): # Reinitialize the correct song list object data[\"song_list\"] = song.song_list.__class__(**data[\"song_list\"]) # Reinitialize the song object song = Song(**data) # Create the output file path output_file = create_file_name(song, self.output, self.output_format) # Restrict the filename if needed if self.restrict is True: output_file = restrict_filename(output_file) # If the file already exists and we don' t want to overwrite it , # we can skip the download if output_file . exists () and self . overwrite == \"skip\" : self . progress_handler . log ( f \"Skipping {song.display_name}\" ) self . progress_handler . overall_completed_tasks += 1 self . progress_handler . update_overall () return song , None # Don 't skip if the file exists and overwrite is set to force if output_file.exists() and self.overwrite == \"force\": self.progress_handler.debug(f\"Overwriting {song.display_name}\") # Initalize the progress tracker display_progress_tracker = self.progress_handler.get_new_tracker(song) # Create the output directory if it doesn' t exist output_file . parent . mkdir ( parents = True , exist_ok = True ) try : if song . download_url is None : url , audio_provider = self . search ( song ) else : url = song . download_url audio_provider = AudioProvider ( output_format = self . output_format , cookie_file = self . cookie_file , search_query = self . search_query , filter_results = self . filter_results , ) # Get the download metadata using yt - dlp download_info = audio_provider . get_download_metadata ( url ) if download_info is None : self . progress_handler . debug ( f \"No download info found for {song.display_name}, url: {url}\" ) raise LookupError ( f \"yt-dlp failed to get metadata for: {song.name} - {song.artist}\" ) self . progress_handler . debug ( f \"Downloading {song.display_name} using {url}, \" f \"audio provider: {audio_provider.name}\" ) success , result = convert_sync ( ( download_info [ \"url\" ] , download_info [ \"ext\" ] ), output_file , self . ffmpeg , self . output_format , self . bitrate , self . ffmpeg_args , display_progress_tracker . progress_hook , ) if not success and result : # If the conversion failed and there is an error message # create a file with the error message # and save it in the errors directory # raise an exception with file path file_name = ( get_errors_path () / f \"ffmpeg_error_{datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.txt\" ) error_message = \"\" for key , value in result . items () : error_message += f \"### {key}:\\n{str(value).strip()}\\n\\n\" with open ( file_name , \"w\" , encoding = \"utf-8\" ) as error_path : error_path . write ( error_message ) # Remove the file that failed to convert output_file . unlink () raise FFmpegError ( f \"Failed to convert {song.display_name}, \" f \"you can find error here: {str(file_name.absolute())}\" ) download_info [ \"filepath\" ] = str ( output_file ) # Set the song 's download url if song.download_url is None: song.download_url = download_info[\"webpage_url\"] display_progress_tracker.notify_download_complete() if self.sponsor_block: post_processor = SponsorBlockPP( audio_provider.audio_handler, SPONSOR_BLOCK_CATEGORIES ) _, download_info = post_processor.run(download_info) chapters = download_info[\"sponsorblock_chapters\"] if len(chapters) > 0: self.progress_handler.log( f\"Removing {len(chapters)} sponsor segments for {song.display_name}\" ) modify_chapters = ModifyChaptersPP( audio_provider.audio_handler, remove_sponsor_segments=SPONSOR_BLOCK_CATEGORIES, ) files_to_delete, download_info = modify_chapters.run(download_info) for file_to_delete in files_to_delete: Path(file_to_delete).unlink() try: lyrics = self.search_lyrics(song) except LookupError: self.progress_handler.debug( f\"No lyrics found for {song.display_name}, \" \"lyrics providers: \" f\"{' , '.join([lprovider.name for lprovider in self.lyrics_providers])}\" ) lyrics = \"\" try: embed_metadata(output_file, song, self.output_format, lyrics) except Exception as exception: raise MetadataError( \"Failed to embed metadata to the song\" ) from exception display_progress_tracker.notify_complete() self.progress_handler.log( f' Downloaded \"{song.display_name}\" : { song . download_url }' ) return song , output_file except Exception as exception : display_progress_tracker . notify_error ( traceback . format_exc (), exception ) self . errors . append ( f \"{song.url} - {exception.__class__.__name__}: {exception}\" ) return song , None","title":"Notes"},{"location":"reference/spotdl/download/downloader/#search_lyrics","text":"def search_lyrics ( self , song : spotdl . types . song . Song ) -> str Search for lyrics using all available providers.","title":"search_lyrics"},{"location":"reference/spotdl/download/downloader/#arguments_5","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/spotdl/download/downloader/#returns_5","text":"lyrics if successful. View Source def search_lyrics ( self , song : Song ) -> str : \"\"\" Search for lyrics using all available providers. ### Arguments - song: The song to search for. ### Returns - lyrics if successful. \"\"\" for lyrics_provider in self . lyrics_providers : lyrics = lyrics_provider . get_lyrics ( song . name , song . artists ) if lyrics : self . progress_handler . debug ( f \"Found lyrics for {song.display_name} on {lyrics_provider.name}\" ) return lyrics self . progress_handler . debug ( f \"{lyrics_provider.name} failed to find lyrics \" f \"for {song.display_name}\" ) raise LookupError ( f \"No lyrics found for song: {song.display_name}\" )","title":"Returns"},{"location":"reference/spotdl/download/downloader/#downloadererror","text":"class DownloaderError ( / , * args , ** kwargs ) View Source class DownloaderError ( Exception ): \"\"\" Base class for all exceptions related to downloaders. \"\"\"","title":"DownloaderError"},{"location":"reference/spotdl/download/downloader/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/download/downloader/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/download/downloader/#methods_1","text":"","title":"Methods"},{"location":"reference/spotdl/download/downloader/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/download/progress_handler/","text":"Module spotdl.download.progress_handler Module that holds the ProgressHandler class and Song Tracker class. None View Source \"\"\" Module that holds the ProgressHandler class and Song Tracker class. \"\"\" import logging from typing import Any , Callable , Optional , List from rich.text import Text from rich.theme import Theme from rich.progress import Task from rich.console import Console from rich.style import StyleType from rich.highlighter import Highlighter from rich.progress import ( BarColumn , TimeRemainingColumn , Progress , ProgressColumn , TaskID , ) from rich.console import ( JustifyMethod , detect_legacy_windows , OverflowMethod , ) from spotdl.types.song import Song # https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py CRITICAL = 50 FATAL = CRITICAL ERROR = 40 WARNING = 30 WARN = WARNING INFO = 20 DEBUG = 10 NOTSET = 0 LEVEL_TO_NAME = { CRITICAL : \"CRITICAL\" , ERROR : \"ERROR\" , WARNING : \"WARNING\" , INFO : \"INFO\" , DEBUG : \"DEBUG\" , NOTSET : \"NOTSET\" , } NAME_TO_LEVEL = { \"CRITICAL\" : CRITICAL , \"FATAL\" : FATAL , \"ERROR\" : ERROR , \"WARN\" : WARNING , \"WARNING\" : WARNING , \"INFO\" : INFO , \"DEBUG\" : DEBUG , \"NOTSET\" : NOTSET , } THEME = Theme ( { \"bar.back\" : \"grey23\" , \"bar.complete\" : \"rgb(165,66,129)\" , \"bar.finished\" : \"rgb(114,156,31)\" , \"bar.pulse\" : \"rgb(165,66,129)\" , \"general\" : \"green\" , \"nonimportant\" : \"rgb(40,100,40)\" , \"progress.data.speed\" : \"red\" , \"progress.description\" : \"none\" , \"progress.download\" : \"green\" , \"progress.filesize\" : \"green\" , \"progress.filesize.total\" : \"green\" , \"progress.percentage\" : \"green\" , \"progress.remaining\" : \"rgb(40,100,40)\" , } ) class ProgressHandlerError ( Exception ): \"\"\" Base class for all exceptions raised by ProgressHandler subclasses. \"\"\" class SizedTextColumn ( ProgressColumn ): \"\"\" Custom sized text column based on the Rich library. \"\"\" def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super () . __init__ () def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text class ProgressHandler : \"\"\" Class for handing the progress of a download, including the progress bar. \"\"\" def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: { log_level } \" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white] {task.description} \" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \" {task.fields[message]} \" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage] {task.percentage:>3.0f} %\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , ) def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \" { self . overall_completed_tasks } / { int ( self . overall_total / 100 ) } \" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue] { message } \" ) else : logging . debug ( message ) def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green] { message } \" ) else : logging . info ( message ) def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow] { message } \" ) else : logging . warning ( message ) def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red] { message } \" ) else : logging . error ( message ) def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \" { self . overall_completed_tasks } /\" f \" { int ( self . overall_total / 100 ) } \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown () class SongTracker : \"\"\" Class to track the progress of a song. \"\"\" def __init__ ( self , parent , song : Song ) -> None : \"\"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\"\" self . parent = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), ) def update ( self , message = \"\" ): \"\"\" Called at every event. ### Arguments - message: The message to display. \"\"\" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \" { self . song . name } - { self . song . artist } : { message } \" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message ) def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \" { traceback . __class__ . __name__ } : { traceback } \" ) def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status ) def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) def progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" ) Variables CRITICAL DEBUG ERROR FATAL INFO LEVEL_TO_NAME NAME_TO_LEVEL NOTSET THEME WARN WARNING Classes ProgressHandler class ProgressHandler ( log_level : int = 20 , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], NoneType ]] = None ) View Source class ProgressHandler : \"\"\" Class for handing the progress of a download, including the progress bar. \"\"\" def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: {log_level}\" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white]{task.description}\" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \"{task.fields[message]}\" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage]{task.percentage:>3.0f}%\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , ) def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \"{self.overall_completed_tasks}/{int(self.overall_total / 100)}\" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue]{message}\" ) else : logging . debug ( message ) def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green]{message}\" ) else : logging . info ( message ) def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow]{message}\" ) else : logging . warning ( message ) def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red]{message}\" ) else : logging . error ( message ) def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \"{self.overall_completed_tasks}/\" f \"{int(self.overall_total / 100)} \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown () Methods add_song def add_song ( self , song : spotdl . types . song . Song ) -> None Adds a song to the list of songs. Arguments song: The song to add. View Source def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) close def close ( self ) -> None Close the Tui Progress Handler. View Source def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown () debug def debug ( self , message : str ) -> None Debug message. Arguments message: The message to log. View Source def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue]{message}\" ) else : logging . debug ( message ) error def error ( self , message : str ) -> None Error message. Arguments message: The message to log. View Source def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red]{message}\" ) else : logging . error ( message ) get_new_tracker def get_new_tracker ( self , song : spotdl . types . song . Song ) -> 'SongTracker' Get a new progress tracker. Arguments song: The song to track. Returns A new progress tracker. View Source def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) log def log ( self , message : str ) -> None Log message. Arguments message: The message to log. View Source def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green]{message}\" ) else : logging . info ( message ) set_song_count def set_song_count ( self , count : int ) -> None Set the number of songs to download. Arguments count: The number of songs to download. View Source def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \"{self.overall_completed_tasks}/{int(self.overall_total / 100)}\" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) set_songs def set_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> None Sets the list of songs to be downloaded. Arguments songs: The list of songs to download. View Source def set_songs ( self , songs : List [ Song ] ) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) update_overall def update_overall ( self ) -> None Update the overall progress bar. View Source def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \"{self.overall_completed_tasks}/\" f \"{int(self.overall_total / 100)} \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \"%s/%s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks warn def warn ( self , message : str ) -> None Warning message. Arguments message: The message to log. View Source def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow]{message}\" ) else : logging . warning ( message ) ProgressHandlerError class ProgressHandlerError ( / , * args , ** kwargs ) View Source class ProgressHandlerError ( Exception ): \"\"\" Base class for all exceptions raised by ProgressHandler subclasses. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. SizedTextColumn class SizedTextColumn ( text_format : str , style : Union [ str , ForwardRef ( 'Style' )] = 'none' , justify : Literal [ 'default' , 'left' , 'center' , 'right' , 'full' ] = 'left' , markup : bool = True , highlighter : Optional [ rich . highlighter . Highlighter ] = None , overflow : Optional [ Literal [ 'fold' , 'crop' , 'ellipsis' , 'ignore' ]] = None , width : int = 20 ) View Source class SizedTextColumn ( ProgressColumn ) : \"\"\" Custom sized text column based on the Rich library. \"\"\" def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super (). __init__ () def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text Ancestors (in MRO) rich.progress.ProgressColumn abc.ABC Class variables max_refresh Methods get_table_column def get_table_column ( self ) -> rich . table . Column Get a table column, used to build tasks table. View Source def get_table_column ( self ) -> Column : \"\"\"Get a table column, used to build tasks table.\"\"\" return self . _table_column or Column () render def render ( self , task : rich . progress . Task ) -> rich . text . Text Render the Column. Arguments task: The Task to render. Returns A Text object. View Source def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text SongTracker class SongTracker ( parent , song : spotdl . types . song . Song ) View Source class SongTracker : \" \"\" Class to track the progress of a song. \"\" \" def __init__ ( self , parent , song : Song ) -> None : \" \"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\" \" self . parent = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), ) def update ( self , message = \"\" ) : \" \"\" Called at every event. ### Arguments - message: The message to display. \"\" \" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \"{self.song.name} - {self.song.artist}: {message}\" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message ) def notify_error ( self , message : str , traceback : Exception ) -> None : \" \"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\" \" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \"{traceback.__class__.__name__}: {traceback}\" ) def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \" \"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\" \" self . progress = 95 self . update ( status ) def notify_complete ( self , status = \"Done\" ) -> None : \" \"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\" \" self . progress = 100 self . update ( status ) def notify_download_skip ( self , status = \"Skipped\" ) -> None : \" \"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\" \" self . progress = 100 self . update ( status ) def progress_hook ( self , progress : int ) -> None : \" \"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\" \" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" ) Methods notify_complete def notify_complete ( self , status = 'Done' ) -> None Notifies the progress handler that the song has been downloaded and converted. Arguments status: The status to display. View Source def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) notify_download_complete def notify_download_complete ( self , status = 'Embeding metadata' ) -> None Notifies the progress handler that the song has been downloaded. Arguments status: The status to display. View Source def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status ) notify_download_skip def notify_download_skip ( self , status = 'Skipped' ) -> None Notifies the progress handler that the song has been skipped. Arguments status: The status to display. View Source def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) notify_error def notify_error ( self , message : str , traceback : Exception ) -> None Logs an error message. Arguments message: The message to log. traceback: The traceback of the error. View Source def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \"{traceback.__class__.__name__}: {traceback}\" ) progress_hook def progress_hook ( self , progress : int ) -> None Updates the progress. Arguments progress: The progress to update to. View Source def progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" ) update def update ( self , message = '' ) Called at every event. Arguments message: The message to display. View Source def update ( self , message = \"\" ) : \" \"\" Called at every event. ### Arguments - message: The message to display. \"\" \" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \"{self.song.name} - {self.song.artist}: {message}\" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message )","title":"Progress Handler"},{"location":"reference/spotdl/download/progress_handler/#module-spotdldownloadprogress_handler","text":"Module that holds the ProgressHandler class and Song Tracker class. None View Source \"\"\" Module that holds the ProgressHandler class and Song Tracker class. \"\"\" import logging from typing import Any , Callable , Optional , List from rich.text import Text from rich.theme import Theme from rich.progress import Task from rich.console import Console from rich.style import StyleType from rich.highlighter import Highlighter from rich.progress import ( BarColumn , TimeRemainingColumn , Progress , ProgressColumn , TaskID , ) from rich.console import ( JustifyMethod , detect_legacy_windows , OverflowMethod , ) from spotdl.types.song import Song # https://github.com/python/cpython/blob/3.10/Lib/logging/__init__.py CRITICAL = 50 FATAL = CRITICAL ERROR = 40 WARNING = 30 WARN = WARNING INFO = 20 DEBUG = 10 NOTSET = 0 LEVEL_TO_NAME = { CRITICAL : \"CRITICAL\" , ERROR : \"ERROR\" , WARNING : \"WARNING\" , INFO : \"INFO\" , DEBUG : \"DEBUG\" , NOTSET : \"NOTSET\" , } NAME_TO_LEVEL = { \"CRITICAL\" : CRITICAL , \"FATAL\" : FATAL , \"ERROR\" : ERROR , \"WARN\" : WARNING , \"WARNING\" : WARNING , \"INFO\" : INFO , \"DEBUG\" : DEBUG , \"NOTSET\" : NOTSET , } THEME = Theme ( { \"bar.back\" : \"grey23\" , \"bar.complete\" : \"rgb(165,66,129)\" , \"bar.finished\" : \"rgb(114,156,31)\" , \"bar.pulse\" : \"rgb(165,66,129)\" , \"general\" : \"green\" , \"nonimportant\" : \"rgb(40,100,40)\" , \"progress.data.speed\" : \"red\" , \"progress.description\" : \"none\" , \"progress.download\" : \"green\" , \"progress.filesize\" : \"green\" , \"progress.filesize.total\" : \"green\" , \"progress.percentage\" : \"green\" , \"progress.remaining\" : \"rgb(40,100,40)\" , } ) class ProgressHandlerError ( Exception ): \"\"\" Base class for all exceptions raised by ProgressHandler subclasses. \"\"\" class SizedTextColumn ( ProgressColumn ): \"\"\" Custom sized text column based on the Rich library. \"\"\" def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super () . __init__ () def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text class ProgressHandler : \"\"\" Class for handing the progress of a download, including the progress bar. \"\"\" def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: { log_level } \" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white] {task.description} \" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \" {task.fields[message]} \" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage] {task.percentage:>3.0f} %\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , ) def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \" { self . overall_completed_tasks } / { int ( self . overall_total / 100 ) } \" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue] { message } \" ) else : logging . debug ( message ) def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green] { message } \" ) else : logging . info ( message ) def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow] { message } \" ) else : logging . warning ( message ) def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red] { message } \" ) else : logging . error ( message ) def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \" { self . overall_completed_tasks } /\" f \" { int ( self . overall_total / 100 ) } \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown () class SongTracker : \"\"\" Class to track the progress of a song. \"\"\" def __init__ ( self , parent , song : Song ) -> None : \"\"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\"\" self . parent = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), ) def update ( self , message = \"\" ): \"\"\" Called at every event. ### Arguments - message: The message to display. \"\"\" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \" { self . song . name } - { self . song . artist } : { message } \" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message ) def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \" { traceback . __class__ . __name__ } : { traceback } \" ) def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status ) def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status ) def progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" )","title":"Module spotdl.download.progress_handler"},{"location":"reference/spotdl/download/progress_handler/#variables","text":"CRITICAL DEBUG ERROR FATAL INFO LEVEL_TO_NAME NAME_TO_LEVEL NOTSET THEME WARN WARNING","title":"Variables"},{"location":"reference/spotdl/download/progress_handler/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/download/progress_handler/#progresshandler","text":"class ProgressHandler ( log_level : int = 20 , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], NoneType ]] = None ) View Source class ProgressHandler : \"\"\" Class for handing the progress of a download, including the progress bar. \"\"\" def __init__ ( self , log_level : int = INFO , simple_tui : bool = False , update_callback : Optional [ Callable [[ Any , str ], None ]] = None , ): \"\"\" Initialize the progress handler. ### Arguments - log_level: The log level to use. - simple_tui: Whether or not to use the simple TUI. - update_callback: A callback to call when the progress bar is updated. \"\"\" self . songs : List [ Song ] = [] self . song_count : int = 0 self . overall_progress = 0 self . overall_total = 100 self . overall_completed_tasks = 0 self . update_callback = update_callback self . previous_overall = self . overall_completed_tasks if log_level not in LEVEL_TO_NAME : raise ProgressHandlerError ( f \"Invalid log level: {log_level}\" ) self . log_level = log_level self . simple_tui = simple_tui self . quiet = self . log_level < 10 self . overall_task_id : Optional [ TaskID ] = None if not self . simple_tui : # Change color system if \"legacy\" windows terminal to prevent wrong colors displaying self . is_legacy = detect_legacy_windows () # dumb_terminals automatically handled by rich. Color system is too but it is incorrect # for legacy windows ... so no color for y'all. self . console = Console ( theme = THEME , color_system = \"truecolor\" if not self . is_legacy else None ) self . rich_progress_bar = Progress ( SizedTextColumn ( \"[white]{task.description}\" , overflow = \"ellipsis\" , width = int ( self . console . width / 3 ), ), SizedTextColumn ( \"{task.fields[message]}\" , width = 18 , style = \"nonimportant\" ), BarColumn ( bar_width = None , finished_style = \"green\" ), \"[progress.percentage]{task.percentage:>3.0f}%\" , TimeRemainingColumn (), console = self . console , # Normally when you exit the progress context manager (or call stop()) # the last refreshed display remains in the terminal with the cursor on # the following line. You can also make the progress display disappear on # exit by setting transient=True on the Progress constructor transient = self . is_legacy , ) # Basically a wrapper for rich's: with ... as ... self . rich_progress_bar . __enter__ () else : logging . basicConfig ( format = \" %(asctime)s - %(levelname)s - %(message)s \" , datefmt = \"%H:%M:%S\" , level = self . log_level , ) def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs )) def set_songs ( self , songs : List [ Song ]) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs )) def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \"{self.overall_completed_tasks}/{int(self.overall_total / 100)}\" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), ) def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue]{message}\" ) else : logging . debug ( message ) def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green]{message}\" ) else : logging . info ( message ) def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow]{message}\" ) else : logging . warning ( message ) def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red]{message}\" ) else : logging . error ( message ) def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \"{self.overall_completed_tasks}/\" f \"{int(self.overall_total / 100)} \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \" %s / %s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song ) def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown ()","title":"ProgressHandler"},{"location":"reference/spotdl/download/progress_handler/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/download/progress_handler/#add_song","text":"def add_song ( self , song : spotdl . types . song . Song ) -> None Adds a song to the list of songs.","title":"add_song"},{"location":"reference/spotdl/download/progress_handler/#arguments","text":"song: The song to add. View Source def add_song ( self , song : Song ) -> None : \"\"\" Adds a song to the list of songs. ### Arguments - song: The song to add. \"\"\" self . songs . append ( song ) self . set_song_count ( len ( self . songs ))","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#close","text":"def close ( self ) -> None Close the Tui Progress Handler. View Source def close ( self ) -> None : \"\"\" Close the Tui Progress Handler. \"\"\" if not self . simple_tui : self . rich_progress_bar . stop () else : logging . shutdown ()","title":"close"},{"location":"reference/spotdl/download/progress_handler/#debug","text":"def debug ( self , message : str ) -> None Debug message.","title":"debug"},{"location":"reference/spotdl/download/progress_handler/#arguments_1","text":"message: The message to log. View Source def debug ( self , message : str ) -> None : \"\"\" Debug message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > DEBUG : return self . rich_progress_bar . console . print ( f \"[blue]{message}\" ) else : logging . debug ( message )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#error","text":"def error ( self , message : str ) -> None Error message.","title":"error"},{"location":"reference/spotdl/download/progress_handler/#arguments_2","text":"message: The message to log. View Source def error ( self , message : str ) -> None : \"\"\" Error message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > ERROR : return self . rich_progress_bar . console . print ( f \"[red]{message}\" ) else : logging . error ( message )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#get_new_tracker","text":"def get_new_tracker ( self , song : spotdl . types . song . Song ) -> 'SongTracker' Get a new progress tracker.","title":"get_new_tracker"},{"location":"reference/spotdl/download/progress_handler/#arguments_3","text":"song: The song to track.","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#returns","text":"A new progress tracker. View Source def get_new_tracker ( self , song : Song ) -> \"SongTracker\" : \"\"\" Get a new progress tracker. ### Arguments - song: The song to track. ### Returns - A new progress tracker. \"\"\" return SongTracker ( self , song )","title":"Returns"},{"location":"reference/spotdl/download/progress_handler/#log","text":"def log ( self , message : str ) -> None Log message.","title":"log"},{"location":"reference/spotdl/download/progress_handler/#arguments_4","text":"message: The message to log. View Source def log ( self , message : str ) -> None : \"\"\" Log message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > INFO : return self . rich_progress_bar . console . print ( f \"[green]{message}\" ) else : logging . info ( message )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#set_song_count","text":"def set_song_count ( self , count : int ) -> None Set the number of songs to download.","title":"set_song_count"},{"location":"reference/spotdl/download/progress_handler/#arguments_5","text":"count: The number of songs to download. View Source def set_song_count ( self , count : int ) -> None : \"\"\" Set the number of songs to download. ### Arguments - count: The number of songs to download. \"\"\" self . song_count = count self . overall_total = 100 * count if not self . simple_tui : if self . song_count > 4 : self . overall_task_id = self . rich_progress_bar . add_task ( description = \"Total\" , message = ( f \"{self.overall_completed_tasks}/{int(self.overall_total / 100)}\" \"complete\" ), total = self . overall_total , visible = ( not self . quiet ), )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#set_songs","text":"def set_songs ( self , songs : List [ spotdl . types . song . Song ] ) -> None Sets the list of songs to be downloaded.","title":"set_songs"},{"location":"reference/spotdl/download/progress_handler/#arguments_6","text":"songs: The list of songs to download. View Source def set_songs ( self , songs : List [ Song ] ) -> None : \"\"\" Sets the list of songs to be downloaded. ### Arguments - songs: The list of songs to download. \"\"\" self . songs = songs self . set_song_count ( len ( songs ))","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#update_overall","text":"def update_overall ( self ) -> None Update the overall progress bar. View Source def update_overall ( self ) -> None : \"\"\" Update the overall progress bar. \"\"\" if not self . simple_tui : # If the overall progress bar exists if self . overall_task_id is not None : self . rich_progress_bar . update ( self . overall_task_id , message = f \"{self.overall_completed_tasks}/\" f \"{int(self.overall_total / 100)} \" \"complete\" , completed = self . overall_progress , ) else : if self . previous_overall != self . overall_completed_tasks : logging . info ( \"%s/%s complete\" , self . overall_completed_tasks , self . song_count ) self . previous_overall = self . overall_completed_tasks","title":"update_overall"},{"location":"reference/spotdl/download/progress_handler/#warn","text":"def warn ( self , message : str ) -> None Warning message.","title":"warn"},{"location":"reference/spotdl/download/progress_handler/#arguments_7","text":"message: The message to log. View Source def warn ( self , message : str ) -> None : \"\"\" Warning message. ### Arguments - message: The message to log. \"\"\" if not self . simple_tui : if self . log_level > WARNING : return self . rich_progress_bar . console . print ( f \"[yellow]{message}\" ) else : logging . warning ( message )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#progresshandlererror","text":"class ProgressHandlerError ( / , * args , ** kwargs ) View Source class ProgressHandlerError ( Exception ): \"\"\" Base class for all exceptions raised by ProgressHandler subclasses. \"\"\"","title":"ProgressHandlerError"},{"location":"reference/spotdl/download/progress_handler/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/download/progress_handler/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/download/progress_handler/#methods_1","text":"","title":"Methods"},{"location":"reference/spotdl/download/progress_handler/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/download/progress_handler/#sizedtextcolumn","text":"class SizedTextColumn ( text_format : str , style : Union [ str , ForwardRef ( 'Style' )] = 'none' , justify : Literal [ 'default' , 'left' , 'center' , 'right' , 'full' ] = 'left' , markup : bool = True , highlighter : Optional [ rich . highlighter . Highlighter ] = None , overflow : Optional [ Literal [ 'fold' , 'crop' , 'ellipsis' , 'ignore' ]] = None , width : int = 20 ) View Source class SizedTextColumn ( ProgressColumn ) : \"\"\" Custom sized text column based on the Rich library. \"\"\" def __init__ ( self , text_format : str , style : StyleType = \"none\" , justify : JustifyMethod = \"left\" , markup : bool = True , highlighter : Optional [ Highlighter ] = None , overflow : Optional [ OverflowMethod ] = None , width : int = 20 , ) -> None : \"\"\" A column containing text. ### Arguments - text_format: The format string to use for the text. - style: The style to use for the text. - justify: The justification to use for the text. - markup: Whether or not the text should be rendered as markup. - highlighter: A Highlighter to use for highlighting the text. - overflow: The overflow method to use for truncating the text. - width: The maximum width of the text. \"\"\" self . text_format = text_format self . justify : JustifyMethod = justify self . style = style self . markup = markup self . highlighter = highlighter self . overflow : Optional [ OverflowMethod ] = overflow self . width = width super (). __init__ () def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text","title":"SizedTextColumn"},{"location":"reference/spotdl/download/progress_handler/#ancestors-in-mro_1","text":"rich.progress.ProgressColumn abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/download/progress_handler/#class-variables_1","text":"max_refresh","title":"Class variables"},{"location":"reference/spotdl/download/progress_handler/#methods_2","text":"","title":"Methods"},{"location":"reference/spotdl/download/progress_handler/#get_table_column","text":"def get_table_column ( self ) -> rich . table . Column Get a table column, used to build tasks table. View Source def get_table_column ( self ) -> Column : \"\"\"Get a table column, used to build tasks table.\"\"\" return self . _table_column or Column ()","title":"get_table_column"},{"location":"reference/spotdl/download/progress_handler/#render","text":"def render ( self , task : rich . progress . Task ) -> rich . text . Text Render the Column.","title":"render"},{"location":"reference/spotdl/download/progress_handler/#arguments_8","text":"task: The Task to render.","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#returns_1","text":"A Text object. View Source def render ( self , task : Task ) -> Text : \"\"\" Render the Column. ### Arguments - task: The Task to render. ### Returns - A Text object. \"\"\" _text = self . text_format . format ( task = task ) if self . markup : text = Text . from_markup ( _text , style = self . style , justify = self . justify ) else : text = Text ( _text , style = self . style , justify = self . justify ) if self . highlighter : self . highlighter . highlight ( text ) text . truncate ( max_width = self . width , overflow = self . overflow , pad = True ) return text","title":"Returns"},{"location":"reference/spotdl/download/progress_handler/#songtracker","text":"class SongTracker ( parent , song : spotdl . types . song . Song ) View Source class SongTracker : \" \"\" Class to track the progress of a song. \"\" \" def __init__ ( self , parent , song : Song ) -> None : \" \"\" Initialize the Tui Song Tracker. ### Arguments - parent: The parent Tui Progress Handler. \"\" \" self . parent = parent self . song = song self . progress : int = 0 self . old_progress : int = 0 self . status = \"\" if not self . parent . simple_tui : self . task_id = self . parent . rich_progress_bar . add_task ( description = song . display_name , message = \"Download Started\" , total = 100 , completed = self . progress , start = False , visible = ( not self . parent . quiet ), ) def update ( self , message = \"\" ) : \" \"\" Called at every event. ### Arguments - message: The message to display. \"\" \" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \"{self.song.name} - {self.song.artist}: {message}\" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message ) def notify_error ( self , message : str , traceback : Exception ) -> None : \" \"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\" \" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \"{traceback.__class__.__name__}: {traceback}\" ) def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \" \"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\" \" self . progress = 95 self . update ( status ) def notify_complete ( self , status = \"Done\" ) -> None : \" \"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\" \" self . progress = 100 self . update ( status ) def notify_download_skip ( self , status = \"Skipped\" ) -> None : \" \"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\" \" self . progress = 100 self . update ( status ) def progress_hook ( self , progress : int ) -> None : \" \"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\" \" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" )","title":"SongTracker"},{"location":"reference/spotdl/download/progress_handler/#methods_3","text":"","title":"Methods"},{"location":"reference/spotdl/download/progress_handler/#notify_complete","text":"def notify_complete ( self , status = 'Done' ) -> None Notifies the progress handler that the song has been downloaded and converted.","title":"notify_complete"},{"location":"reference/spotdl/download/progress_handler/#arguments_9","text":"status: The status to display. View Source def notify_complete ( self , status = \"Done\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded and converted. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#notify_download_complete","text":"def notify_download_complete ( self , status = 'Embeding metadata' ) -> None Notifies the progress handler that the song has been downloaded.","title":"notify_download_complete"},{"location":"reference/spotdl/download/progress_handler/#arguments_10","text":"status: The status to display. View Source def notify_download_complete ( self , status = \"Embeding metadata\" ) -> None : \"\"\" Notifies the progress handler that the song has been downloaded. ### Arguments - status: The status to display. \"\"\" self . progress = 95 self . update ( status )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#notify_download_skip","text":"def notify_download_skip ( self , status = 'Skipped' ) -> None Notifies the progress handler that the song has been skipped.","title":"notify_download_skip"},{"location":"reference/spotdl/download/progress_handler/#arguments_11","text":"status: The status to display. View Source def notify_download_skip ( self , status = \"Skipped\" ) -> None : \"\"\" Notifies the progress handler that the song has been skipped. ### Arguments - status: The status to display. \"\"\" self . progress = 100 self . update ( status )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#notify_error","text":"def notify_error ( self , message : str , traceback : Exception ) -> None Logs an error message.","title":"notify_error"},{"location":"reference/spotdl/download/progress_handler/#arguments_12","text":"message: The message to log. traceback: The traceback of the error. View Source def notify_error ( self , message : str , traceback : Exception ) -> None : \"\"\" Logs an error message. ### Arguments - message: The message to log. - traceback: The traceback of the error. \"\"\" self . update ( \"Error\" ) self . parent . debug ( message ) self . parent . error ( f \"{traceback.__class__.__name__}: {traceback}\" )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#progress_hook","text":"def progress_hook ( self , progress : int ) -> None Updates the progress.","title":"progress_hook"},{"location":"reference/spotdl/download/progress_handler/#arguments_13","text":"progress: The progress to update to. View Source def progress_hook ( self , progress : int ) -> None : \"\"\" Updates the progress. ### Arguments - progress: The progress to update to. \"\"\" self . progress = int ( progress * 0.95 ) self . update ( \"Downloading\" )","title":"Arguments"},{"location":"reference/spotdl/download/progress_handler/#update","text":"def update ( self , message = '' ) Called at every event.","title":"update"},{"location":"reference/spotdl/download/progress_handler/#arguments_14","text":"message: The message to display. View Source def update ( self , message = \"\" ) : \" \"\" Called at every event. ### Arguments - message: The message to display. \"\" \" self . status = message # The change in progress since last update delta = self . progress - self . old_progress if not self . parent . simple_tui : # Update the progress bar # `start_task` called everytime to ensure progress is remove from indeterminate state self . parent . rich_progress_bar . start_task ( self . task_id ) self . parent . rich_progress_bar . update ( self . task_id , description = self . song . display_name , message = message , completed = self . progress , ) # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . rich_progress_bar . remove_task ( self . task_id ) else : # If task is complete if self . progress == 100 or message == \"Error\" : self . parent . overall_completed_tasks += 1 self . parent . log ( f \"{self.song.name} - {self.song.artist}: {message}\" ) # Update the overall progress bar if self . parent . song_count == self . parent . overall_completed_tasks : self . parent . overall_progress = self . parent . song_count * 100 else : self . parent . overall_progress += delta self . parent . update_overall () self . old_progress = self . progress if self . parent . update_callback : self . parent . update_callback ( self , message )","title":"Arguments"},{"location":"reference/spotdl/providers/","text":"Module spotdl.providers Different types of data providers for spotdl. None View Source \"\"\" Different types of data providers for spotdl . \"\"\" Sub-modules spotdl.providers.audio spotdl.providers.lyrics","title":"Index"},{"location":"reference/spotdl/providers/#module-spotdlproviders","text":"Different types of data providers for spotdl. None View Source \"\"\" Different types of data providers for spotdl . \"\"\"","title":"Module spotdl.providers"},{"location":"reference/spotdl/providers/#sub-modules","text":"spotdl.providers.audio spotdl.providers.lyrics","title":"Sub-modules"},{"location":"reference/spotdl/providers/audio/","text":"Module spotdl.providers.audio Audio providers for spotdl. None View Source \"\"\" Audio providers for spotdl. \"\"\" from spotdl.providers.audio.youtube import YouTube from spotdl.providers.audio.ytmusic import YouTubeMusic Sub-modules spotdl.providers.audio.base spotdl.providers.audio.youtube spotdl.providers.audio.ytmusic","title":"Index"},{"location":"reference/spotdl/providers/audio/#module-spotdlprovidersaudio","text":"Audio providers for spotdl. None View Source \"\"\" Audio providers for spotdl. \"\"\" from spotdl.providers.audio.youtube import YouTube from spotdl.providers.audio.ytmusic import YouTubeMusic","title":"Module spotdl.providers.audio"},{"location":"reference/spotdl/providers/audio/#sub-modules","text":"spotdl.providers.audio.base spotdl.providers.audio.youtube spotdl.providers.audio.ytmusic","title":"Sub-modules"},{"location":"reference/spotdl/providers/audio/base/","text":"Module spotdl.providers.audio.base Base audio provider module. None View Source \"\"\" Base audio provider module. \"\"\" from typing import Dict , Optional from yt_dlp import YoutubeDL from spotdl.types import Song class AudioProviderError ( Exception ): \"\"\" Base class for all exceptions related to audio searching/downloading. \"\"\" class YTDLLogger : \"\"\" Custom YT-dlp logger. \"\"\" def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception ( msg ) class AudioProvider : \"\"\" Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler. \"\"\" def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : str = \" {artists} - {title} \" , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , } ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError def get_results ( self , search_term : str , ** kwargs ): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError def order_results ( self , results , song : Song ): \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url { url } \" ) @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__ Classes AudioProvider class AudioProvider ( output_format : str = 'mp3' , cookie_file : Optional [ str ] = None , search_query : str = ' {artists} - {title} ' , filter_results : bool = True ) View Source class AudioProvider : \"\"\" Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler. \"\"\" def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : str = \"{artists} - {title}\" , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , } ) def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError def get_results ( self , search_term : str , ** kwargs ) : \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError def order_results ( self , results , song : Song ) : \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" ) @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__ Descendants spotdl.providers.audio.youtube.YouTube spotdl.providers.audio.ytmusic.YouTubeMusic Instance variables name Get the name of the provider. Returns The name of the provider. Methods get_download_metadata def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp. Arguments url: The url to get metadata for. Returns A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" ) get_results def get_results ( self , search_term : str , ** kwargs ) Get results from audio provider. Arguments search_term: The search term to use. kwargs: Additional arguments. Returns A list of results. View Source def get_results(self, search_term: str, **kwargs): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError order_results def order_results ( self , results , song : spotdl . types . song . Song ) Order results. Arguments results: The results to order. song: The song to order for. Returns The ordered results. View Source def order_results ( self , results , song : Song ) : \"\"\" Order results . ### Arguments - results : The results to order . - song : The song to order for . ### Returns - The ordered results . \"\"\" raise NotImplementedError search def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a song and return best match. Arguments song: The song to search for. Returns The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError AudioProviderError class AudioProviderError ( / , * args , ** kwargs ) View Source class AudioProviderError ( Exception ): \"\"\" Base class for all exceptions related to audio searching/downloading. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. YTDLLogger class YTDLLogger ( / , * args , ** kwargs ) View Source class YTDLLogger: \"\"\" Custom YT-dlp logger. \"\"\" def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception ( msg ) Methods debug def debug ( self , msg ) YTDL uses this to print debug messages. View Source def debug(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 error def error ( self , msg ) YTDL uses this to print errors. View Source def error(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception(msg) warning def warning ( self , msg ) YTDL uses this to print warnings. View Source def warning(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107","title":"Base"},{"location":"reference/spotdl/providers/audio/base/#module-spotdlprovidersaudiobase","text":"Base audio provider module. None View Source \"\"\" Base audio provider module. \"\"\" from typing import Dict , Optional from yt_dlp import YoutubeDL from spotdl.types import Song class AudioProviderError ( Exception ): \"\"\" Base class for all exceptions related to audio searching/downloading. \"\"\" class YTDLLogger : \"\"\" Custom YT-dlp logger. \"\"\" def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception ( msg ) class AudioProvider : \"\"\" Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler. \"\"\" def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : str = \" {artists} - {title} \" , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , } ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError def get_results ( self , search_term : str , ** kwargs ): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError def order_results ( self , results , song : Song ): \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url { url } \" ) @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__","title":"Module spotdl.providers.audio.base"},{"location":"reference/spotdl/providers/audio/base/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/audio/base/#audioprovider","text":"class AudioProvider ( output_format : str = 'mp3' , cookie_file : Optional [ str ] = None , search_query : str = ' {artists} - {title} ' , filter_results : bool = True ) View Source class AudioProvider : \"\"\" Base class for all other providers. Provides some common functionality. Handles the yt-dlp audio handler. \"\"\" def __init__ ( self , output_format : str = \"mp3\" , cookie_file : Optional [ str ] = None , search_query : str = \"{artists} - {title}\" , filter_results : bool = True , ) -> None : \"\"\" Base class for audio providers. ### Arguments - output_directory: The directory to save the downloaded songs to. - output_format: The format to save the downloaded songs in. - cookie_file: The path to a file containing cookies to be used by YTDL. - search_query: The query to use when searching for songs. - filter_results: Whether to filter results. ### Errors - raises `NotImplementedError` if self.name is not set. \"\"\" self . output_format = output_format self . cookie_file = cookie_file self . search_query = search_query self . filter_results = filter_results if self . output_format == \"m4a\" : ytdl_format = \"bestaudio[ext=m4a]/bestaudio/best\" elif self . output_format == \"opus\" : ytdl_format = \"bestaudio[ext=webm]/bestaudio/best\" else : ytdl_format = \"bestaudio\" self . audio_handler = YoutubeDL ( { \"format\" : ytdl_format , \"quiet\" : True , \"no_warnings\" : True , \"encoding\" : \"UTF-8\" , \"logger\" : YTDLLogger (), \"cookiefile\" : self . cookie_file , } ) def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError def get_results ( self , search_term : str , ** kwargs ) : \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError def order_results ( self , results , song : Song ) : \"\"\" Order results. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" raise NotImplementedError def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" ) @property def name ( self ) -> str : \"\"\" Get the name of the provider. ### Returns - The name of the provider. \"\"\" return self . __class__ . __name__","title":"AudioProvider"},{"location":"reference/spotdl/providers/audio/base/#descendants","text":"spotdl.providers.audio.youtube.YouTube spotdl.providers.audio.ytmusic.YouTubeMusic","title":"Descendants"},{"location":"reference/spotdl/providers/audio/base/#instance-variables","text":"name Get the name of the provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/audio/base/#returns","text":"The name of the provider.","title":"Returns"},{"location":"reference/spotdl/providers/audio/base/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/audio/base/#get_download_metadata","text":"def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp.","title":"get_download_metadata"},{"location":"reference/spotdl/providers/audio/base/#arguments","text":"url: The url to get metadata for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/base/#returns_1","text":"A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" )","title":"Returns"},{"location":"reference/spotdl/providers/audio/base/#get_results","text":"def get_results ( self , search_term : str , ** kwargs ) Get results from audio provider.","title":"get_results"},{"location":"reference/spotdl/providers/audio/base/#arguments_1","text":"search_term: The search term to use. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/base/#returns_2","text":"A list of results. View Source def get_results(self, search_term: str, **kwargs): \"\"\" Get results from audio provider. ### Arguments - search_term: The search term to use. - kwargs: Additional arguments. ### Returns - A list of results. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/providers/audio/base/#order_results","text":"def order_results ( self , results , song : spotdl . types . song . Song ) Order results.","title":"order_results"},{"location":"reference/spotdl/providers/audio/base/#arguments_2","text":"results: The results to order. song: The song to order for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/base/#returns_3","text":"The ordered results. View Source def order_results ( self , results , song : Song ) : \"\"\" Order results . ### Arguments - results : The results to order . - song : The song to order for . ### Returns - The ordered results . \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/providers/audio/base/#search","text":"def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a song and return best match.","title":"search"},{"location":"reference/spotdl/providers/audio/base/#arguments_3","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/base/#returns_4","text":"The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song and return best match. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/providers/audio/base/#audioprovidererror","text":"class AudioProviderError ( / , * args , ** kwargs ) View Source class AudioProviderError ( Exception ): \"\"\" Base class for all exceptions related to audio searching/downloading. \"\"\"","title":"AudioProviderError"},{"location":"reference/spotdl/providers/audio/base/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/audio/base/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/providers/audio/base/#methods_1","text":"","title":"Methods"},{"location":"reference/spotdl/providers/audio/base/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/providers/audio/base/#ytdllogger","text":"class YTDLLogger ( / , * args , ** kwargs ) View Source class YTDLLogger: \"\"\" Custom YT-dlp logger. \"\"\" def debug ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107 def warning ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107 def error ( self , msg ): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception ( msg )","title":"YTDLLogger"},{"location":"reference/spotdl/providers/audio/base/#methods_2","text":"","title":"Methods"},{"location":"reference/spotdl/providers/audio/base/#debug","text":"def debug ( self , msg ) YTDL uses this to print debug messages. View Source def debug(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print debug messages. \"\"\" pass # pylint: disable=W0107","title":"debug"},{"location":"reference/spotdl/providers/audio/base/#error","text":"def error ( self , msg ) YTDL uses this to print errors. View Source def error(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print errors. \"\"\" raise Exception(msg)","title":"error"},{"location":"reference/spotdl/providers/audio/base/#warning","text":"def warning ( self , msg ) YTDL uses this to print warnings. View Source def warning(self, msg): # pylint: disable=R0201 \"\"\" YTDL uses this to print warnings. \"\"\" pass # pylint: disable=W0107","title":"warning"},{"location":"reference/spotdl/providers/audio/youtube/","text":"Module spotdl.providers.audio.youtube Youtube module for downloading and searching songs. None View Source \"\"\" Youtube module for downloading and searching songs. \"\"\" from typing import Any , Dict , List , Optional from pytube import YouTube as PyTube , Search from slugify import slugify from spotdl.utils.formatter import create_song_title , create_search_query from spotdl.utils.providers import match_percentage from spotdl.providers.audio.base import AudioProvider from spotdl.types import Song class YouTube ( AudioProvider ): \"\"\" YouTube audio provider class \"\"\" def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ] @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ PyTube ]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ) . results def order_results ( self , results : List [ PyTube ], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song's artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70% artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result . watch_url ] = average_match return links_with_match_value Classes YouTube class YouTube ( output_format : str = 'mp3' , cookie_file : Optional [ str ] = None , search_query : str = ' {artists} - {title} ' , filter_results : bool = True ) View Source class YouTube ( AudioProvider ) : \"\"\" YouTube audio provider class \"\"\" def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ). lower () # Query YTM by songs only first , this way if we get correct result on the first try # we don 't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self.get_results(search_query) if results is None: return None if self.filter_results: ordered_results = {results[0].watch_url: 100} else: # Order results ordered_results = self.order_results(results, song) # No matches found if len(ordered_results) == 0: return None result_items = list(ordered_results.items()) # Sort results by highest score sorted_results = sorted(result_items, key=lambda x: x[1], reverse=True) # Return the first result return sorted_results[0][0] @staticmethod def get_results( search_term: str, *_args, **_kwargs ) -> Optional[List[PyTube]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search(search_term).results def order_results(self, results: List[PyTube], song: Song) -> Dict[str, Any]: \"\"\" Filter results based on the song' s metadata . ### Arguments - results : The results to order . - song : The song to order for . ### Returns - The ordered results . \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify(song.name) slug_song_title = slugify( create_song_title(song.name, song.artists) if not self.search_query else create_search_query(song, self.search_query, False, None, True) ) for result in results: # Skip results without id if result.video_id is None: continue # Slugify some variables slug_result_name = slugify(result.title) sentence_words = slug_song_name.replace(\" - \", \" \").split(\" \") # Check for common words in result name common_word = any( word != \" \" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song ' s artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70 % artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50 % if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result.watch_url ] = average_match return links_with_match_value Ancestors (in MRO) spotdl.providers.audio.base.AudioProvider Static methods get_results def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ pytube . __main__ . YouTube ]] Get results from YouTube Arguments search_term: The search term to search for. args: Unused. kwargs: Unused. Returns A list of YouTube results if found, None otherwise. View Source @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List[PyTube ] ]: # pylint : disable = W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ). results Instance variables name Get the name of the provider. Returns The name of the provider. Methods get_download_metadata def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp. Arguments url: The url to get metadata for. Returns A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" ) order_results def order_results ( self , results : List [ pytube . __main__ . YouTube ], song : spotdl . types . song . Song ) -> Dict [ str , Any ] Filter results based on the song's metadata. Arguments results: The results to order. song: The song to order for. Returns The ordered results. View Source def order_results ( self , results : List [ PyTube ] , song : Song ) -> Dict [ str, Any ] : \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ). split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song ' s artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70 % artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50 % if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result.watch_url ] = average_match return links_with_match_value search def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a video on YouTube. Arguments song: The song to search for. Returns The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ). lower () # Query YTM by songs only first , this way if we get correct result on the first try # we don ' t have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ] , reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ]","title":"Youtube"},{"location":"reference/spotdl/providers/audio/youtube/#module-spotdlprovidersaudioyoutube","text":"Youtube module for downloading and searching songs. None View Source \"\"\" Youtube module for downloading and searching songs. \"\"\" from typing import Any , Dict , List , Optional from pytube import YouTube as PyTube , Search from slugify import slugify from spotdl.utils.formatter import create_song_title , create_search_query from spotdl.utils.providers import match_percentage from spotdl.providers.audio.base import AudioProvider from spotdl.types import Song class YouTube ( AudioProvider ): \"\"\" YouTube audio provider class \"\"\" def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ] @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ PyTube ]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ) . results def order_results ( self , results : List [ PyTube ], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song's artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70% artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result . watch_url ] = average_match return links_with_match_value","title":"Module spotdl.providers.audio.youtube"},{"location":"reference/spotdl/providers/audio/youtube/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/audio/youtube/#youtube","text":"class YouTube ( output_format : str = 'mp3' , cookie_file : Optional [ str ] = None , search_query : str = ' {artists} - {title} ' , filter_results : bool = True ) View Source class YouTube ( AudioProvider ) : \"\"\" YouTube audio provider class \"\"\" def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ). lower () # Query YTM by songs only first , this way if we get correct result on the first try # we don 't have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self.get_results(search_query) if results is None: return None if self.filter_results: ordered_results = {results[0].watch_url: 100} else: # Order results ordered_results = self.order_results(results, song) # No matches found if len(ordered_results) == 0: return None result_items = list(ordered_results.items()) # Sort results by highest score sorted_results = sorted(result_items, key=lambda x: x[1], reverse=True) # Return the first result return sorted_results[0][0] @staticmethod def get_results( search_term: str, *_args, **_kwargs ) -> Optional[List[PyTube]]: # pylint: disable=W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search(search_term).results def order_results(self, results: List[PyTube], song: Song) -> Dict[str, Any]: \"\"\" Filter results based on the song' s metadata . ### Arguments - results : The results to order . - song : The song to order for . ### Returns - The ordered results . \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify(song.name) slug_song_title = slugify( create_song_title(song.name, song.artists) if not self.search_query else create_search_query(song, self.search_query, False, None, True) ) for result in results: # Skip results without id if result.video_id is None: continue # Slugify some variables slug_result_name = slugify(result.title) sentence_words = slug_song_name.replace(\" - \", \" \").split(\" \") # Check for common words in result name common_word = any( word != \" \" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song ' s artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70 % artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50 % if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result.watch_url ] = average_match return links_with_match_value","title":"YouTube"},{"location":"reference/spotdl/providers/audio/youtube/#ancestors-in-mro","text":"spotdl.providers.audio.base.AudioProvider","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/audio/youtube/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/providers/audio/youtube/#get_results","text":"def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List [ pytube . __main__ . YouTube ]] Get results from YouTube","title":"get_results"},{"location":"reference/spotdl/providers/audio/youtube/#arguments","text":"search_term: The search term to search for. args: Unused. kwargs: Unused.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/youtube/#returns","text":"A list of YouTube results if found, None otherwise. View Source @staticmethod def get_results ( search_term : str , * _args , ** _kwargs ) -> Optional [ List[PyTube ] ]: # pylint : disable = W0221 \"\"\" Get results from YouTube ### Arguments - search_term: The search term to search for. - args: Unused. - kwargs: Unused. ### Returns - A list of YouTube results if found, None otherwise. \"\"\" return Search ( search_term ). results","title":"Returns"},{"location":"reference/spotdl/providers/audio/youtube/#instance-variables","text":"name Get the name of the provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/audio/youtube/#returns_1","text":"The name of the provider.","title":"Returns"},{"location":"reference/spotdl/providers/audio/youtube/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/audio/youtube/#get_download_metadata","text":"def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp.","title":"get_download_metadata"},{"location":"reference/spotdl/providers/audio/youtube/#arguments_1","text":"url: The url to get metadata for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/youtube/#returns_2","text":"A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" )","title":"Returns"},{"location":"reference/spotdl/providers/audio/youtube/#order_results","text":"def order_results ( self , results : List [ pytube . __main__ . YouTube ], song : spotdl . types . song . Song ) -> Dict [ str , Any ] Filter results based on the song's metadata.","title":"order_results"},{"location":"reference/spotdl/providers/audio/youtube/#arguments_2","text":"results: The results to order. song: The song to order for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/youtube/#returns_3","text":"The ordered results. View Source def order_results ( self , results : List [ PyTube ] , song : Song ) -> Dict [ str, Any ] : \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to order. - song: The song to order for. ### Returns - The ordered results. \"\"\" # Assign an overall avg match value to each result links_with_match_value = {} # Slugify song title slug_song_name = slugify ( song . name ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) for result in results : # Skip results without id if result . video_id is None : continue # Slugify some variables slug_result_name = slugify ( result . title ) sentence_words = slug_song_name . replace ( \"-\" , \" \" ). split ( \" \" ) # Check for common words in result name common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Find artist match artist_match_number = 0.0 # Calculate artist match for each artist # in the song ' s artist list for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # skip results with artist match lower than 70 % artist_match = artist_match_number / len ( song . artists ) if artist_match < 70 : continue # Calculate name match name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50 % if name_match < 50 : continue # Calculate time match time_match = ( 100 - ( result . length - song . duration ** 2 ) / song . duration * 100 ) average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result.watch_url ] = average_match return links_with_match_value","title":"Returns"},{"location":"reference/spotdl/providers/audio/youtube/#search","text":"def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a video on YouTube.","title":"search"},{"location":"reference/spotdl/providers/audio/youtube/#arguments_3","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/youtube/#returns_4","text":"The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a video on YouTube. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # if isrc is not None then we try to find song with it if song . isrc : isrc_results = self . get_results ( song . isrc ) if isrc_results and len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] if isrc_result and isrc_result . watch_url is not None : return isrc_result . watch_url search_query = create_song_title ( song . name , song . artists ). lower () # Query YTM by songs only first , this way if we get correct result on the first try # we don ' t have to make another request to ytmusic api that could result in us # getting rate limited sooner results = self . get_results ( search_query ) if results is None : return None if self . filter_results : ordered_results = { results [ 0 ] . watch_url : 100 } else : # Order results ordered_results = self . order_results ( results , song ) # No matches found if len ( ordered_results ) == 0 : return None result_items = list ( ordered_results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ] , reverse = True ) # Return the first result return sorted_results [ 0 ][ 0 ]","title":"Returns"},{"location":"reference/spotdl/providers/audio/ytmusic/","text":"Module spotdl.providers.audio.ytmusic YTMusic module for downloading and searching songs. None View Source \"\"\" YTMusic module for downloading and searching songs. \"\"\" from typing import Any , Dict , List , Optional from ytmusicapi import YTMusic from slugify import slugify from spotdl.utils.providers import match_percentage from spotdl.providers.audio.base import AudioProvider , AudioProviderError from spotdl.types import Song from spotdl.utils.formatter import ( create_song_title , parse_duration , create_search_query , ) class YouTubeMusic ( AudioProvider ): \"\"\" YouTube Music audio provider class \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic () # Check if we are getting results from YouTube Music test_results = self . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use VPN or other audio provider.\" ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] name_match = match_percentage ( isrc_result [ \"name\" ] . lower (), song . name . lower ()) delta = isrc_result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result . get ( \"link\" ) and name_match > 90 and time_match > 90 ): return isrc_result [ \"link\" ] search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ] def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v= { result [ 'videoId' ] } \" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \" { slug_song_artist } - { slug_result_name } \" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value Classes YouTubeMusic class YouTubeMusic ( * args : Any , ** kwargs : Any ) View Source class YouTubeMusic ( AudioProvider ): \"\"\" YouTube Music audio provider class \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic () # Check if we are getting results from YouTube Music test_results = self . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use VPN or other audio provider.\" ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] name_match = match_percentage ( isrc_result [ \"name\" ] . lower (), song . name . lower ()) delta = isrc_result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result . get ( \"link\" ) and name_match > 90 and time_match > 90 ): return isrc_result [ \"link\" ] search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ] def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v={result['videoId']}\" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \"{slug_song_artist}-{slug_result_name}\" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value Ancestors (in MRO) spotdl.providers.audio.base.AudioProvider Instance variables name Get the name of the provider. Returns The name of the provider. Methods get_download_metadata def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp. Arguments url: The url to get metadata for. Returns A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" ) get_results def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]] Get results from YouTube Music API and simplify them Arguments search_term: The search term to search for. kwargs: other keyword arguments passed to the YTMusic.search method. Returns A list of simplified results (dicts) View Source def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]] : \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v={result[' videoId ']}\" , \"album\" : result . get ( \"album\" , {}). get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results order_results def order_results ( self , results : List [ Dict [ str , Any ]], song : spotdl . types . song . Song ) -> Dict [ str , Any ] Filter results based on the song's metadata. Arguments results: The results to filter. song: The song to filter by. Returns A dict of filtered results. View Source def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \"{slug_song_artist}-{slug_result_name}\" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value search def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a song on YouTube Music. Arguments song: The song to search for. Returns The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it 's available if song.isrc: isrc_results = self.get_results(song.isrc, filter=\"songs\") if len(isrc_results) == 1: isrc_result = isrc_results[0] name_match = match_percentage(isrc_result[\"name\"].lower(), song.name.lower()) delta = isrc_result[\"duration\"] - song.duration non_match_value = (delta**2) / song.duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result.get(\"link\") and name_match > 90 and time_match > 90 ): return isrc_result[\"link\"] search_query = create_song_title(song.name, song.artists).lower() # Query YTM by songs only first, this way if we get correct result on the first try # we don' t have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ] : 100 } # song type results are always more accurate than video type , # so if we get score of 80 or above # we are almost 100 % sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ] ) if songs [ best_result ] >= 80 : return best_result # We didn ' t find the correct song on the first try so now we get video type results # add them to song_results , and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ] : 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ] , reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ]","title":"Ytmusic"},{"location":"reference/spotdl/providers/audio/ytmusic/#module-spotdlprovidersaudioytmusic","text":"YTMusic module for downloading and searching songs. None View Source \"\"\" YTMusic module for downloading and searching songs. \"\"\" from typing import Any , Dict , List , Optional from ytmusicapi import YTMusic from slugify import slugify from spotdl.utils.providers import match_percentage from spotdl.providers.audio.base import AudioProvider , AudioProviderError from spotdl.types import Song from spotdl.utils.formatter import ( create_song_title , parse_duration , create_search_query , ) class YouTubeMusic ( AudioProvider ): \"\"\" YouTube Music audio provider class \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic () # Check if we are getting results from YouTube Music test_results = self . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use VPN or other audio provider.\" ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] name_match = match_percentage ( isrc_result [ \"name\" ] . lower (), song . name . lower ()) delta = isrc_result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result . get ( \"link\" ) and name_match > 90 and time_match > 90 ): return isrc_result [ \"link\" ] search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ] def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v= { result [ 'videoId' ] } \" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \" { slug_song_artist } - { slug_result_name } \" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value","title":"Module spotdl.providers.audio.ytmusic"},{"location":"reference/spotdl/providers/audio/ytmusic/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/audio/ytmusic/#youtubemusic","text":"class YouTubeMusic ( * args : Any , ** kwargs : Any ) View Source class YouTubeMusic ( AudioProvider ): \"\"\" YouTube Music audio provider class \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : \"\"\" Initialize the YouTube Music API ### Arguments - args: Arguments passed to the `AudioProvider` class. - kwargs: Keyword arguments passed to the `AudioProvider` class. \"\"\" super () . __init__ ( * args , ** kwargs ) self . client = YTMusic () # Check if we are getting results from YouTube Music test_results = self . get_results ( \"a\" ) if len ( test_results ) == 0 : raise AudioProviderError ( \"Could not connect to YouTube Music API. Use VPN or other audio provider.\" ) def search ( self , song : Song ) -> Optional [ str ]: \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it's available if song . isrc : isrc_results = self . get_results ( song . isrc , filter = \"songs\" ) if len ( isrc_results ) == 1 : isrc_result = isrc_results [ 0 ] name_match = match_percentage ( isrc_result [ \"name\" ] . lower (), song . name . lower ()) delta = isrc_result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result . get ( \"link\" ) and name_match > 90 and time_match > 90 ): return isrc_result [ \"link\" ] search_query = create_song_title ( song . name , song . artists ) . lower () # Query YTM by songs only first, this way if we get correct result on the first try # we don't have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ]: 100 } # song type results are always more accurate than video type, # so if we get score of 80 or above # we are almost 100% sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ]) if songs [ best_result ] >= 80 : return best_result # We didn't find the correct song on the first try so now we get video type results # add them to song_results, and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ]: 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ], reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ] def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]]: \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v={result['videoId']}\" , \"album\" : result . get ( \"album\" , {}) . get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \"{slug_song_artist}-{slug_result_name}\" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value","title":"YouTubeMusic"},{"location":"reference/spotdl/providers/audio/ytmusic/#ancestors-in-mro","text":"spotdl.providers.audio.base.AudioProvider","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/audio/ytmusic/#instance-variables","text":"name Get the name of the provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/audio/ytmusic/#returns","text":"The name of the provider.","title":"Returns"},{"location":"reference/spotdl/providers/audio/ytmusic/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/audio/ytmusic/#get_download_metadata","text":"def get_download_metadata ( self , url : str ) -> Dict Get metadata for a download using yt-dlp.","title":"get_download_metadata"},{"location":"reference/spotdl/providers/audio/ytmusic/#arguments","text":"url: The url to get metadata for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/ytmusic/#returns_1","text":"A dictionary containing the metadata. View Source def get_download_metadata ( self , url : str ) -> Dict : \"\"\" Get metadata for a download using yt-dlp. ### Arguments - url: The url to get metadata for. ### Returns - A dictionary containing the metadata. \"\"\" data = self . audio_handler . extract_info ( url , download = False ) if data : return data raise AudioProviderError ( f \"No metadata found for the provided url {url}\" )","title":"Returns"},{"location":"reference/spotdl/providers/audio/ytmusic/#get_results","text":"def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]] Get results from YouTube Music API and simplify them","title":"get_results"},{"location":"reference/spotdl/providers/audio/ytmusic/#arguments_1","text":"search_term: The search term to search for. kwargs: other keyword arguments passed to the YTMusic.search method.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/ytmusic/#returns_2","text":"A list of simplified results (dicts) View Source def get_results ( self , search_term : str , ** kwargs ) -> List [ Dict [ str , Any ]] : \"\"\" Get results from YouTube Music API and simplify them ### Arguments - search_term: The search term to search for. - kwargs: other keyword arguments passed to the `YTMusic.search` method. ### Returns - A list of simplified results (dicts) \"\"\" results = self . client . search ( search_term , ** kwargs ) # Simplify results simplified_results = [] for result in results : if result . get ( \"videoId\" ) is None : continue simplified_results . append ( { \"name\" : result [ \"title\" ], \"type\" : result [ \"resultType\" ], \"link\" : f \"https://youtube.com/watch?v={result[' videoId ']}\" , \"album\" : result . get ( \"album\" , {}). get ( \"name\" ), \"duration\" : parse_duration ( result . get ( \"duration\" )), \"artists\" : \", \" . join ( map ( lambda a : a [ \"name\" ], result [ \"artists\" ])), } ) return simplified_results","title":"Returns"},{"location":"reference/spotdl/providers/audio/ytmusic/#order_results","text":"def order_results ( self , results : List [ Dict [ str , Any ]], song : spotdl . types . song . Song ) -> Dict [ str , Any ] Filter results based on the song's metadata.","title":"order_results"},{"location":"reference/spotdl/providers/audio/ytmusic/#arguments_2","text":"results: The results to filter. song: The song to filter by.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/ytmusic/#returns_3","text":"A dict of filtered results. View Source def order_results ( self , results : List [ Dict [ str , Any ]], song : Song ) -> Dict [ str , Any ]: \"\"\" Filter results based on the song's metadata. ### Arguments - results: The results to filter. - song: The song to filter by. ### Returns - A dict of filtered results. \"\"\" # Slugify some variables slug_song_name = slugify ( song . name ) slug_album_name = slugify ( song . album_name ) slug_song_artist = slugify ( song . artist ) slug_song_title = slugify ( create_song_title ( song . name , song . artists ) if not self . search_query else create_search_query ( song , self . search_query , False , None , True ) ) # Assign an overall avg match value to each result links_with_match_value = {} for result in results : # Slugify result title slug_result_name = slugify ( result [ \"name\" ]) # check for common words in result name sentence_words = slug_song_name . replace ( \"-\" , \" \" ) . split ( \" \" ) common_word = any ( word != \"\" and word in slug_result_name for word in sentence_words ) # skip results that have no common words in their name if not common_word : continue # Artist divide number artist_divide_number = len ( song . artists ) # Find artist match artist_match_number = 0.0 if result [ \"type\" ] == \"song\" : # Artist results has only one artist # So we fallback to matching the song title # if len(result[\"artists\"].split(\",\")) == 1: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slug_result_name # ) # else: # for artist in song.artists: # artist_match_number += match_percentage( # slugify(artist), slugify(result[\"artists\"]) # ) for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slugify ( result [ \"artists\" ]) ) else : for artist in song . artists : artist_match_number += match_percentage ( slugify ( artist ), slug_result_name ) # If we didn't find any artist match, # we fallback to channel name match if artist_match_number <= 50 : channel_name_match = match_percentage ( slugify ( song . artist ), slugify ( result [ \"artists\" ]), ) if channel_name_match > artist_match_number : artist_match_number = channel_name_match artist_divide_number = 1 # skip results with artist match lower than 70% artist_match = artist_match_number / artist_divide_number if artist_match < 70 : continue # Calculate name match # for different result types if result [ \"type\" ] == \"song\" : name_match = match_percentage ( slug_result_name , slug_song_name ) else : # We are almost certain that this result # contains the correct song artist # so if the title doesn't contain the song artist in it # we append slug_song_artist to the title if artist_match > 90 and slug_song_artist not in slug_result_name : name_match = match_percentage ( f \"{slug_song_artist}-{slug_result_name}\" , slug_song_title ) else : name_match = match_percentage ( slug_result_name , slug_song_title ) # Drop results with name match lower than 50% if name_match < 50 : continue # Find album match album_match = 0.0 album = None # Calculate album match only for songs if result [ \"type\" ] == \"song\" : album = result . get ( \"album\" ) if album : album_match = match_percentage ( slugify ( album ), slug_album_name ) # Calculate time match delta = result [ \"duration\" ] - song . duration non_match_value = ( delta ** 2 ) / song . duration * 100 time_match = 100 - non_match_value if result [ \"type\" ] == \"song\" : if album is None : # Don't use album match # If we didn't find album for the result, average_match = ( artist_match + name_match + time_match ) / 3 elif ( match_percentage ( album . lower (), result [ \"name\" ] . lower ()) > 95 and album . lower () != song . album_name . lower () ): # If the album name is similar to the result song name, # But the album name is different from the song album name # We don't use album match average_match = ( artist_match + name_match + time_match ) / 3 else : average_match = ( artist_match + album_match + name_match + time_match ) / 4 else : # Don't use album match for videos average_match = ( artist_match + name_match + time_match ) / 3 # the results along with the avg Match links_with_match_value [ result [ \"link\" ]] = average_match return links_with_match_value","title":"Returns"},{"location":"reference/spotdl/providers/audio/ytmusic/#search","text":"def search ( self , song : spotdl . types . song . Song ) -> Optional [ str ] Search for a song on YouTube Music.","title":"search"},{"location":"reference/spotdl/providers/audio/ytmusic/#arguments_3","text":"song: The song to search for.","title":"Arguments"},{"location":"reference/spotdl/providers/audio/ytmusic/#returns_4","text":"The url of the best match or None if no match was found. View Source def search ( self , song : Song ) -> Optional [ str ] : \"\"\" Search for a song on YouTube Music. ### Arguments - song: The song to search for. ### Returns - The url of the best match or None if no match was found. \"\"\" if self . search_query : search_query = create_search_query ( song , self . search_query , False , None , True ) else : # search for song using isrc if it 's available if song.isrc: isrc_results = self.get_results(song.isrc, filter=\"songs\") if len(isrc_results) == 1: isrc_result = isrc_results[0] name_match = match_percentage(isrc_result[\"name\"].lower(), song.name.lower()) delta = isrc_result[\"duration\"] - song.duration non_match_value = (delta**2) / song.duration * 100 time_match = 100 - non_match_value if ( isrc_result and isrc_result.get(\"link\") and name_match > 90 and time_match > 90 ): return isrc_result[\"link\"] search_query = create_song_title(song.name, song.artists).lower() # Query YTM by songs only first, this way if we get correct result on the first try # we don' t have to make another request song_results = self . get_results ( search_query , filter = \"songs\" ) if self . filter_results : # Order results songs = self . order_results ( song_results , song ) else : songs = {} if len ( song_results ) > 0 : songs = { song_results [ 0 ][ \"link\" ] : 100 } # song type results are always more accurate than video type , # so if we get score of 80 or above # we are almost 100 % sure that this is the correct link if len ( songs ) != 0 : # get the result with highest score best_result = max ( songs , key = lambda k : songs [ k ] ) if songs [ best_result ] >= 80 : return best_result # We didn ' t find the correct song on the first try so now we get video type results # add them to song_results , and get the result with highest score video_results = self . get_results ( search_query , filter = \"videos\" ) if self . filter_results : # Order video results videos = self . order_results ( video_results , song ) else : videos = {} if len ( video_results ) > 0 : videos = { video_results [ 0 ][ \"link\" ] : 100 } # Merge songs and video results results = { ** songs , ** videos } # No matches found if not results : return None result_items = list ( results . items ()) # Sort results by highest score sorted_results = sorted ( result_items , key = lambda x : x [ 1 ] , reverse = True ) # Get the result with highest score # and return the link return sorted_results [ 0 ][ 0 ]","title":"Returns"},{"location":"reference/spotdl/providers/lyrics/","text":"Module spotdl.providers.lyrics Lyrics providers for spotdl. None View Source \"\"\" Lyrics providers for spotdl. \"\"\" from spotdl.providers.lyrics.genius import Genius from spotdl.providers.lyrics.musixmatch import MusixMatch from spotdl.providers.lyrics.azlyrics import AzLyrics Sub-modules spotdl.providers.lyrics.azlyrics spotdl.providers.lyrics.base spotdl.providers.lyrics.genius spotdl.providers.lyrics.musixmatch","title":"Index"},{"location":"reference/spotdl/providers/lyrics/#module-spotdlproviderslyrics","text":"Lyrics providers for spotdl. None View Source \"\"\" Lyrics providers for spotdl. \"\"\" from spotdl.providers.lyrics.genius import Genius from spotdl.providers.lyrics.musixmatch import MusixMatch from spotdl.providers.lyrics.azlyrics import AzLyrics","title":"Module spotdl.providers.lyrics"},{"location":"reference/spotdl/providers/lyrics/#sub-modules","text":"spotdl.providers.lyrics.azlyrics spotdl.providers.lyrics.base spotdl.providers.lyrics.genius spotdl.providers.lyrics.musixmatch","title":"Sub-modules"},{"location":"reference/spotdl/providers/lyrics/azlyrics/","text":"Module spotdl.providers.lyrics.azlyrics AZLyrics lyrics module. None View Source \"\"\" AZLyrics lyrics module. \"\"\" from typing import List , Optional from bs4 import BeautifulSoup import requests from spotdl.providers.lyrics.base import LyricsProvider class AzLyrics ( LyricsProvider ): \"\"\" AZLyrics lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ) . lower () song_artists = artist_str . replace ( \" \" , \"+\" ) . lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q= { song_name } + { artists } \" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don't have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3 :] return lyrics Classes AzLyrics class AzLyrics ( ) View Source class AzLyrics ( LyricsProvider ) : \"\"\" AZLyrics lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ). lower () song_artists = artist_str . replace ( \" \" , \"+\" ). lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q={song_name}+{artists}\" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don ' t have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3: ] return lyrics Ancestors (in MRO) spotdl.providers.lyrics.base.LyricsProvider Instance variables name Returns the name of the lyrics provider. Methods get_lyrics def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ] Try to get lyrics from azlyrics Arguments name: The name of the song. artists: The artists of the song. Returns The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ). lower () song_artists = artist_str . replace ( \" \" , \"+\" ). lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q={song_name}+{artists}\" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don ' t have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3: ] return lyrics","title":"Azlyrics"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#module-spotdlproviderslyricsazlyrics","text":"AZLyrics lyrics module. None View Source \"\"\" AZLyrics lyrics module. \"\"\" from typing import List , Optional from bs4 import BeautifulSoup import requests from spotdl.providers.lyrics.base import LyricsProvider class AzLyrics ( LyricsProvider ): \"\"\" AZLyrics lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ) . lower () song_artists = artist_str . replace ( \" \" , \"+\" ) . lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q= { song_name } + { artists } \" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don't have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3 :] return lyrics","title":"Module spotdl.providers.lyrics.azlyrics"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#azlyrics","text":"class AzLyrics ( ) View Source class AzLyrics ( LyricsProvider ) : \"\"\" AZLyrics lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ). lower () song_artists = artist_str . replace ( \" \" , \"+\" ). lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q={song_name}+{artists}\" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don ' t have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3: ] return lyrics","title":"AzLyrics"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#ancestors-in-mro","text":"spotdl.providers.lyrics.base.LyricsProvider","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#instance-variables","text":"name Returns the name of the lyrics provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#get_lyrics","text":"def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ] Try to get lyrics from azlyrics","title":"get_lyrics"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#arguments","text":"name: The name of the song. artists: The artists of the song.","title":"Arguments"},{"location":"reference/spotdl/providers/lyrics/azlyrics/#returns","text":"The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from azlyrics ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" # Join every artist by comma in artists artist_str = \", \" . join ( artist for artist in artists if artist ) song_name = name . replace ( \" \" , \"+\" ). lower () song_artists = artist_str . replace ( \" \" , \"+\" ). lower () song_artists = song_artists . replace ( \",\" , \"%2C\" ) url = f \"https://search.azlyrics.com/search.php?q={song_name}+{artists}\" response = requests . get ( url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) td_tags = soup . find_all ( \"td\" ) if len ( td_tags ) == 0 : return None result = td_tags [ 0 ] a_tags = result . find_all ( \"a\" , href = True ) if len ( a_tags ) != 0 : lyrics_url = a_tags [ 0 ][ \"href\" ] else : return None if lyrics_url . strip () == \"\" : return None response = requests . get ( lyrics_url , headers = self . headers ) soup = BeautifulSoup ( response . content , \"html.parser\" ) # Find all divs that don ' t have a class div_tags = soup . find_all ( \"div\" , class_ = False , id_ = False ) lyrics = div_tags [ 1 ] . get_text () # Remove the 3 first new lines lyrics = lyrics [ 3: ] return lyrics","title":"Returns"},{"location":"reference/spotdl/providers/lyrics/base/","text":"Module spotdl.providers.lyrics.base Base module for all other lyrics providers. None View Source \"\"\" Base module for all other lyrics providers. \"\"\" from typing import List , Optional class LyricsProvider : \"\"\" Base class for all other lyrics providers. \"\"\" def __init__ ( self ): \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , } def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__ Classes LyricsProvider class LyricsProvider ( ) View Source class LyricsProvider : \"\"\" Base class for all other lyrics providers. \"\"\" def __init__ ( self ) : \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , } def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__ Descendants spotdl.providers.lyrics.genius.Genius spotdl.providers.lyrics.musixmatch.MusixMatch spotdl.providers.lyrics.azlyrics.AzLyrics Instance variables name Returns the name of the lyrics provider. Methods get_lyrics def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ] Returns the lyrics for the given song. Arguments name: The name of the song. artists: The artists of the song. kwargs: Additional arguments. Returns The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError","title":"Base"},{"location":"reference/spotdl/providers/lyrics/base/#module-spotdlproviderslyricsbase","text":"Base module for all other lyrics providers. None View Source \"\"\" Base module for all other lyrics providers. \"\"\" from typing import List , Optional class LyricsProvider : \"\"\" Base class for all other lyrics providers. \"\"\" def __init__ ( self ): \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , } def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__","title":"Module spotdl.providers.lyrics.base"},{"location":"reference/spotdl/providers/lyrics/base/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/lyrics/base/#lyricsprovider","text":"class LyricsProvider ( ) View Source class LyricsProvider : \"\"\" Base class for all other lyrics providers. \"\"\" def __init__ ( self ) : \"\"\" Init the lyrics provider searchand set headers. \"\"\" self . headers = { \"Connection\" : \"keep-alive\" , \"Pragma\" : \"no-cache\" , \"Cache-Control\" : \"no-cache\" , \"sec-ch-ua\" : '\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"' , \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) \" \"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36\" , \"Accept\" : \"*/*\" , \"Sec-Fetch-Site\" : \"same-origin\" , \"Sec-Fetch-Mode\" : \"cors\" , \"Sec-Fetch-Dest\" : \"empty\" , \"Accept-Language\" : \"en-US;q=0.8,en;q=0.7\" , } def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError @property def name ( self ) -> str : \"\"\" Returns the name of the lyrics provider. \"\"\" return self . __class__ . __name__","title":"LyricsProvider"},{"location":"reference/spotdl/providers/lyrics/base/#descendants","text":"spotdl.providers.lyrics.genius.Genius spotdl.providers.lyrics.musixmatch.MusixMatch spotdl.providers.lyrics.azlyrics.AzLyrics","title":"Descendants"},{"location":"reference/spotdl/providers/lyrics/base/#instance-variables","text":"name Returns the name of the lyrics provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/lyrics/base/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/lyrics/base/#get_lyrics","text":"def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ] Returns the lyrics for the given song.","title":"get_lyrics"},{"location":"reference/spotdl/providers/lyrics/base/#arguments","text":"name: The name of the song. artists: The artists of the song. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/spotdl/providers/lyrics/base/#returns","text":"The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Returns the lyrics for the given song. ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/providers/lyrics/genius/","text":"Module spotdl.providers.lyrics.genius Genius Lyrics module. None View Source \"\"\" Genius Lyrics module. \"\"\" from typing import List , Optional import requests from bs4 import BeautifulSoup from spotdl.providers.lyrics.base import LyricsProvider class Genius ( LyricsProvider ): \"\"\" Genius lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \" { name } { artist_str } \" }, headers = headers , ) song_id = search_response . json ()[ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/ { song_id } \" , headers = headers ) song_url = song_response . json ()[ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \" \\n \" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text () . strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \" \\n \" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None Classes Genius class Genius ( ) View Source class Genius ( LyricsProvider ) : \"\"\" Genius lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \"{name} {artist_str}\" } , headers = headers , ) song_id = search_response . json () [ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/{song_id}\" , headers = headers ) song_url = song_response . json () [ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \"\\n\" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text (). strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \"\\n\" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None Ancestors (in MRO) spotdl.providers.lyrics.base.LyricsProvider Instance variables name Returns the name of the lyrics provider. Methods get_lyrics def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ] Try to get lyrics from genius Arguments name: The name of the song. artists: The artists of the song. Returns The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \"{name} {artist_str}\" } , headers = headers , ) song_id = search_response . json () [ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/{song_id}\" , headers = headers ) song_url = song_response . json () [ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \"\\n\" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text (). strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \"\\n\" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"Genius"},{"location":"reference/spotdl/providers/lyrics/genius/#module-spotdlproviderslyricsgenius","text":"Genius Lyrics module. None View Source \"\"\" Genius Lyrics module. \"\"\" from typing import List , Optional import requests from bs4 import BeautifulSoup from spotdl.providers.lyrics.base import LyricsProvider class Genius ( LyricsProvider ): \"\"\" Genius lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ]: \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \" { name } { artist_str } \" }, headers = headers , ) song_id = search_response . json ()[ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/ { song_id } \" , headers = headers ) song_url = song_response . json ()[ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \" \\n \" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text () . strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \" \\n \" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"Module spotdl.providers.lyrics.genius"},{"location":"reference/spotdl/providers/lyrics/genius/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/lyrics/genius/#genius","text":"class Genius ( ) View Source class Genius ( LyricsProvider ) : \"\"\" Genius lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \"{name} {artist_str}\" } , headers = headers , ) song_id = search_response . json () [ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/{song_id}\" , headers = headers ) song_url = song_response . json () [ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \"\\n\" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text (). strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \"\\n\" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"Genius"},{"location":"reference/spotdl/providers/lyrics/genius/#ancestors-in-mro","text":"spotdl.providers.lyrics.base.LyricsProvider","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/lyrics/genius/#instance-variables","text":"name Returns the name of the lyrics provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/lyrics/genius/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/lyrics/genius/#get_lyrics","text":"def get_lyrics ( self , name : str , artists : List [ str ], ** _ ) -> Optional [ str ] Try to get lyrics from genius","title":"get_lyrics"},{"location":"reference/spotdl/providers/lyrics/genius/#arguments","text":"name: The name of the song. artists: The artists of the song.","title":"Arguments"},{"location":"reference/spotdl/providers/lyrics/genius/#returns","text":"The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** _ ) -> Optional [ str ] : \"\"\" Try to get lyrics from genius ### Arguments - name: The name of the song. - artists: The artists of the song. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : headers = { \"Authorization\" : \"Bearer \" \"alXXDbPZtK1m2RrZ8I4k2Hn8Ahsd0Gh_o076HYvcdlBvmc0ULL1H8Z8xRlew5qaG\" , } headers . update ( self . headers ) artist_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) search_response = requests . get ( \"https://api.genius.com/search\" , params = { \"q\" : f \"{name} {artist_str}\" } , headers = headers , ) song_id = search_response . json () [ \"response\" ][ \"hits\" ][ 0 ][ \"result\" ][ \"id\" ] song_response = requests . get ( f \"https://api.genius.com/songs/{song_id}\" , headers = headers ) song_url = song_response . json () [ \"response\" ][ \"song\" ][ \"url\" ] genius_page_response = requests . get ( song_url , headers = headers ) if not genius_page_response . ok : return None soup = BeautifulSoup ( genius_page_response . text . replace ( \"<br/>\" , \"\\n\" ), \"html.parser\" ) lyrics_div = soup . select_one ( \"div.lyrics\" ) if lyrics_div is not None : return lyrics_div . get_text (). strip () lyrics_containers = soup . select ( \"div[class^=Lyrics__Container]\" ) lyrics = \"\\n\" . join ( con . get_text () for con in lyrics_containers ) return lyrics . strip () except Exception : return None","title":"Returns"},{"location":"reference/spotdl/providers/lyrics/musixmatch/","text":"Module spotdl.providers.lyrics.musixmatch MusixMatch lyrics provider. None View Source \"\"\" MusixMatch lyrics provider. \"\"\" from typing import List , Optional from urllib.parse import quote import requests from bs4 import BeautifulSoup from spotdl.providers.lyrics.base import LyricsProvider class MusixMatch ( LyricsProvider ): \"\"\" MusixMatch lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote ( f \" { name } - { artists_str } \" , safe = \"\" ) # search the `tracks page` if track_search is True if track_search : query += \"/tracks\" search_url = f \"https://www.musixmatch.com/search/ { query } \" search_resp = requests . get ( search_url , headers = self . headers ) search_soup = BeautifulSoup ( search_resp . text , \"html.parser\" ) song_url_tag = search_soup . select_one ( \"a[href^='/lyrics/']\" ) # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None : # track_serach being True means we are already searching the tracks page. if track_search : return None lyrics = self . get_lyrics ( name , artists , track_search = True ) return lyrics song_url = \"https://www.musixmatch.com\" + str ( song_url_tag . get ( \"href\" , \"\" )) lyrics_resp = requests . get ( song_url , headers = self . headers ) lyrics_soup = BeautifulSoup ( lyrics_resp . text , \"html.parser\" ) lyrics_paragraphs = lyrics_soup . select ( \"p.mxm-lyrics__content\" ) lyrics = \" \\n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None Classes MusixMatch class MusixMatch ( ) View Source class MusixMatch ( LyricsProvider ) : \"\"\" MusixMatch lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it 's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote(f\"{name} - {artists_str}\", safe=\"\") # search the `tracks page` if track_search is True if track_search: query += \"/tracks\" search_url = f\"https://www.musixmatch.com/search/{query}\" search_resp = requests.get(search_url, headers=self.headers) search_soup = BeautifulSoup(search_resp.text, \"html.parser\") song_url_tag = search_soup.select_one(\"a[href^=' / lyrics / '] \") # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None: # track_serach being True means we are already searching the tracks page. if track_search: return None lyrics = self.get_lyrics(name, artists, track_search=True) return lyrics song_url = \" https : // www . musixmatch . com \" + str(song_url_tag.get(\" href \", \"\")) lyrics_resp = requests.get(song_url, headers=self.headers) lyrics_soup = BeautifulSoup(lyrics_resp.text, \" html . parser \") lyrics_paragraphs = lyrics_soup.select(\" p . mxm - lyrics__content \") lyrics = \" \\ n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None Ancestors (in MRO) spotdl.providers.lyrics.base.LyricsProvider Instance variables name Returns the name of the lyrics provider. Methods get_lyrics def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ] Try to get lyrics from musixmatch Arguments name: The name of the song. artists: The artists of the song. kwargs: Additional arguments. Returns The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it 's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote(f\"{name} - {artists_str}\", safe=\"\") # search the `tracks page` if track_search is True if track_search: query += \"/tracks\" search_url = f\"https://www.musixmatch.com/search/{query}\" search_resp = requests.get(search_url, headers=self.headers) search_soup = BeautifulSoup(search_resp.text, \"html.parser\") song_url_tag = search_soup.select_one(\"a[href^=' / lyrics / '] \") # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None: # track_serach being True means we are already searching the tracks page. if track_search: return None lyrics = self.get_lyrics(name, artists, track_search=True) return lyrics song_url = \" https : // www . musixmatch . com \" + str(song_url_tag.get(\" href \", \"\")) lyrics_resp = requests.get(song_url, headers=self.headers) lyrics_soup = BeautifulSoup(lyrics_resp.text, \" html . parser \") lyrics_paragraphs = lyrics_soup.select(\" p . mxm - lyrics__content \") lyrics = \" \\ n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"Musixmatch"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#module-spotdlproviderslyricsmusixmatch","text":"MusixMatch lyrics provider. None View Source \"\"\" MusixMatch lyrics provider. \"\"\" from typing import List , Optional from urllib.parse import quote import requests from bs4 import BeautifulSoup from spotdl.providers.lyrics.base import LyricsProvider class MusixMatch ( LyricsProvider ): \"\"\" MusixMatch lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ]: \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote ( f \" { name } - { artists_str } \" , safe = \"\" ) # search the `tracks page` if track_search is True if track_search : query += \"/tracks\" search_url = f \"https://www.musixmatch.com/search/ { query } \" search_resp = requests . get ( search_url , headers = self . headers ) search_soup = BeautifulSoup ( search_resp . text , \"html.parser\" ) song_url_tag = search_soup . select_one ( \"a[href^='/lyrics/']\" ) # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None : # track_serach being True means we are already searching the tracks page. if track_search : return None lyrics = self . get_lyrics ( name , artists , track_search = True ) return lyrics song_url = \"https://www.musixmatch.com\" + str ( song_url_tag . get ( \"href\" , \"\" )) lyrics_resp = requests . get ( song_url , headers = self . headers ) lyrics_soup = BeautifulSoup ( lyrics_resp . text , \"html.parser\" ) lyrics_paragraphs = lyrics_soup . select ( \"p.mxm-lyrics__content\" ) lyrics = \" \\n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"Module spotdl.providers.lyrics.musixmatch"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#musixmatch","text":"class MusixMatch ( ) View Source class MusixMatch ( LyricsProvider ) : \"\"\" MusixMatch lyrics provider class. \"\"\" def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it 's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote(f\"{name} - {artists_str}\", safe=\"\") # search the `tracks page` if track_search is True if track_search: query += \"/tracks\" search_url = f\"https://www.musixmatch.com/search/{query}\" search_resp = requests.get(search_url, headers=self.headers) search_soup = BeautifulSoup(search_resp.text, \"html.parser\") song_url_tag = search_soup.select_one(\"a[href^=' / lyrics / '] \") # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None: # track_serach being True means we are already searching the tracks page. if track_search: return None lyrics = self.get_lyrics(name, artists, track_search=True) return lyrics song_url = \" https : // www . musixmatch . com \" + str(song_url_tag.get(\" href \", \"\")) lyrics_resp = requests.get(song_url, headers=self.headers) lyrics_soup = BeautifulSoup(lyrics_resp.text, \" html . parser \") lyrics_paragraphs = lyrics_soup.select(\" p . mxm - lyrics__content \") lyrics = \" \\ n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"MusixMatch"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#ancestors-in-mro","text":"spotdl.providers.lyrics.base.LyricsProvider","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#instance-variables","text":"name Returns the name of the lyrics provider.","title":"Instance variables"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#get_lyrics","text":"def get_lyrics ( self , name : str , artists : List [ str ], ** kwargs ) -> Optional [ str ] Try to get lyrics from musixmatch","title":"get_lyrics"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#arguments","text":"name: The name of the song. artists: The artists of the song. kwargs: Additional arguments.","title":"Arguments"},{"location":"reference/spotdl/providers/lyrics/musixmatch/#returns","text":"The lyrics of the song or None if no lyrics were found. View Source def get_lyrics ( self , name : str , artists : List [ str ] , ** kwargs ) -> Optional [ str ] : \"\"\" Try to get lyrics from musixmatch ### Arguments - name: The name of the song. - artists: The artists of the song. - kwargs: Additional arguments. ### Returns - The lyrics of the song or None if no lyrics were found. \"\"\" try : track_search = kwargs . get ( \"track_search\" , False ) artists_str = \", \" . join ( artist for artist in artists if artist . lower () not in name . lower () ) # quote the query so that it 's safe to use in a url # e.g \"Au/Ra\" -> \"Au%2FRa\" query = quote(f\"{name} - {artists_str}\", safe=\"\") # search the `tracks page` if track_search is True if track_search: query += \"/tracks\" search_url = f\"https://www.musixmatch.com/search/{query}\" search_resp = requests.get(search_url, headers=self.headers) search_soup = BeautifulSoup(search_resp.text, \"html.parser\") song_url_tag = search_soup.select_one(\"a[href^=' / lyrics / '] \") # song_url_tag being None means no results were found on the # All Results page, therefore, we use `track_search` to # search the tracks page. if song_url_tag is None: # track_serach being True means we are already searching the tracks page. if track_search: return None lyrics = self.get_lyrics(name, artists, track_search=True) return lyrics song_url = \" https : // www . musixmatch . com \" + str(song_url_tag.get(\" href \", \"\")) lyrics_resp = requests.get(song_url, headers=self.headers) lyrics_soup = BeautifulSoup(lyrics_resp.text, \" html . parser \") lyrics_paragraphs = lyrics_soup.select(\" p . mxm - lyrics__content \") lyrics = \" \\ n \" . join ( i . get_text () for i in lyrics_paragraphs ) return lyrics except Exception : return None","title":"Returns"},{"location":"reference/spotdl/types/","text":"Module spotdl.types Types for the spotdl package. None View Source \"\"\" Types for the spotdl package. \"\"\" from spotdl.types.song import Song from spotdl.types.playlist import Playlist from spotdl.types.album import Album from spotdl.types.artist import Artist from spotdl.types.saved import Saved Sub-modules spotdl.types.album spotdl.types.artist spotdl.types.playlist spotdl.types.saved spotdl.types.song","title":"Index"},{"location":"reference/spotdl/types/#module-spotdltypes","text":"Types for the spotdl package. None View Source \"\"\" Types for the spotdl package. \"\"\" from spotdl.types.song import Song from spotdl.types.playlist import Playlist from spotdl.types.album import Album from spotdl.types.artist import Artist from spotdl.types.saved import Saved","title":"Module spotdl.types"},{"location":"reference/spotdl/types/#sub-modules","text":"spotdl.types.album spotdl.types.artist spotdl.types.playlist spotdl.types.saved spotdl.types.song","title":"Sub-modules"},{"location":"reference/spotdl/types/album/","text":"Module spotdl.types.album Artist module for retrieving artist data from Spotify. None View Source \"\"\" Artist module for retrieving artist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.utils.spotify import SpotifyClient from spotdl.types.song import Song class AlbumError ( Exception ): \"\"\" Base class for all exceptions related to albums. \"\"\" @dataclass ( frozen = True ) class Album ( SongList ): \"\"\" Album class for retrieving album data from Spotify. \"\"\" artist : Dict [ str , Any ] @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track songs : List [ Song ] = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ]: album_response = spotify_client . next ( album_response ) # Failed to get response, break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ]) if album_response is None : raise AlbumError ( f \"Failed to get album response: { url } \" ) return [ track [ \"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ], \"artist\" : album_metadata [ \"artists\" ][ 0 ], \"url\" : url , } Classes Album class Album ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], artist : Dict [ str , Any ] ) View Source @dataclass ( frozen = True ) class Album ( SongList ) : \"\"\" Album class for retrieving album data from Spotify. \"\"\" artist : Dict [ str, Any ] @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track songs : List [ Song ] = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ] : album_response = spotify_client . next ( album_response ) # Failed to get response , break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ] ) if album_response is None : raise AlbumError ( f \"Failed to get album response: {url}\" ) return [ track[\"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ] , \"artist\" : album_metadata [ \"artists\" ][ 0 ] , \"url\" : url , } Ancestors (in MRO) spotdl.types.song.SongList Static methods create_basic_list def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls. Arguments url: The url of the list. Returns The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) from_url def from_url ( url : str ) -> 'Album' Parse an album from a Spotify URL. Arguments url: The URL of the album. Returns The Album object. View Source @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track songs : List [ Song ] = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) get_metadata def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for album. Arguments url: The URL of the album. Returns A dictionary with metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ] , \"artist\" : album_metadata [ \"artists\" ][ 0 ] , \"url\" : url , } get_urls def get_urls ( url : str ) -> List [ str ] Get urls for all songs in album. Arguments url: The URL of the album. Returns A list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ] : album_response = spotify_client . next ( album_response ) # Failed to get response , break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ] ) if album_response is None : raise AlbumError ( f \"Failed to get album response: {url}\" ) return [ track[\"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] Instance variables length Get list length (number of songs). Returns The list length. AlbumError class AlbumError ( / , * args , ** kwargs ) View Source class AlbumError ( Exception ): \"\"\" Base class for all exceptions related to albums. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Album"},{"location":"reference/spotdl/types/album/#module-spotdltypesalbum","text":"Artist module for retrieving artist data from Spotify. None View Source \"\"\" Artist module for retrieving artist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.utils.spotify import SpotifyClient from spotdl.types.song import Song class AlbumError ( Exception ): \"\"\" Base class for all exceptions related to albums. \"\"\" @dataclass ( frozen = True ) class Album ( SongList ): \"\"\" Album class for retrieving album data from Spotify. \"\"\" artist : Dict [ str , Any ] @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track songs : List [ Song ] = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ]: album_response = spotify_client . next ( album_response ) # Failed to get response, break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ]) if album_response is None : raise AlbumError ( f \"Failed to get album response: { url } \" ) return [ track [ \"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ], \"artist\" : album_metadata [ \"artists\" ][ 0 ], \"url\" : url , }","title":"Module spotdl.types.album"},{"location":"reference/spotdl/types/album/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/types/album/#album","text":"class Album ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], artist : Dict [ str , Any ] ) View Source @dataclass ( frozen = True ) class Album ( SongList ) : \"\"\" Album class for retrieving album data from Spotify. \"\"\" artist : Dict [ str, Any ] @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track songs : List [ Song ] = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ] : album_response = spotify_client . next ( album_response ) # Failed to get response , break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ] ) if album_response is None : raise AlbumError ( f \"Failed to get album response: {url}\" ) return [ track[\"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ] , \"artist\" : album_metadata [ \"artists\" ][ 0 ] , \"url\" : url , }","title":"Album"},{"location":"reference/spotdl/types/album/#ancestors-in-mro","text":"spotdl.types.song.SongList","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/album/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/types/album/#create_basic_list","text":"def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls.","title":"create_basic_list"},{"location":"reference/spotdl/types/album/#arguments","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/spotdl/types/album/#returns","text":"The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] )","title":"Returns"},{"location":"reference/spotdl/types/album/#from_url","text":"def from_url ( url : str ) -> 'Album' Parse an album from a Spotify URL.","title":"from_url"},{"location":"reference/spotdl/types/album/#arguments_1","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/spotdl/types/album/#returns_1","text":"The Album object. View Source @classmethod def from_url ( cls , url : str ) -> \"Album\" : \"\"\" Parse an album from a Spotify URL. ### Arguments - url: The URL of the album. ### Returns - The Album object. \"\"\" metadata = Album . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track songs : List [ Song ] = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = songs , urls = urls , )","title":"Returns"},{"location":"reference/spotdl/types/album/#get_metadata","text":"def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for album.","title":"get_metadata"},{"location":"reference/spotdl/types/album/#arguments_2","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/spotdl/types/album/#returns_2","text":"A dictionary with metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for album. ### Arguments - url: The URL of the album. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () album_metadata = spotify_client . album ( url ) if album_metadata is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) return { \"name\" : album_metadata [ \"name\" ] , \"artist\" : album_metadata [ \"artists\" ][ 0 ] , \"url\" : url , }","title":"Returns"},{"location":"reference/spotdl/types/album/#get_urls","text":"def get_urls ( url : str ) -> List [ str ] Get urls for all songs in album.","title":"get_urls"},{"location":"reference/spotdl/types/album/#arguments_3","text":"url: The URL of the album.","title":"Arguments"},{"location":"reference/spotdl/types/album/#returns_3","text":"A list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in album. ### Arguments - url: The URL of the album. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () album_response = spotify_client . album_tracks ( url ) if album_response is None : raise AlbumError ( \"Couldn't get metadata, check if you have passed correct album id\" ) tracks = album_response [ \"items\" ] # Get all tracks from album while album_response [ \"next\" ] : album_response = spotify_client . next ( album_response ) # Failed to get response , break the loop if album_response is None : break tracks . extend ( album_response [ \"items\" ] ) if album_response is None : raise AlbumError ( f \"Failed to get album response: {url}\" ) return [ track[\"external_urls\" ][ \"spotify\" ] for track in tracks if track and track . get ( \"id\" ) ]","title":"Returns"},{"location":"reference/spotdl/types/album/#instance-variables","text":"length Get list length (number of songs).","title":"Instance variables"},{"location":"reference/spotdl/types/album/#returns_4","text":"The list length.","title":"Returns"},{"location":"reference/spotdl/types/album/#albumerror","text":"class AlbumError ( / , * args , ** kwargs ) View Source class AlbumError ( Exception ): \"\"\" Base class for all exceptions related to albums. \"\"\"","title":"AlbumError"},{"location":"reference/spotdl/types/album/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/album/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/types/album/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/types/album/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/types/artist/","text":"Module spotdl.types.artist Artist module for retrieving artist data from Spotify. None View Source \"\"\" Artist module for retrieving artist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List , Set from slugify import slugify from spotdl.types.song import SongList from spotdl.types.song import Song from spotdl.types.album import Album from spotdl.utils.spotify import SpotifyClient class ArtistError ( Exception ): \"\"\" Base class for all exceptions related to artists. \"\"\" @dataclass ( frozen = True ) class Artist ( SongList ): \"\"\" Artist class. Contains all the information about an artist. Frozen to prevent accidental modification. \"\"\" genres : List [ str ] albums : List [ Album ] @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: { url } \" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above, but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type: ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [], albums = []) @staticmethod def get_albums ( url : str ) -> List [ str ]: \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ]: albums . append ( album [ \"external_urls\" ][ \"spotify\" ]) known_albums . add ( slugify ( album [ \"name\" ])) # type: ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ]: artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ]: album_name = slugify ( album [ \"name\" ]) # type: ignore if album_name in known_albums : albums . extend ([ item [ \"uri\" ] for item in artist_albums [ \"items\" ]]) known_albums . add ( album_name ) return albums @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ], \"genres\" : raw_artist_meta [ \"genres\" ], \"url\" : url , } Classes Artist class Artist ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], genres : List [ str ], albums : List [ spotdl . types . album . Album ] ) View Source @dataclass ( frozen = True ) class Artist ( SongList ) : \"\"\" Artist class. Contains all the information about an artist. Frozen to prevent accidental modification. \"\"\" genres : List [ str ] albums : List [ Album ] @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: {url}\" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above , but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type : ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] , albums = [] ) @staticmethod def get_albums ( url : str ) -> List [ str ] : \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ] : albums . append ( album [ \"external_urls\" ][ \"spotify\" ] ) known_albums . add ( slugify ( album [ \"name\" ] )) # type : ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ] : artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ] : album_name = slugify ( album [ \"name\" ] ) # type : ignore if album_name in known_albums : albums . extend ( [ item[\"uri\" ] for item in artist_albums [ \"items\" ] ] ) known_albums . add ( album_name ) return albums @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ] , \"genres\" : raw_artist_meta [ \"genres\" ] , \"url\" : url , } Ancestors (in MRO) spotdl.types.song.SongList Static methods create_basic_list def create_basic_list ( url : str ) -> 'Artist' Create a basic list with only the required metadata and urls. Arguments url: The url of the list. Returns The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] , albums = [] ) from_url def from_url ( url : str ) -> 'Artist' Creates an Artist object from a URL. Arguments url: The URL of the artist. Returns The Artist object. View Source @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: {url}\" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above , but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type : ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) get_albums def get_albums ( url : str ) -> List [ str ] Returns a list with album urls. Arguments url: The URL of the artist. Returns List of album urls. View Source @staticmethod def get_albums ( url : str ) -> List [ str ] : \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ] : albums . append ( album [ \"external_urls\" ][ \"spotify\" ] ) known_albums . add ( slugify ( album [ \"name\" ] )) # type : ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ] : artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ] : album_name = slugify ( album [ \"name\" ] ) # type : ignore if album_name in known_albums : albums . extend ( [ item[\"uri\" ] for item in artist_albums [ \"items\" ] ] ) known_albums . add ( album_name ) return albums get_metadata def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for artist. Arguments url: The URL of the artist. Returns Dict with metadata for artist. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ] , \"genres\" : raw_artist_meta [ \"genres\" ] , \"url\" : url , } get_urls def get_urls ( url : str ) -> List [ str ] Get urls for all songs for artist. Arguments url: The URL of the artist. Returns List of urls for all songs for artist. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls Instance variables length Get list length (number of songs). Returns The list length. ArtistError class ArtistError ( / , * args , ** kwargs ) View Source class ArtistError ( Exception ): \"\"\" Base class for all exceptions related to artists. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Artist"},{"location":"reference/spotdl/types/artist/#module-spotdltypesartist","text":"Artist module for retrieving artist data from Spotify. None View Source \"\"\" Artist module for retrieving artist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List , Set from slugify import slugify from spotdl.types.song import SongList from spotdl.types.song import Song from spotdl.types.album import Album from spotdl.utils.spotify import SpotifyClient class ArtistError ( Exception ): \"\"\" Base class for all exceptions related to artists. \"\"\" @dataclass ( frozen = True ) class Artist ( SongList ): \"\"\" Artist class. Contains all the information about an artist. Frozen to prevent accidental modification. \"\"\" genres : List [ str ] albums : List [ Album ] @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: { url } \" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above, but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type: ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [], albums = []) @staticmethod def get_albums ( url : str ) -> List [ str ]: \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ]: albums . append ( album [ \"external_urls\" ][ \"spotify\" ]) known_albums . add ( slugify ( album [ \"name\" ])) # type: ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ]: artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ]: album_name = slugify ( album [ \"name\" ]) # type: ignore if album_name in known_albums : albums . extend ([ item [ \"uri\" ] for item in artist_albums [ \"items\" ]]) known_albums . add ( album_name ) return albums @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ], \"genres\" : raw_artist_meta [ \"genres\" ], \"url\" : url , }","title":"Module spotdl.types.artist"},{"location":"reference/spotdl/types/artist/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/types/artist/#artist","text":"class Artist ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], genres : List [ str ], albums : List [ spotdl . types . album . Album ] ) View Source @dataclass ( frozen = True ) class Artist ( SongList ) : \"\"\" Artist class. Contains all the information about an artist. Frozen to prevent accidental modification. \"\"\" genres : List [ str ] albums : List [ Album ] @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: {url}\" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above , but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type : ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] , albums = [] ) @staticmethod def get_albums ( url : str ) -> List [ str ] : \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ] : albums . append ( album [ \"external_urls\" ][ \"spotify\" ] ) known_albums . add ( slugify ( album [ \"name\" ] )) # type : ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ] : artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ] : album_name = slugify ( album [ \"name\" ] ) # type : ignore if album_name in known_albums : albums . extend ( [ item[\"uri\" ] for item in artist_albums [ \"items\" ] ] ) known_albums . add ( album_name ) return albums @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ] , \"genres\" : raw_artist_meta [ \"genres\" ] , \"url\" : url , }","title":"Artist"},{"location":"reference/spotdl/types/artist/#ancestors-in-mro","text":"spotdl.types.song.SongList","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/artist/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/types/artist/#create_basic_list","text":"def create_basic_list ( url : str ) -> 'Artist' Create a basic list with only the required metadata and urls.","title":"create_basic_list"},{"location":"reference/spotdl/types/artist/#arguments","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/spotdl/types/artist/#returns","text":"The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) -> \"Artist\" : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = Artist . get_metadata ( url ) urls = Artist . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] , albums = [] )","title":"Returns"},{"location":"reference/spotdl/types/artist/#from_url","text":"def from_url ( url : str ) -> 'Artist' Creates an Artist object from a URL.","title":"from_url"},{"location":"reference/spotdl/types/artist/#arguments_1","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/spotdl/types/artist/#returns_1","text":"The Artist object. View Source @classmethod def from_url ( cls , url : str ) -> \"Artist\" : \"\"\" Creates an Artist object from a URL. ### Arguments - url: The URL of the artist. ### Returns - The Artist object. \"\"\" if \"open.spotify.com\" not in url or \"artist\" not in url : raise ArtistError ( f \"Invalid URL: {url}\" ) metadata = Artist . get_metadata ( url ) album_urls = cls . get_albums ( url ) tracks : List [ Song ] = [] albums : List [ Album ] = [] # get artist tracks # same as above , but for tracks known_tracks : Set [ str ] = set () if len ( album_urls ) < 1 : raise ArtistError ( \"Couldn't get albums, check if you have passed correct artist id\" ) # get all tracks from all albums # ignore duplicates urls = [] for album_url in album_urls : album = Album . from_url ( album_url ) albums . append ( album ) for track in album . songs : track_name = slugify ( track . name ) # type : ignore if track_name not in known_tracks : tracks . append ( track ) urls . append ( track . url ) known_tracks . add ( track_name ) return cls ( ** metadata , songs = tracks , albums = albums , urls = urls , )","title":"Returns"},{"location":"reference/spotdl/types/artist/#get_albums","text":"def get_albums ( url : str ) -> List [ str ] Returns a list with album urls.","title":"get_albums"},{"location":"reference/spotdl/types/artist/#arguments_2","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/spotdl/types/artist/#returns_2","text":"List of album urls. View Source @staticmethod def get_albums ( url : str ) -> List [ str ] : \"\"\" Returns a list with album urls. ### Arguments - url: The URL of the artist. ### Returns - List of album urls. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () artist_albums = spotify_client . artist_albums ( url , album_type = \"album,single\" ) albums : List [ str ] = [] # get artist albums and remove duplicates # duplicates can occur if the artist has the same album available in # different countries known_albums : Set [ str ] = set () if artist_albums is not None : for album in artist_albums [ \"items\" ] : albums . append ( album [ \"external_urls\" ][ \"spotify\" ] ) known_albums . add ( slugify ( album [ \"name\" ] )) # type : ignore # Fetch all artist albums while artist_albums and artist_albums [ \"next\" ] : artist_albums = spotify_client . next ( artist_albums ) if artist_albums is None : break for album in artist_albums [ \"items\" ] : album_name = slugify ( album [ \"name\" ] ) # type : ignore if album_name in known_albums : albums . extend ( [ item[\"uri\" ] for item in artist_albums [ \"items\" ] ] ) known_albums . add ( album_name ) return albums","title":"Returns"},{"location":"reference/spotdl/types/artist/#get_metadata","text":"def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for artist.","title":"get_metadata"},{"location":"reference/spotdl/types/artist/#arguments_3","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/spotdl/types/artist/#returns_3","text":"Dict with metadata for artist. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for artist. ### Arguments - url: The URL of the artist. ### Returns - Dict with metadata for artist. \"\"\" # query spotify for artist details spotify_client = SpotifyClient () # get artist info raw_artist_meta = spotify_client . artist ( url ) if raw_artist_meta is None : raise ArtistError ( \"Couldn't get metadata, check if you have passed correct artist id\" ) return { \"name\" : raw_artist_meta [ \"name\" ] , \"genres\" : raw_artist_meta [ \"genres\" ] , \"url\" : url , }","title":"Returns"},{"location":"reference/spotdl/types/artist/#get_urls","text":"def get_urls ( url : str ) -> List [ str ] Get urls for all songs for artist.","title":"get_urls"},{"location":"reference/spotdl/types/artist/#arguments_4","text":"url: The URL of the artist.","title":"Arguments"},{"location":"reference/spotdl/types/artist/#returns_4","text":"List of urls for all songs for artist. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs for artist. ### Arguments - url: The URL of the artist. ### Returns - List of urls for all songs for artist. \"\"\" albums = Artist . get_albums ( url ) urls = [] for album in albums : urls . extend ( Album . get_urls ( album )) return urls","title":"Returns"},{"location":"reference/spotdl/types/artist/#instance-variables","text":"length Get list length (number of songs).","title":"Instance variables"},{"location":"reference/spotdl/types/artist/#returns_5","text":"The list length.","title":"Returns"},{"location":"reference/spotdl/types/artist/#artisterror","text":"class ArtistError ( / , * args , ** kwargs ) View Source class ArtistError ( Exception ): \"\"\" Base class for all exceptions related to artists. \"\"\"","title":"ArtistError"},{"location":"reference/spotdl/types/artist/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/artist/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/types/artist/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/types/artist/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/types/playlist/","text":"Module spotdl.types.playlist Playlist module for retrieving playlist data from Spotify. None View Source \"\"\" Playlist module for retrieving playlist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.utils.spotify import SpotifyClient from spotdl.types.song import Song class PlaylistError ( Exception ): \"\"\" Base class for all exceptions related to playlists. \"\"\" @dataclass ( frozen = True ) class Playlist ( SongList ): \"\"\" Playlist class for retrieving playlist data from Spotify. \"\"\" description : str author_url : str author_name : str @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: { url } \" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ]: playlist_response = spotify_client . next ( playlist_response ) # Failed to get response, break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ]) return [ track [ \"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ) . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ], \"url\" : url , \"description\" : playlist [ \"description\" ], \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ], \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ], } Classes Playlist class Playlist ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], description : str , author_url : str , author_name : str ) View Source @dataclass ( frozen = True ) class Playlist ( SongList ) : \"\"\" Playlist class for retrieving playlist data from Spotify. \"\"\" description : str author_url : str author_name : str @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: {url}\" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ] : playlist_response = spotify_client . next ( playlist_response ) # Failed to get response , break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ] ) return [ track[\"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ). get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ] , \"url\" : url , \"description\" : playlist [ \"description\" ] , \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ] , \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ] , } Ancestors (in MRO) spotdl.types.song.SongList Static methods create_basic_list def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls. Arguments url: The url of the list. Returns The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) from_url def from_url ( url : str ) -> 'Playlist' Load playlist info and tracks from a Spotify playlist URL. Arguments url: The URL of the playlist. Returns The Playlist object. View Source @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) get_metadata def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for a playlist. Arguments url: The URL of the playlist. Returns A dictionary with metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ] , \"url\" : url , \"description\" : playlist [ \"description\" ] , \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ] , \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ] , } get_urls def get_urls ( url : str ) -> List [ str ] Get URLs of all tracks in a playlist. Arguments url: The URL of the playlist. Returns A list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: {url}\" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ] : playlist_response = spotify_client . next ( playlist_response ) # Failed to get response , break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ] ) return [ track[\"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ). get ( \"id\" ) ] Instance variables length Get list length (number of songs). Returns The list length. PlaylistError class PlaylistError ( / , * args , ** kwargs ) View Source class PlaylistError ( Exception ): \"\"\" Base class for all exceptions related to playlists. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Playlist"},{"location":"reference/spotdl/types/playlist/#module-spotdltypesplaylist","text":"Playlist module for retrieving playlist data from Spotify. None View Source \"\"\" Playlist module for retrieving playlist data from Spotify. \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.utils.spotify import SpotifyClient from spotdl.types.song import Song class PlaylistError ( Exception ): \"\"\" Base class for all exceptions related to playlists. \"\"\" @dataclass ( frozen = True ) class Playlist ( SongList ): \"\"\" Playlist class for retrieving playlist data from Spotify. \"\"\" description : str author_url : str author_name : str @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id (country restricted/local tracks) # And create song object for each track tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: { url } \" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ]: playlist_response = spotify_client . next ( playlist_response ) # Failed to get response, break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ]) return [ track [ \"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ) . get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ], \"url\" : url , \"description\" : playlist [ \"description\" ], \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ], \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ], }","title":"Module spotdl.types.playlist"},{"location":"reference/spotdl/types/playlist/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/types/playlist/#playlist","text":"class Playlist ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ], description : str , author_url : str , author_name : str ) View Source @dataclass ( frozen = True ) class Playlist ( SongList ) : \"\"\" Playlist class for retrieving playlist data from Spotify. \"\"\" description : str author_url : str author_name : str @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: {url}\" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ] : playlist_response = spotify_client . next ( playlist_response ) # Failed to get response , break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ] ) return [ track[\"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ). get ( \"id\" ) ] @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ] , \"url\" : url , \"description\" : playlist [ \"description\" ] , \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ] , \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ] , }","title":"Playlist"},{"location":"reference/spotdl/types/playlist/#ancestors-in-mro","text":"spotdl.types.song.SongList","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/playlist/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/types/playlist/#create_basic_list","text":"def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls.","title":"create_basic_list"},{"location":"reference/spotdl/types/playlist/#arguments","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/spotdl/types/playlist/#returns","text":"The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] )","title":"Returns"},{"location":"reference/spotdl/types/playlist/#from_url","text":"def from_url ( url : str ) -> 'Playlist' Load playlist info and tracks from a Spotify playlist URL.","title":"from_url"},{"location":"reference/spotdl/types/playlist/#arguments_1","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/spotdl/types/playlist/#returns_1","text":"The Playlist object. View Source @classmethod def from_url ( cls , url : str ) -> \"Playlist\" : \"\"\" Load playlist info and tracks from a Spotify playlist URL. ### Arguments - url: The URL of the playlist. ### Returns - The Playlist object. \"\"\" metadata = Playlist . get_metadata ( url ) # Get urls urls = cls . get_urls ( url ) # Remove songs without id ( country restricted / local tracks ) # And create song object for each track tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , )","title":"Returns"},{"location":"reference/spotdl/types/playlist/#get_metadata","text":"def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for a playlist.","title":"get_metadata"},{"location":"reference/spotdl/types/playlist/#arguments_2","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/spotdl/types/playlist/#returns_2","text":"A dictionary with metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A dictionary with metadata. \"\"\" spotify_client = SpotifyClient () playlist = spotify_client . playlist ( url ) if playlist is None : raise PlaylistError ( \"Invalid playlist URL.\" ) return { \"name\" : playlist [ \"name\" ] , \"url\" : url , \"description\" : playlist [ \"description\" ] , \"author_url\" : playlist [ \"external_urls\" ][ \"spotify\" ] , \"author_name\" : playlist [ \"owner\" ][ \"display_name\" ] , }","title":"Returns"},{"location":"reference/spotdl/types/playlist/#get_urls","text":"def get_urls ( url : str ) -> List [ str ] Get URLs of all tracks in a playlist.","title":"get_urls"},{"location":"reference/spotdl/types/playlist/#arguments_3","text":"url: The URL of the playlist.","title":"Arguments"},{"location":"reference/spotdl/types/playlist/#returns_3","text":"A list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get URLs of all tracks in a playlist. ### Arguments - url: The URL of the playlist. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () tracks = [] playlist_response = spotify_client . playlist_items ( url ) if playlist_response is None : raise PlaylistError ( f \"Wrong playlist id: {url}\" ) tracks = playlist_response [ \"items\" ] # Get all tracks from playlist while playlist_response [ \"next\" ] : playlist_response = spotify_client . next ( playlist_response ) # Failed to get response , break the loop if playlist_response is None : break # Add tracks to the list tracks . extend ( playlist_response [ \"items\" ] ) return [ track[\"track\" ][ \"external_urls\" ][ \"spotify\" ] for track in tracks if track is not None and track . get ( \"track\" ) is not None and track . get ( \"track\" ). get ( \"id\" ) ]","title":"Returns"},{"location":"reference/spotdl/types/playlist/#instance-variables","text":"length Get list length (number of songs).","title":"Instance variables"},{"location":"reference/spotdl/types/playlist/#returns_4","text":"The list length.","title":"Returns"},{"location":"reference/spotdl/types/playlist/#playlisterror","text":"class PlaylistError ( / , * args , ** kwargs ) View Source class PlaylistError ( Exception ): \"\"\" Base class for all exceptions related to playlists. \"\"\"","title":"PlaylistError"},{"location":"reference/spotdl/types/playlist/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/playlist/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/types/playlist/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/types/playlist/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/types/saved/","text":"Module spotdl.types.saved Saved module for handing the saved tracks from user library None View Source \"\"\" Saved module for handing the saved tracks from user library \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.types.song import Song from spotdl.utils.spotify import SpotifyClient class SavedError ( Exception ): \"\"\" Base class for all exceptions related to saved tracks. \"\"\" @dataclass ( frozen = True ) class Saved ( SongList ): \"\"\" Saved class for handling the saved tracks from user library. \"\"\" @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ]: \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type: ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ]: response = spotify_client . next ( saved_tracks_response ) # response is wrong, break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ]) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track [ \"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {}) . get ( \"id\" ) ] @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str , Any ]: \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url } Classes Saved class Saved ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ] ) View Source @dataclass ( frozen = True ) class Saved ( SongList ) : \"\"\" Saved class for handling the saved tracks from user library. \"\"\" @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ] : \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type : ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ] : response = spotify_client . next ( saved_tracks_response ) # response is wrong , break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ] ) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track[\"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {} ). get ( \"id\" ) ] @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str, Any ] : \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url } Ancestors (in MRO) spotdl.types.song.SongList Static methods create_basic_list def create_basic_list ( url : str = 'saved' ) -> 'Saved' Create a basic list with only the required metadata and urls. Returns The Saved object. View Source @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) from_url def from_url ( url : str = 'saved' ) -> 'Saved' Loads saved tracks from Spotify. Will throw an exception if users is not logged in. View Source @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) get_metadata def get_metadata ( url : str = 'saved' ) -> Dict [ str , Any ] Returns metadata for a saved list. Arguments url: Not required, but used to match the signature of the other get_metadata methods. View Source @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str, Any ] : \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url } get_urls def get_urls ( _ : str = 'saved' ) -> List [ str ] Returns a list of urls of all saved tracks. Arguments _: not required, but used to match the signature of the other get_urls methods. Returns A list of urls. View Source @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ] : \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type : ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ] : response = spotify_client . next ( saved_tracks_response ) # response is wrong , break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ] ) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track[\"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {} ). get ( \"id\" ) ] Instance variables length Get list length (number of songs). Returns The list length. SavedError class SavedError ( / , * args , ** kwargs ) View Source class SavedError ( Exception ): \"\"\" Base class for all exceptions related to saved tracks. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Saved"},{"location":"reference/spotdl/types/saved/#module-spotdltypessaved","text":"Saved module for handing the saved tracks from user library None View Source \"\"\" Saved module for handing the saved tracks from user library \"\"\" from dataclasses import dataclass from typing import Any , Dict , List from spotdl.types.song import SongList from spotdl.types.song import Song from spotdl.utils.spotify import SpotifyClient class SavedError ( Exception ): \"\"\" Base class for all exceptions related to saved tracks. \"\"\" @dataclass ( frozen = True ) class Saved ( SongList ): \"\"\" Saved class for handling the saved tracks from user library. \"\"\" @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song . from_url ( url ) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ]: \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type: ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ]: response = spotify_client . next ( saved_tracks_response ) # response is wrong, break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ]) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track [ \"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {}) . get ( \"id\" ) ] @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str , Any ]: \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url }","title":"Module spotdl.types.saved"},{"location":"reference/spotdl/types/saved/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/types/saved/#saved","text":"class Saved ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ] ) View Source @dataclass ( frozen = True ) class Saved ( SongList ) : \"\"\" Saved class for handling the saved tracks from user library. \"\"\" @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , ) @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ] : \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type : ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ] : response = spotify_client . next ( saved_tracks_response ) # response is wrong , break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ] ) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track[\"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {} ). get ( \"id\" ) ] @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str, Any ] : \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url }","title":"Saved"},{"location":"reference/spotdl/types/saved/#ancestors-in-mro","text":"spotdl.types.song.SongList","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/saved/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/types/saved/#create_basic_list","text":"def create_basic_list ( url : str = 'saved' ) -> 'Saved' Create a basic list with only the required metadata and urls.","title":"create_basic_list"},{"location":"reference/spotdl/types/saved/#returns","text":"The Saved object. View Source @classmethod def create_basic_list ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Create a basic list with only the required metadata and urls. ### Returns - The Saved object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] )","title":"Returns"},{"location":"reference/spotdl/types/saved/#from_url","text":"def from_url ( url : str = 'saved' ) -> 'Saved' Loads saved tracks from Spotify. Will throw an exception if users is not logged in. View Source @classmethod def from_url ( cls , url : str = \"saved\" ) -> \"Saved\" : \"\"\" Loads saved tracks from Spotify. Will throw an exception if users is not logged in. \"\"\" metadata = Saved . get_metadata ( url ) urls = cls . get_urls ( url ) # Remove songs without id # and create Song objects tracks = [ Song.from_url(url) for url in urls ] return cls ( ** metadata , songs = tracks , urls = urls , )","title":"from_url"},{"location":"reference/spotdl/types/saved/#get_metadata","text":"def get_metadata ( url : str = 'saved' ) -> Dict [ str , Any ] Returns metadata for a saved list.","title":"get_metadata"},{"location":"reference/spotdl/types/saved/#arguments","text":"url: Not required, but used to match the signature of the other get_metadata methods. View Source @staticmethod def get_metadata ( url : str = \"saved\" ) -> Dict [ str, Any ] : \"\"\" Returns metadata for a saved list. ### Arguments - url: Not required, but used to match the signature of the other get_metadata methods. \"\"\" return { \"name\" : \"Saved tracks\" , \"url\" : url }","title":"Arguments"},{"location":"reference/spotdl/types/saved/#get_urls","text":"def get_urls ( _ : str = 'saved' ) -> List [ str ] Returns a list of urls of all saved tracks.","title":"get_urls"},{"location":"reference/spotdl/types/saved/#arguments_1","text":"_: not required, but used to match the signature of the other get_urls methods.","title":"Arguments"},{"location":"reference/spotdl/types/saved/#returns_1","text":"A list of urls. View Source @staticmethod def get_urls ( _ : str = \"saved\" ) -> List [ str ] : \"\"\" Returns a list of urls of all saved tracks. ### Arguments - _: not required, but used to match the signature of the other get_urls methods. ### Returns - A list of urls. \"\"\" spotify_client = SpotifyClient () if spotify_client . user_auth is False : # type : ignore raise SavedError ( \"You must be logged in to use this function.\" ) saved_tracks_response = spotify_client . current_user_saved_tracks () if saved_tracks_response is None : raise Exception ( \"Couldn't get saved tracks\" ) saved_tracks = saved_tracks_response [ \"items\" ] # Fetch all saved tracks while saved_tracks_response and saved_tracks_response [ \"next\" ] : response = spotify_client . next ( saved_tracks_response ) # response is wrong , break if response is None : break saved_tracks_response = response saved_tracks . extend ( saved_tracks_response [ \"items\" ] ) # Remove songs without id # and return urls return [ \"https://open.spotify.com/track/\" + track[\"track\" ][ \"id\" ] for track in saved_tracks if track and track . get ( \"track\" , {} ). get ( \"id\" ) ]","title":"Returns"},{"location":"reference/spotdl/types/saved/#instance-variables","text":"length Get list length (number of songs).","title":"Instance variables"},{"location":"reference/spotdl/types/saved/#returns_2","text":"The list length.","title":"Returns"},{"location":"reference/spotdl/types/saved/#savederror","text":"class SavedError ( / , * args , ** kwargs ) View Source class SavedError ( Exception ): \"\"\" Base class for all exceptions related to saved tracks. \"\"\"","title":"SavedError"},{"location":"reference/spotdl/types/saved/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/saved/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/types/saved/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/types/saved/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/types/song/","text":"Module spotdl.types.song Song module that hold the Song and SongList classes. None View Source \"\"\" Song module that hold the Song and SongList classes. \"\"\" import json from dataclasses import dataclass , asdict from typing import Dict , Any , List , Optional from spotdl.utils.spotify import SpotifyClient class SongError ( Exception ): \"\"\" Base class for all exceptions related to songs. \"\"\" @dataclass () class Song : \"\"\" Song class. Contains all the information about a song. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int duration : int year : int date : str track_number : int tracks_count : int song_id : str cover_url : str explicit : bool publisher : str url : str isrc : Optional [ str ] copyright_text : Optional [ str ] download_url : Optional [ str ] = None song_list : Optional [ \"SongList\" ] = None @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: { url } \" ) # query spotify for song, artist, album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str , Any ] = spotify_client . artist ( primary_artist_id ) # type: ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str , Any ] = spotify_client . album ( album_id ) # type: ignore # create song object return cls ( name = raw_track_meta [ \"name\" ], artists = [ artist [ \"name\" ] for artist in raw_track_meta [ \"artists\" ]], artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ], album_name = raw_album_meta [ \"name\" ], album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ], copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ], disc_number = raw_track_meta [ \"disc_number\" ], disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ - 1 ][ \"disc_number\" ]), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][: 4 ]), date = raw_album_meta [ \"release_date\" ], track_number = raw_track_meta [ \"track_number\" ], tracks_count = raw_album_meta [ \"total_tracks\" ], isrc = raw_track_meta . get ( \"external_ids\" , {}) . get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ], explicit = raw_track_meta [ \"explicit\" ], publisher = raw_album_meta [ \"label\" ], url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ], cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ], ) @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \" { self . artist } - { self . name } \" @property def json ( self ) -> Dict [ str , Any ]: \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self ) @dataclass ( frozen = True ) class SongList : \"\"\" SongList class. Base class for all other song lists subclasses. \"\"\" name : str url : str urls : List [ str ] songs : List [ Song ] @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs ) @classmethod def create_basic_list ( cls , url : str ): \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError Classes Song class Song ( name : str , artists : List [ str ], artist : str , album_name : str , album_artist : str , genres : List [ str ], disc_number : int , disc_count : int , duration : int , year : int , date : str , track_number : int , tracks_count : int , song_id : str , cover_url : str , explicit : bool , publisher : str , url : str , isrc : Optional [ str ], copyright_text : Optional [ str ], download_url : Optional [ str ] = None , song_list : Optional [ ForwardRef ( 'SongList' )] = None ) View Source @dataclass () class Song : \"\"\" Song class. Contains all the information about a song. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int duration : int year : int date : str track_number : int tracks_count : int song_id : str cover_url : str explicit : bool publisher : str url : str isrc : Optional [ str ] copyright_text : Optional [ str ] download_url : Optional [ str ] = None song_list : Optional [ \"SongList\" ] = None @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: {url}\" ) # query spotify for song , artist , album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str, Any ] = spotify_client . artist ( primary_artist_id ) # type : ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str, Any ] = spotify_client . album ( album_id ) # type : ignore # create song object return cls ( name = raw_track_meta [ \"name\" ] , artists =[ artist[\"name\" ] for artist in raw_track_meta [ \"artists\" ] ] , artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ] , album_name = raw_album_meta [ \"name\" ] , album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ] , copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ] , disc_number = raw_track_meta [ \"disc_number\" ] , disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ -1 ][ \"disc_number\" ] ), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][ :4 ] ), date = raw_album_meta [ \"release_date\" ] , track_number = raw_track_meta [ \"track_number\" ] , tracks_count = raw_album_meta [ \"total_tracks\" ] , isrc = raw_track_meta . get ( \"external_ids\" , {} ). get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ] , explicit = raw_track_meta [ \"explicit\" ] , publisher = raw_album_meta [ \"label\" ] , url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ] , cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] , ) @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) @classmethod def from_dict ( cls , data : Dict [ str, Any ] ) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \"{self.artist} - {self.name}\" @property def json ( self ) -> Dict [ str, Any ] : \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self ) Class variables download_url song_list Static methods from_data_dump def from_data_dump ( data : str ) -> 'Song' Create a Song object from a data dump. Arguments data: The data dump. Returns The Song object. View Source @ classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) from_dict def from_dict ( data : Dict [ str , Any ] ) -> 'Song' Create a Song object from a dictionary. Arguments data: The dictionary. Returns The Song object. View Source @classmethod def from_dict ( cls , data : Dict [ str, Any ] ) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) from_search_term def from_search_term ( search_term : str ) -> 'Song' Creates a list of Song objects from a search term. Arguments search_term: The search term to use. Returns The Song object. View Source @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) from_url def from_url ( url : str ) -> 'Song' Creates a Song object from a URL. Arguments url: The URL of the song. Returns The Song object. View Source @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: {url}\" ) # query spotify for song , artist , album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str, Any ] = spotify_client . artist ( primary_artist_id ) # type : ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str, Any ] = spotify_client . album ( album_id ) # type : ignore # create song object return cls ( name = raw_track_meta [ \"name\" ] , artists =[ artist[\"name\" ] for artist in raw_track_meta [ \"artists\" ] ] , artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ] , album_name = raw_album_meta [ \"name\" ] , album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ] , copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ] , disc_number = raw_track_meta [ \"disc_number\" ] , disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ -1 ][ \"disc_number\" ] ), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][ :4 ] ), date = raw_album_meta [ \"release_date\" ] , track_number = raw_track_meta [ \"track_number\" ] , tracks_count = raw_album_meta [ \"total_tracks\" ] , isrc = raw_track_meta . get ( \"external_ids\" , {} ). get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ] , explicit = raw_track_meta [ \"explicit\" ] , publisher = raw_album_meta [ \"label\" ] , url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ] , cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] , ) Instance variables display_name Returns a display name for the song. Returns The display name. json Returns a dictionary of the song's data. Returns The dictionary. SongError class SongError ( / , * args , ** kwargs ) View Source class SongError ( Exception ): \"\"\" Base class for all exceptions related to songs. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. SongList class SongList ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ] ) View Source @dataclass ( frozen = True ) class SongList : \"\"\" SongList class. Base class for all other song lists subclasses. \"\"\" name : str url : str urls : List [ str ] songs : List [ Song ] @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs ) @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError Descendants spotdl.types.playlist.Playlist spotdl.types.album.Album spotdl.types.artist.Artist spotdl.types.saved.Saved Static methods create_basic_list def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls. Arguments url: The url of the list. Returns The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) from_url def from_url ( url : str ) -> 'SongList' Initialize a SongList object from a URL. Arguments url: The URL of the list. View Source @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError get_metadata def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for list. Arguments url: The URL of the list. Returns The metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError get_urls def get_urls ( url : str ) -> List [ str ] Get urls for all songs in url. Arguments url: The URL of the list. Returns The list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError Instance variables length Get list length (number of songs). Returns The list length.","title":"Song"},{"location":"reference/spotdl/types/song/#module-spotdltypessong","text":"Song module that hold the Song and SongList classes. None View Source \"\"\" Song module that hold the Song and SongList classes. \"\"\" import json from dataclasses import dataclass , asdict from typing import Dict , Any , List , Optional from spotdl.utils.spotify import SpotifyClient class SongError ( Exception ): \"\"\" Base class for all exceptions related to songs. \"\"\" @dataclass () class Song : \"\"\" Song class. Contains all the information about a song. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int duration : int year : int date : str track_number : int tracks_count : int song_id : str cover_url : str explicit : bool publisher : str url : str isrc : Optional [ str ] copyright_text : Optional [ str ] download_url : Optional [ str ] = None song_list : Optional [ \"SongList\" ] = None @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: { url } \" ) # query spotify for song, artist, album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str , Any ] = spotify_client . artist ( primary_artist_id ) # type: ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str , Any ] = spotify_client . album ( album_id ) # type: ignore # create song object return cls ( name = raw_track_meta [ \"name\" ], artists = [ artist [ \"name\" ] for artist in raw_track_meta [ \"artists\" ]], artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ], album_name = raw_album_meta [ \"name\" ], album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ], copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ], disc_number = raw_track_meta [ \"disc_number\" ], disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ - 1 ][ \"disc_number\" ]), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][: 4 ]), date = raw_album_meta [ \"release_date\" ], track_number = raw_track_meta [ \"track_number\" ], tracks_count = raw_album_meta [ \"total_tracks\" ], isrc = raw_track_meta . get ( \"external_ids\" , {}) . get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ], explicit = raw_track_meta [ \"explicit\" ], publisher = raw_album_meta [ \"label\" ], url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ], cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ], ) @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \" { self . artist } - { self . name } \" @property def json ( self ) -> Dict [ str , Any ]: \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self ) @dataclass ( frozen = True ) class SongList : \"\"\" SongList class. Base class for all other song lists subclasses. \"\"\" name : str url : str urls : List [ str ] songs : List [ Song ] @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs ) @classmethod def create_basic_list ( cls , url : str ): \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = []) @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError @staticmethod def get_urls ( url : str ) -> List [ str ]: \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError @staticmethod def get_metadata ( url : str ) -> Dict [ str , Any ]: \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError","title":"Module spotdl.types.song"},{"location":"reference/spotdl/types/song/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/types/song/#song","text":"class Song ( name : str , artists : List [ str ], artist : str , album_name : str , album_artist : str , genres : List [ str ], disc_number : int , disc_count : int , duration : int , year : int , date : str , track_number : int , tracks_count : int , song_id : str , cover_url : str , explicit : bool , publisher : str , url : str , isrc : Optional [ str ], copyright_text : Optional [ str ], download_url : Optional [ str ] = None , song_list : Optional [ ForwardRef ( 'SongList' )] = None ) View Source @dataclass () class Song : \"\"\" Song class. Contains all the information about a song. \"\"\" name : str artists : List [ str ] artist : str album_name : str album_artist : str genres : List [ str ] disc_number : int disc_count : int duration : int year : int date : str track_number : int tracks_count : int song_id : str cover_url : str explicit : bool publisher : str url : str isrc : Optional [ str ] copyright_text : Optional [ str ] download_url : Optional [ str ] = None song_list : Optional [ \"SongList\" ] = None @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: {url}\" ) # query spotify for song , artist , album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str, Any ] = spotify_client . artist ( primary_artist_id ) # type : ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str, Any ] = spotify_client . album ( album_id ) # type : ignore # create song object return cls ( name = raw_track_meta [ \"name\" ] , artists =[ artist[\"name\" ] for artist in raw_track_meta [ \"artists\" ] ] , artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ] , album_name = raw_album_meta [ \"name\" ] , album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ] , copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ] , disc_number = raw_track_meta [ \"disc_number\" ] , disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ -1 ][ \"disc_number\" ] ), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][ :4 ] ), date = raw_album_meta [ \"release_date\" ] , track_number = raw_track_meta [ \"track_number\" ] , tracks_count = raw_album_meta [ \"total_tracks\" ] , isrc = raw_track_meta . get ( \"external_ids\" , {} ). get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ] , explicit = raw_track_meta [ \"explicit\" ] , publisher = raw_album_meta [ \"label\" ] , url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ] , cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] , ) @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] ) @classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict ) @classmethod def from_dict ( cls , data : Dict [ str, Any ] ) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data ) @property def display_name ( self ) -> str : \"\"\" Returns a display name for the song. ### Returns - The display name. \"\"\" return f \"{self.artist} - {self.name}\" @property def json ( self ) -> Dict [ str, Any ] : \"\"\" Returns a dictionary of the song's data. ### Returns - The dictionary. \"\"\" return asdict ( self )","title":"Song"},{"location":"reference/spotdl/types/song/#class-variables","text":"download_url song_list","title":"Class variables"},{"location":"reference/spotdl/types/song/#static-methods","text":"","title":"Static methods"},{"location":"reference/spotdl/types/song/#from_data_dump","text":"def from_data_dump ( data : str ) -> 'Song' Create a Song object from a data dump.","title":"from_data_dump"},{"location":"reference/spotdl/types/song/#arguments","text":"data: The data dump.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns","text":"The Song object. View Source @ classmethod def from_data_dump ( cls , data : str ) -> \"Song\" : \"\"\" Create a Song object from a data dump. ### Arguments - data: The data dump. ### Returns - The Song object. \"\"\" # Create dict from json string data_dict = json . loads ( data ) # Return product object return cls ( ** data_dict )","title":"Returns"},{"location":"reference/spotdl/types/song/#from_dict","text":"def from_dict ( data : Dict [ str , Any ] ) -> 'Song' Create a Song object from a dictionary.","title":"from_dict"},{"location":"reference/spotdl/types/song/#arguments_1","text":"data: The dictionary.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_1","text":"The Song object. View Source @classmethod def from_dict ( cls , data : Dict [ str, Any ] ) -> \"Song\" : \"\"\" Create a Song object from a dictionary. ### Arguments - data: The dictionary. ### Returns - The Song object. \"\"\" # Return product object return cls ( ** data )","title":"Returns"},{"location":"reference/spotdl/types/song/#from_search_term","text":"def from_search_term ( search_term : str ) -> 'Song' Creates a list of Song objects from a search term.","title":"from_search_term"},{"location":"reference/spotdl/types/song/#arguments_2","text":"search_term: The search term to use.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_2","text":"The Song object. View Source @classmethod def from_search_term ( cls , search_term : str ) -> \"Song\" : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: The search term to use. ### Returns - The Song object. \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) return Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ 0 ][ \"id\" ] )","title":"Returns"},{"location":"reference/spotdl/types/song/#from_url","text":"def from_url ( url : str ) -> 'Song' Creates a Song object from a URL.","title":"from_url"},{"location":"reference/spotdl/types/song/#arguments_3","text":"url: The URL of the song.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_3","text":"The Song object. View Source @classmethod def from_url ( cls , url : str ) -> \"Song\" : \"\"\" Creates a Song object from a URL. ### Arguments - url: The URL of the song. ### Returns - The Song object. \"\"\" if \"open.spotify.com\" not in url or \"track\" not in url : raise SongError ( f \"Invalid URL: {url}\" ) # query spotify for song , artist , album details spotify_client = SpotifyClient () # get track info raw_track_meta = spotify_client . track ( url ) if raw_track_meta is None : raise SongError ( \"Couldn't get metadata, check if you have passed correct track id\" ) # get artist info primary_artist_id = raw_track_meta [ \"artists\" ][ 0 ][ \"id\" ] raw_artist_meta : Dict [ str, Any ] = spotify_client . artist ( primary_artist_id ) # type : ignore # get album info album_id = raw_track_meta [ \"album\" ][ \"id\" ] raw_album_meta : Dict [ str, Any ] = spotify_client . album ( album_id ) # type : ignore # create song object return cls ( name = raw_track_meta [ \"name\" ] , artists =[ artist[\"name\" ] for artist in raw_track_meta [ \"artists\" ] ] , artist = raw_track_meta [ \"artists\" ][ 0 ][ \"name\" ] , album_name = raw_album_meta [ \"name\" ] , album_artist = raw_album_meta [ \"artists\" ][ 0 ][ \"name\" ] , copyright_text = raw_album_meta [ \"copyrights\" ][ 0 ][ \"text\" ] if raw_album_meta [ \"copyrights\" ] else None , genres = raw_album_meta [ \"genres\" ] + raw_artist_meta [ \"genres\" ] , disc_number = raw_track_meta [ \"disc_number\" ] , disc_count = int ( raw_album_meta [ \"tracks\" ][ \"items\" ][ -1 ][ \"disc_number\" ] ), duration = raw_track_meta [ \"duration_ms\" ] / 1000 , year = int ( raw_album_meta [ \"release_date\" ][ :4 ] ), date = raw_album_meta [ \"release_date\" ] , track_number = raw_track_meta [ \"track_number\" ] , tracks_count = raw_album_meta [ \"total_tracks\" ] , isrc = raw_track_meta . get ( \"external_ids\" , {} ). get ( \"isrc\" ), song_id = raw_track_meta [ \"id\" ] , explicit = raw_track_meta [ \"explicit\" ] , publisher = raw_album_meta [ \"label\" ] , url = raw_track_meta [ \"external_urls\" ][ \"spotify\" ] , cover_url = raw_album_meta [ \"images\" ][ 0 ][ \"url\" ] , )","title":"Returns"},{"location":"reference/spotdl/types/song/#instance-variables","text":"display_name Returns a display name for the song.","title":"Instance variables"},{"location":"reference/spotdl/types/song/#returns_4","text":"The display name. json Returns a dictionary of the song's data.","title":"Returns"},{"location":"reference/spotdl/types/song/#returns_5","text":"The dictionary.","title":"Returns"},{"location":"reference/spotdl/types/song/#songerror","text":"class SongError ( / , * args , ** kwargs ) View Source class SongError ( Exception ): \"\"\" Base class for all exceptions related to songs. \"\"\"","title":"SongError"},{"location":"reference/spotdl/types/song/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/types/song/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/spotdl/types/song/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/types/song/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/types/song/#songlist","text":"class SongList ( name : str , url : str , urls : List [ str ], songs : List [ spotdl . types . song . Song ] ) View Source @dataclass ( frozen = True ) class SongList : \"\"\" SongList class. Base class for all other song lists subclasses. \"\"\" name : str url : str urls : List [ str ] songs : List [ Song ] @property def length ( self ) -> int : \"\"\" Get list length (number of songs). ### Returns - The list length. \"\"\" return len ( self . songs ) @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] ) @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError","title":"SongList"},{"location":"reference/spotdl/types/song/#descendants","text":"spotdl.types.playlist.Playlist spotdl.types.album.Album spotdl.types.artist.Artist spotdl.types.saved.Saved","title":"Descendants"},{"location":"reference/spotdl/types/song/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/spotdl/types/song/#create_basic_list","text":"def create_basic_list ( url : str ) Create a basic list with only the required metadata and urls.","title":"create_basic_list"},{"location":"reference/spotdl/types/song/#arguments_4","text":"url: The url of the list.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_6","text":"The SongList object. View Source @classmethod def create_basic_list ( cls , url : str ) : \"\"\" Create a basic list with only the required metadata and urls. ### Arguments - url: The url of the list. ### Returns - The SongList object. \"\"\" metadata = cls . get_metadata ( url ) urls = cls . get_urls ( url ) return cls ( ** metadata , urls = urls , songs = [] )","title":"Returns"},{"location":"reference/spotdl/types/song/#from_url_1","text":"def from_url ( url : str ) -> 'SongList' Initialize a SongList object from a URL.","title":"from_url"},{"location":"reference/spotdl/types/song/#arguments_5","text":"url: The URL of the list. View Source @classmethod def from_url ( cls , url : str ) -> \"SongList\" : \"\"\" Initialize a SongList object from a URL. ### Arguments - url: The URL of the list. \"\"\" raise NotImplementedError","title":"Arguments"},{"location":"reference/spotdl/types/song/#get_metadata","text":"def get_metadata ( url : str ) -> Dict [ str , Any ] Get metadata for list.","title":"get_metadata"},{"location":"reference/spotdl/types/song/#arguments_6","text":"url: The URL of the list.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_7","text":"The metadata. View Source @staticmethod def get_metadata ( url : str ) -> Dict [ str, Any ] : \"\"\" Get metadata for list. ### Arguments - url: The URL of the list. ### Returns - The metadata. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/types/song/#get_urls","text":"def get_urls ( url : str ) -> List [ str ] Get urls for all songs in url.","title":"get_urls"},{"location":"reference/spotdl/types/song/#arguments_7","text":"url: The URL of the list.","title":"Arguments"},{"location":"reference/spotdl/types/song/#returns_8","text":"The list of urls. View Source @staticmethod def get_urls ( url : str ) -> List [ str ] : \"\"\" Get urls for all songs in url. ### Arguments - url: The URL of the list. ### Returns - The list of urls. \"\"\" raise NotImplementedError","title":"Returns"},{"location":"reference/spotdl/types/song/#instance-variables_1","text":"length Get list length (number of songs).","title":"Instance variables"},{"location":"reference/spotdl/types/song/#returns_9","text":"The list length.","title":"Returns"},{"location":"reference/spotdl/utils/","text":"Module spotdl.utils Utility functions for spotdl. These functions are used in every stage of the download process. View Source \"\"\" Utility functions for spotdl. These functions are used in every stage of the download process. \"\"\" Sub-modules spotdl.utils.arguments spotdl.utils.config spotdl.utils.ffmpeg spotdl.utils.formatter spotdl.utils.github spotdl.utils.m3u spotdl.utils.metadata spotdl.utils.providers spotdl.utils.search spotdl.utils.spotify","title":"Index"},{"location":"reference/spotdl/utils/#module-spotdlutils","text":"Utility functions for spotdl. These functions are used in every stage of the download process. View Source \"\"\" Utility functions for spotdl. These functions are used in every stage of the download process. \"\"\"","title":"Module spotdl.utils"},{"location":"reference/spotdl/utils/#sub-modules","text":"spotdl.utils.arguments spotdl.utils.config spotdl.utils.ffmpeg spotdl.utils.formatter spotdl.utils.github spotdl.utils.m3u spotdl.utils.metadata spotdl.utils.providers spotdl.utils.search spotdl.utils.spotify","title":"Sub-modules"},{"location":"reference/spotdl/utils/arguments/","text":"Module spotdl.utils.arguments Module that handles the command line arguments. None View Source \"\"\" Module that handles the command line arguments. \"\"\" import sys from argparse import _ArgumentGroup , ArgumentParser , Namespace from spotdl import _version from spotdl.download.progress_handler import NAME_TO_LEVEL from spotdl.utils.ffmpeg import FFMPEG_FORMATS from spotdl.utils.config import DEFAULT_CONFIG from spotdl.utils.formatter import VARS from spotdl.download.downloader import ( AUDIO_PROVIDERS , LYRICS_PROVIDERS , ) OPERATIONS = [ \"download\" , \"save\" , \"preload\" , \"web\" , \"sync\" ] def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args () def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = \"The operation to perform.\" , ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = \"URL for a song/playlist/album/artist/etc. to download.\" , ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , default = DEFAULT_CONFIG [ \"audio_providers\" ], help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), default = DEFAULT_CONFIG [ \"lyrics_providers\" ], help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under `C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json` \" \"or `~/.spotdl/config.json` under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , default = DEFAULT_CONFIG [ \"search_query\" ], help = f \"The search query to use, available variables: { ', ' . join ( VARS ) } \" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , action = \"store_false\" , dest = \"filter_results\" , default = DEFAULT_CONFIG [ \"filter_results\" ], help = \"Disable filtering results.\" , ) def parse_spotify_options ( parser : _ArgumentGroup ): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser . add_argument ( \"--user-auth\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"user_auth\" ], help = \"Login to Spotify using OAuth.\" , ) # Add client id argument parser . add_argument ( \"--client-id\" , default = DEFAULT_CONFIG [ \"client_id\" ], help = \"The client id to use when logging in to Spotify.\" , ) # Add client secret argument parser . add_argument ( \"--client-secret\" , default = DEFAULT_CONFIG [ \"client_secret\" ], help = \"The client secret to use when logging in to Spotify.\" , ) # Add cache path argument parser . add_argument ( \"--cache-path\" , type = str , default = DEFAULT_CONFIG [ \"cache_path\" ], help = \"The path where spotipy cache file will be stored.\" , ) # Add no cache argument parser . add_argument ( \"--no-cache\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"no_cache\" ], help = \"Disable caching.\" , ) # Add cookie file argument parser . add_argument ( \"--cookie-file\" , default = DEFAULT_CONFIG [ \"cookie_file\" ], help = \"Path to cookies file.\" , ) def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , default = DEFAULT_CONFIG [ \"ffmpeg\" ], help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , default = DEFAULT_CONFIG [ \"threads\" ], type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], default = DEFAULT_CONFIG [ \"bitrate\" ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , default = DEFAULT_CONFIG [ \"ffmpeg_args\" ], help = \"Additional ffmpeg arguments passed as a string.\" , ) def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), default = DEFAULT_CONFIG [ \"format\" ], help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , default = DEFAULT_CONFIG [ \"save_file\" ], help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" , \"preload\" , \"sync\" ], ) # Add name format argument parser . add_argument ( \"--output\" , type = str , default = DEFAULT_CONFIG [ \"output\" ], help = f \"Specify the downloaded file name format, available variables: { ', ' . join ( VARS ) } \" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , default = DEFAULT_CONFIG [ \"m3u\" ], help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, default = DEFAULT_CONFIG [ \"overwrite\" ], help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , default = DEFAULT_CONFIG [ \"restrict\" ], help = \"Restrict filenames to ASCII only\" , action = \"store_true\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , default = DEFAULT_CONFIG [ \"print_errors\" ], help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , action = \"store_true\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , default = DEFAULT_CONFIG [ \"sponsor_block\" ], help = \"Use the sponsor block to download songs from yt/ytm.\" , action = \"store_true\" , ) def parse_misc_options ( parser : _ArgumentGroup ): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser . add_argument ( \"--log-level\" , choices = NAME_TO_LEVEL . keys (), help = \"Select log level.\" , ) # Add simple tui argument parser . add_argument ( \"--simple-tui\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"simple_tui\" ], help = \"Use a simple tui.\" , ) # Add headless argument parser . add_argument ( \"--headless\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"headless\" ], help = \"Run in headless mode.\" , ) def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , ) Variables AUDIO_PROVIDERS DEFAULT_CONFIG FFMPEG_FORMATS LYRICS_PROVIDERS NAME_TO_LEVEL OPERATIONS VARS Functions parse_arguments def parse_arguments ( ) -> argparse . Namespace Parse arguments from the command line. Returns A Namespace object containing the parsed arguments. View Source def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args () parse_ffmpeg_options def parse_ffmpeg_options ( parser : argparse . _ArgumentGroup ) Parse ffmpeg options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , default = DEFAULT_CONFIG [ \"ffmpeg\" ], help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , default = DEFAULT_CONFIG [ \"threads\" ], type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], default = DEFAULT_CONFIG [ \"bitrate\" ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , default = DEFAULT_CONFIG [ \"ffmpeg_args\" ], help = \"Additional ffmpeg arguments passed as a string.\" , ) parse_main_options def parse_main_options ( parser : argparse . _ArgumentGroup ) Parse main options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = \"The operation to perform.\" , ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = \"URL for a song/playlist/album/artist/etc. to download.\" , ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , default = DEFAULT_CONFIG [ \"audio_providers\" ], help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), default = DEFAULT_CONFIG [ \"lyrics_providers\" ], help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under `C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json` \" \"or `~/.spotdl/config.json` under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , default = DEFAULT_CONFIG [ \"search_query\" ], help = f \"The search query to use, available variables: {', '.join(VARS)}\" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , action = \"store_false\" , dest = \"filter_results\" , default = DEFAULT_CONFIG [ \"filter_results\" ], help = \"Disable filtering results.\" , ) parse_misc_options def parse_misc_options ( parser : argparse . _ArgumentGroup ) Parse misc options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_misc_options(parser: _ArgumentGroup): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser.add_argument( \"--log-level\", choices=NAME_TO_LEVEL.keys(), help=\"Select log level.\", ) # Add simple tui argument parser.add_argument( \"--simple-tui\", action=\"store_true\", default=DEFAULT_CONFIG[\"simple_tui\"], help=\"Use a simple tui.\", ) # Add headless argument parser.add_argument( \"--headless\", action=\"store_true\", default=DEFAULT_CONFIG[\"headless\"], help=\"Run in headless mode.\", ) parse_other_options def parse_other_options ( parser : argparse . _ArgumentGroup ) Parse other options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , ) parse_output_options def parse_output_options ( parser : argparse . _ArgumentGroup ) Parse output options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), default = DEFAULT_CONFIG [ \"format\" ], help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , default = DEFAULT_CONFIG [ \"save_file\" ], help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" , \"preload\" , \"sync\" ], ) # Add name format argument parser . add_argument ( \"--output\" , type = str , default = DEFAULT_CONFIG [ \"output\" ], help = f \"Specify the downloaded file name format, available variables: {', '.join(VARS)}\" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , default = DEFAULT_CONFIG [ \"m3u\" ], help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, default = DEFAULT_CONFIG [ \"overwrite\" ], help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , default = DEFAULT_CONFIG [ \"restrict\" ], help = \"Restrict filenames to ASCII only\" , action = \"store_true\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , default = DEFAULT_CONFIG [ \"print_errors\" ], help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , action = \"store_true\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , default = DEFAULT_CONFIG [ \"sponsor_block\" ], help = \"Use the sponsor block to download songs from yt/ytm.\" , action = \"store_true\" , ) parse_spotify_options def parse_spotify_options ( parser : argparse . _ArgumentGroup ) Parse spotify options from the command line. Arguments parser: The argument parser to add the options to. View Source def parse_spotify_options(parser: _ArgumentGroup): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser.add_argument( \"--user-auth\", action=\"store_true\", default=DEFAULT_CONFIG[\"user_auth\"], help=\"Login to Spotify using OAuth.\", ) # Add client id argument parser.add_argument( \"--client-id\", default=DEFAULT_CONFIG[\"client_id\"], help=\"The client id to use when logging in to Spotify.\", ) # Add client secret argument parser.add_argument( \"--client-secret\", default=DEFAULT_CONFIG[\"client_secret\"], help=\"The client secret to use when logging in to Spotify.\", ) # Add cache path argument parser.add_argument( \"--cache-path\", type=str, default=DEFAULT_CONFIG[\"cache_path\"], help=\"The path where spotipy cache file will be stored.\", ) # Add no cache argument parser.add_argument( \"--no-cache\", action=\"store_true\", default=DEFAULT_CONFIG[\"no_cache\"], help=\"Disable caching.\", ) # Add cookie file argument parser.add_argument( \"--cookie-file\", default=DEFAULT_CONFIG[\"cookie_file\"], help=\"Path to cookies file.\", )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#module-spotdlutilsarguments","text":"Module that handles the command line arguments. None View Source \"\"\" Module that handles the command line arguments. \"\"\" import sys from argparse import _ArgumentGroup , ArgumentParser , Namespace from spotdl import _version from spotdl.download.progress_handler import NAME_TO_LEVEL from spotdl.utils.ffmpeg import FFMPEG_FORMATS from spotdl.utils.config import DEFAULT_CONFIG from spotdl.utils.formatter import VARS from spotdl.download.downloader import ( AUDIO_PROVIDERS , LYRICS_PROVIDERS , ) OPERATIONS = [ \"download\" , \"save\" , \"preload\" , \"web\" , \"sync\" ] def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args () def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = \"The operation to perform.\" , ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = \"URL for a song/playlist/album/artist/etc. to download.\" , ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , default = DEFAULT_CONFIG [ \"audio_providers\" ], help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), default = DEFAULT_CONFIG [ \"lyrics_providers\" ], help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under `C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json` \" \"or `~/.spotdl/config.json` under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , default = DEFAULT_CONFIG [ \"search_query\" ], help = f \"The search query to use, available variables: { ', ' . join ( VARS ) } \" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , action = \"store_false\" , dest = \"filter_results\" , default = DEFAULT_CONFIG [ \"filter_results\" ], help = \"Disable filtering results.\" , ) def parse_spotify_options ( parser : _ArgumentGroup ): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser . add_argument ( \"--user-auth\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"user_auth\" ], help = \"Login to Spotify using OAuth.\" , ) # Add client id argument parser . add_argument ( \"--client-id\" , default = DEFAULT_CONFIG [ \"client_id\" ], help = \"The client id to use when logging in to Spotify.\" , ) # Add client secret argument parser . add_argument ( \"--client-secret\" , default = DEFAULT_CONFIG [ \"client_secret\" ], help = \"The client secret to use when logging in to Spotify.\" , ) # Add cache path argument parser . add_argument ( \"--cache-path\" , type = str , default = DEFAULT_CONFIG [ \"cache_path\" ], help = \"The path where spotipy cache file will be stored.\" , ) # Add no cache argument parser . add_argument ( \"--no-cache\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"no_cache\" ], help = \"Disable caching.\" , ) # Add cookie file argument parser . add_argument ( \"--cookie-file\" , default = DEFAULT_CONFIG [ \"cookie_file\" ], help = \"Path to cookies file.\" , ) def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , default = DEFAULT_CONFIG [ \"ffmpeg\" ], help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , default = DEFAULT_CONFIG [ \"threads\" ], type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], default = DEFAULT_CONFIG [ \"bitrate\" ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , default = DEFAULT_CONFIG [ \"ffmpeg_args\" ], help = \"Additional ffmpeg arguments passed as a string.\" , ) def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), default = DEFAULT_CONFIG [ \"format\" ], help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , default = DEFAULT_CONFIG [ \"save_file\" ], help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" , \"preload\" , \"sync\" ], ) # Add name format argument parser . add_argument ( \"--output\" , type = str , default = DEFAULT_CONFIG [ \"output\" ], help = f \"Specify the downloaded file name format, available variables: { ', ' . join ( VARS ) } \" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , default = DEFAULT_CONFIG [ \"m3u\" ], help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, default = DEFAULT_CONFIG [ \"overwrite\" ], help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , default = DEFAULT_CONFIG [ \"restrict\" ], help = \"Restrict filenames to ASCII only\" , action = \"store_true\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , default = DEFAULT_CONFIG [ \"print_errors\" ], help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , action = \"store_true\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , default = DEFAULT_CONFIG [ \"sponsor_block\" ], help = \"Use the sponsor block to download songs from yt/ytm.\" , action = \"store_true\" , ) def parse_misc_options ( parser : _ArgumentGroup ): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser . add_argument ( \"--log-level\" , choices = NAME_TO_LEVEL . keys (), help = \"Select log level.\" , ) # Add simple tui argument parser . add_argument ( \"--simple-tui\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"simple_tui\" ], help = \"Use a simple tui.\" , ) # Add headless argument parser . add_argument ( \"--headless\" , action = \"store_true\" , default = DEFAULT_CONFIG [ \"headless\" ], help = \"Run in headless mode.\" , ) def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , )","title":"Module spotdl.utils.arguments"},{"location":"reference/spotdl/utils/arguments/#variables","text":"AUDIO_PROVIDERS DEFAULT_CONFIG FFMPEG_FORMATS LYRICS_PROVIDERS NAME_TO_LEVEL OPERATIONS VARS","title":"Variables"},{"location":"reference/spotdl/utils/arguments/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/arguments/#parse_arguments","text":"def parse_arguments ( ) -> argparse . Namespace Parse arguments from the command line.","title":"parse_arguments"},{"location":"reference/spotdl/utils/arguments/#returns","text":"A Namespace object containing the parsed arguments. View Source def parse_arguments () -> Namespace : \"\"\" Parse arguments from the command line. ### Returns - A Namespace object containing the parsed arguments. \"\"\" # Initialize argument parser parser = ArgumentParser ( prog = \"spotdl\" , description = \"Download your Spotify playlists and songs along with album art and metadata\" , ) # Parse main options main_options = parser . add_argument_group ( \"Main options\" ) parse_main_options ( main_options ) # Parse spotify options spotify_options = parser . add_argument_group ( \"Spotify options\" ) parse_spotify_options ( spotify_options ) # Parse ffmpeg options ffmpeg_options = parser . add_argument_group ( \"FFmpeg options\" ) parse_ffmpeg_options ( ffmpeg_options ) # Parse output options output_options = parser . add_argument_group ( \"Output options\" ) parse_output_options ( output_options ) # Parse misc options misc_options = parser . add_argument_group ( \"Misc options\" ) parse_misc_options ( misc_options ) # Parse other options other_options = parser . add_argument_group ( \"Other options\" ) parse_other_options ( other_options ) return parser . parse_args ()","title":"Returns"},{"location":"reference/spotdl/utils/arguments/#parse_ffmpeg_options","text":"def parse_ffmpeg_options ( parser : argparse . _ArgumentGroup ) Parse ffmpeg options from the command line.","title":"parse_ffmpeg_options"},{"location":"reference/spotdl/utils/arguments/#arguments","text":"parser: The argument parser to add the options to. View Source def parse_ffmpeg_options ( parser : _ArgumentGroup ): \"\"\" Parse ffmpeg options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add ffmpeg executable argument parser . add_argument ( \"--ffmpeg\" , default = DEFAULT_CONFIG [ \"ffmpeg\" ], help = \"The ffmpeg executable to use.\" , ) # Add search threads argument parser . add_argument ( \"--threads\" , default = DEFAULT_CONFIG [ \"threads\" ], type = int , help = \"The number of threads to use when downloading songs.\" , ) # Add constant bit rate argument parser . add_argument ( \"--bitrate\" , choices = [ \"8k\" , \"16k\" , \"24k\" , \"32k\" , \"40k\" , \"48k\" , \"64k\" , \"80k\" , \"96k\" , \"112k\" , \"128k\" , \"160k\" , \"192k\" , \"224k\" , \"256k\" , \"320k\" , ], default = DEFAULT_CONFIG [ \"bitrate\" ], type = str . lower , help = \"The constant bitrate to use for the output file.\" , ) # Additional ffmpeg arguments parser . add_argument ( \"--ffmpeg-args\" , type = str , default = DEFAULT_CONFIG [ \"ffmpeg_args\" ], help = \"Additional ffmpeg arguments passed as a string.\" , )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#parse_main_options","text":"def parse_main_options ( parser : argparse . _ArgumentGroup ) Parse main options from the command line.","title":"parse_main_options"},{"location":"reference/spotdl/utils/arguments/#arguments_1","text":"parser: The argument parser to add the options to. View Source def parse_main_options ( parser : _ArgumentGroup ): \"\"\" Parse main options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add operation argument operation = parser . add_argument ( \"operation\" , choices = OPERATIONS , help = \"The operation to perform.\" , ) # Add query argument query = parser . add_argument ( \"query\" , nargs = \"+\" , type = str , help = \"URL for a song/playlist/album/artist/etc. to download.\" , ) try : is_web = sys . argv [ 1 ] == \"web\" except IndexError : is_web = False is_frozen = getattr ( sys , \"frozen\" , False ) # If the program is frozen, we and user didn't pass any arguments, # or if the user is using the web interface, we don't need to parse # the query if ( is_frozen and len ( sys . argv ) < 2 ) or ( len ( sys . argv ) > 1 and is_web ): # If we are running the web interface # or we are in the frozen env and not running web interface # don't remove the operation from the arg parser if not is_web or ( is_frozen and not is_web ): parser . _remove_action ( operation ) # pylint: disable=protected-access parser . _remove_action ( query ) # pylint: disable=protected-access # Audio provider argument parser . add_argument ( \"--audio\" , dest = \"audio_providers\" , nargs = \"*\" , choices = AUDIO_PROVIDERS , default = DEFAULT_CONFIG [ \"audio_providers\" ], help = \"The audio provider to use. You can provide more than one for fallback.\" , ) # Lyrics provider argument parser . add_argument ( \"--lyrics\" , dest = \"lyrics_providers\" , nargs = \"*\" , choices = LYRICS_PROVIDERS . keys (), default = DEFAULT_CONFIG [ \"lyrics_providers\" ], help = \"The lyrics provider to use. You can provide more than one for fallback.\" , ) # Add config argument parser . add_argument ( \"--config\" , action = \"store_true\" , help = ( \"Use the config file to download songs. \" \"It's located under `C: \\\\ Users \\\\ user \\\\ .spotdl \\\\ config.json` \" \"or `~/.spotdl/config.json` under linux\" ), ) # Add search query argument parser . add_argument ( \"--search-query\" , default = DEFAULT_CONFIG [ \"search_query\" ], help = f \"The search query to use, available variables: {', '.join(VARS)}\" , ) # Add don't filter results argument parser . add_argument ( \"--dont-filter-results\" , action = \"store_false\" , dest = \"filter_results\" , default = DEFAULT_CONFIG [ \"filter_results\" ], help = \"Disable filtering results.\" , )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#parse_misc_options","text":"def parse_misc_options ( parser : argparse . _ArgumentGroup ) Parse misc options from the command line.","title":"parse_misc_options"},{"location":"reference/spotdl/utils/arguments/#arguments_2","text":"parser: The argument parser to add the options to. View Source def parse_misc_options(parser: _ArgumentGroup): \"\"\" Parse misc options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add verbose argument parser.add_argument( \"--log-level\", choices=NAME_TO_LEVEL.keys(), help=\"Select log level.\", ) # Add simple tui argument parser.add_argument( \"--simple-tui\", action=\"store_true\", default=DEFAULT_CONFIG[\"simple_tui\"], help=\"Use a simple tui.\", ) # Add headless argument parser.add_argument( \"--headless\", action=\"store_true\", default=DEFAULT_CONFIG[\"headless\"], help=\"Run in headless mode.\", )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#parse_other_options","text":"def parse_other_options ( parser : argparse . _ArgumentGroup ) Parse other options from the command line.","title":"parse_other_options"},{"location":"reference/spotdl/utils/arguments/#arguments_3","text":"parser: The argument parser to add the options to. View Source def parse_other_options ( parser : _ArgumentGroup ): \"\"\" Parse other options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" parser . add_argument ( \"--download-ffmpeg\" , action = \"store_true\" , help = \"Download ffmpeg to spotdl directory.\" , ) parser . add_argument ( \"--generate-config\" , action = \"store_true\" , help = \"Generate a config file. This will overwrite current config if present.\" , ) parser . add_argument ( \"--check-for-updates\" , action = \"store_true\" , help = \"Check for new version.\" ) parser . add_argument ( \"--profile\" , action = \"store_true\" , help = \"Run in profile mode. Useful for debugging.\" , ) parser . add_argument ( \"--version\" , \"-v\" , action = \"version\" , help = \"Show the version number and exit.\" , version = _version . __version__ , )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#parse_output_options","text":"def parse_output_options ( parser : argparse . _ArgumentGroup ) Parse output options from the command line.","title":"parse_output_options"},{"location":"reference/spotdl/utils/arguments/#arguments_4","text":"parser: The argument parser to add the options to. View Source def parse_output_options ( parser : _ArgumentGroup ): \"\"\" Parse output options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add output format argument parser . add_argument ( \"--format\" , choices = FFMPEG_FORMATS . keys (), default = DEFAULT_CONFIG [ \"format\" ], help = \"The format to download the song in.\" , ) # Add save file argument parser . add_argument ( \"--save-file\" , type = str , default = DEFAULT_CONFIG [ \"save_file\" ], help = ( \"The file to save/load the songs data from/to. \" \"It has to end with .spotdl. \" \"If combined with the download operation, it will save the songs data to the file. \" \"Required for save/preload/sync\" ), required = len ( sys . argv ) > 1 and sys . argv [ 1 ] in [ \"save\" , \"preload\" , \"sync\" ], ) # Add name format argument parser . add_argument ( \"--output\" , type = str , default = DEFAULT_CONFIG [ \"output\" ], help = f \"Specify the downloaded file name format, available variables: {', '.join(VARS)}\" , ) # Add m3u argument parser . add_argument ( \"--m3u\" , type = str , default = DEFAULT_CONFIG [ \"m3u\" ], help = \"Name of the m3u file to save the songs to.\" , ) # Add overwrite argument parser . add_argument ( \"--overwrite\" , choices = { \"force\" , \"skip\" }, default = DEFAULT_CONFIG [ \"overwrite\" ], help = \"Overwrite existing files.\" , ) # Option to restrict filenames for easier handling in the shell parser . add_argument ( \"--restrict\" , default = DEFAULT_CONFIG [ \"restrict\" ], help = \"Restrict filenames to ASCII only\" , action = \"store_true\" , ) # Option to print errors on exit, useful for long playlist parser . add_argument ( \"--print-errors\" , default = DEFAULT_CONFIG [ \"print_errors\" ], help = \"Print errors (wrong songs, failed downloads etc) on exit, useful for long playlist\" , action = \"store_true\" , ) # Option to use sponsor block parser . add_argument ( \"--sponsor-block\" , default = DEFAULT_CONFIG [ \"sponsor_block\" ], help = \"Use the sponsor block to download songs from yt/ytm.\" , action = \"store_true\" , )","title":"Arguments"},{"location":"reference/spotdl/utils/arguments/#parse_spotify_options","text":"def parse_spotify_options ( parser : argparse . _ArgumentGroup ) Parse spotify options from the command line.","title":"parse_spotify_options"},{"location":"reference/spotdl/utils/arguments/#arguments_5","text":"parser: The argument parser to add the options to. View Source def parse_spotify_options(parser: _ArgumentGroup): \"\"\" Parse spotify options from the command line. ### Arguments - parser: The argument parser to add the options to. \"\"\" # Add login argument parser.add_argument( \"--user-auth\", action=\"store_true\", default=DEFAULT_CONFIG[\"user_auth\"], help=\"Login to Spotify using OAuth.\", ) # Add client id argument parser.add_argument( \"--client-id\", default=DEFAULT_CONFIG[\"client_id\"], help=\"The client id to use when logging in to Spotify.\", ) # Add client secret argument parser.add_argument( \"--client-secret\", default=DEFAULT_CONFIG[\"client_secret\"], help=\"The client secret to use when logging in to Spotify.\", ) # Add cache path argument parser.add_argument( \"--cache-path\", type=str, default=DEFAULT_CONFIG[\"cache_path\"], help=\"The path where spotipy cache file will be stored.\", ) # Add no cache argument parser.add_argument( \"--no-cache\", action=\"store_true\", default=DEFAULT_CONFIG[\"no_cache\"], help=\"Disable caching.\", ) # Add cookie file argument parser.add_argument( \"--cookie-file\", default=DEFAULT_CONFIG[\"cookie_file\"], help=\"Path to cookies file.\", )","title":"Arguments"},{"location":"reference/spotdl/utils/config/","text":"Module spotdl.utils.config Module related to managing reading and writing to the config file. Default config - spotdl.utils.config.DEFAULT_CONFIG View Source \"\"\" Module related to managing reading and writing to the config file. Default config - spotdl.utils.config.DEFAULT_CONFIG \"\"\" from pathlib import Path from typing import Any , Dict import os import json class ConfigError ( Exception ): \"\"\" Base class for all exceptions related to config. \"\"\" def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists (): os . mkdir ( spotdl_path ) return spotdl_path def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\" def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\" def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists (): os . mkdir ( temp_path ) return temp_path def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists (): os . mkdir ( errors_path ) return errors_path def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file ) DEFAULT_CONFIG = { \"default_config\" : False , \"log_level\" : \"INFO\" , \"simple_tui\" : False , \"cache_path\" : str ( get_cache_path ()), \"audio_providers\" : [ \"youtube-music\" ], \"lyrics_providers\" : [ \"musixmatch\" ], \"ffmpeg\" : \"ffmpeg\" , \"bitrate\" : None , \"ffmpeg_args\" : None , \"format\" : \"mp3\" , \"save_file\" : None , \"m3u\" : None , \"output\" : \" {artists} - {title} .{output-ext}\" , \"overwrite\" : \"skip\" , \"client_id\" : \"5f573c9620494bae87890c0f08a60293\" , \"client_secret\" : \"212476d9b0f3472eaa762d90b19b0ba8\" , \"user_auth\" : False , \"search_query\" : \" {artists} - {title} \" , \"filter_results\" : True , \"threads\" : 4 , \"no_cache\" : False , \"cookie_file\" : None , \"headless\" : False , \"restrict\" : False , \"print_errors\" : False , \"sponsor_block\" : False , } Variables DEFAULT_CONFIG Functions get_cache_path def get_cache_path ( ) -> pathlib . Path Get the path to the cache folder. Returns The path to the spotipy cache file. View Source def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\" get_config def get_config ( ) -> Dict [ str , Any ] Get the config. Returns The dictionary with the config. Errors ConfigError: If the config file does not exist. View Source def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file ) get_config_file def get_config_file ( ) -> pathlib . Path Get config file path Returns The path to the config file. View Source def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\" get_errors_path def get_errors_path ( ) -> pathlib . Path Get the path to the errors folder. Returns The path to the errors folder. Notes If the errors directory does not exist, it will be created. View Source def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists () : os . mkdir ( errors_path ) return errors_path get_spotdl_path def get_spotdl_path ( ) -> pathlib . Path Get the path to the spotdl folder. Returns The path to the spotdl folder. Notes If the spotdl directory does not exist, it will be created. View Source def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists () : os . mkdir ( spotdl_path ) return spotdl_path get_temp_path def get_temp_path ( ) -> pathlib . Path Get the path to the temp folder. Returns The path to the temp folder. View Source def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists () : os . mkdir ( temp_path ) return temp_path Classes ConfigError class ConfigError ( / , * args , ** kwargs ) View Source class ConfigError ( Exception ): \"\"\" Base class for all exceptions related to config. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Config"},{"location":"reference/spotdl/utils/config/#module-spotdlutilsconfig","text":"Module related to managing reading and writing to the config file. Default config - spotdl.utils.config.DEFAULT_CONFIG View Source \"\"\" Module related to managing reading and writing to the config file. Default config - spotdl.utils.config.DEFAULT_CONFIG \"\"\" from pathlib import Path from typing import Any , Dict import os import json class ConfigError ( Exception ): \"\"\" Base class for all exceptions related to config. \"\"\" def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists (): os . mkdir ( spotdl_path ) return spotdl_path def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\" def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\" def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists (): os . mkdir ( temp_path ) return temp_path def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists (): os . mkdir ( errors_path ) return errors_path def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file ) DEFAULT_CONFIG = { \"default_config\" : False , \"log_level\" : \"INFO\" , \"simple_tui\" : False , \"cache_path\" : str ( get_cache_path ()), \"audio_providers\" : [ \"youtube-music\" ], \"lyrics_providers\" : [ \"musixmatch\" ], \"ffmpeg\" : \"ffmpeg\" , \"bitrate\" : None , \"ffmpeg_args\" : None , \"format\" : \"mp3\" , \"save_file\" : None , \"m3u\" : None , \"output\" : \" {artists} - {title} .{output-ext}\" , \"overwrite\" : \"skip\" , \"client_id\" : \"5f573c9620494bae87890c0f08a60293\" , \"client_secret\" : \"212476d9b0f3472eaa762d90b19b0ba8\" , \"user_auth\" : False , \"search_query\" : \" {artists} - {title} \" , \"filter_results\" : True , \"threads\" : 4 , \"no_cache\" : False , \"cookie_file\" : None , \"headless\" : False , \"restrict\" : False , \"print_errors\" : False , \"sponsor_block\" : False , }","title":"Module spotdl.utils.config"},{"location":"reference/spotdl/utils/config/#variables","text":"DEFAULT_CONFIG","title":"Variables"},{"location":"reference/spotdl/utils/config/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/config/#get_cache_path","text":"def get_cache_path ( ) -> pathlib . Path Get the path to the cache folder.","title":"get_cache_path"},{"location":"reference/spotdl/utils/config/#returns","text":"The path to the spotipy cache file. View Source def get_cache_path () -> Path : \"\"\" Get the path to the cache folder. ### Returns - The path to the spotipy cache file. \"\"\" return get_spotdl_path () / \".spotipy\"","title":"Returns"},{"location":"reference/spotdl/utils/config/#get_config","text":"def get_config ( ) -> Dict [ str , Any ] Get the config.","title":"get_config"},{"location":"reference/spotdl/utils/config/#returns_1","text":"The dictionary with the config.","title":"Returns"},{"location":"reference/spotdl/utils/config/#errors","text":"ConfigError: If the config file does not exist. View Source def get_config () -> Dict [ str , Any ]: \"\"\" Get the config. ### Returns - The dictionary with the config. ### Errors - ConfigError: If the config file does not exist. \"\"\" config_path = get_config_file () if not config_path . exists (): raise ConfigError ( \"Config file not found.\" \"Please run `spotdl --generate-config` to create a config file.\" ) with open ( config_path , \"r\" , encoding = \"utf-8\" ) as config_file : return json . load ( config_file )","title":"Errors"},{"location":"reference/spotdl/utils/config/#get_config_file","text":"def get_config_file ( ) -> pathlib . Path Get config file path","title":"get_config_file"},{"location":"reference/spotdl/utils/config/#returns_2","text":"The path to the config file. View Source def get_config_file () -> Path : \"\"\" Get config file path ### Returns - The path to the config file. \"\"\" return get_spotdl_path () / \"config.json\"","title":"Returns"},{"location":"reference/spotdl/utils/config/#get_errors_path","text":"def get_errors_path ( ) -> pathlib . Path Get the path to the errors folder.","title":"get_errors_path"},{"location":"reference/spotdl/utils/config/#returns_3","text":"The path to the errors folder.","title":"Returns"},{"location":"reference/spotdl/utils/config/#notes","text":"If the errors directory does not exist, it will be created. View Source def get_errors_path () -> Path : \"\"\" Get the path to the errors folder. ### Returns - The path to the errors folder. ### Notes - If the errors directory does not exist, it will be created. \"\"\" errors_path = get_spotdl_path () / \"errors\" if not errors_path . exists () : os . mkdir ( errors_path ) return errors_path","title":"Notes"},{"location":"reference/spotdl/utils/config/#get_spotdl_path","text":"def get_spotdl_path ( ) -> pathlib . Path Get the path to the spotdl folder.","title":"get_spotdl_path"},{"location":"reference/spotdl/utils/config/#returns_4","text":"The path to the spotdl folder.","title":"Returns"},{"location":"reference/spotdl/utils/config/#notes_1","text":"If the spotdl directory does not exist, it will be created. View Source def get_spotdl_path () -> Path : \"\"\" Get the path to the spotdl folder. ### Returns - The path to the spotdl folder. ### Notes - If the spotdl directory does not exist, it will be created. \"\"\" spotdl_path = Path ( os . path . expanduser ( \"~\" ), \".spotdl\" ) if not spotdl_path . exists () : os . mkdir ( spotdl_path ) return spotdl_path","title":"Notes"},{"location":"reference/spotdl/utils/config/#get_temp_path","text":"def get_temp_path ( ) -> pathlib . Path Get the path to the temp folder.","title":"get_temp_path"},{"location":"reference/spotdl/utils/config/#returns_5","text":"The path to the temp folder. View Source def get_temp_path () -> Path : \"\"\" Get the path to the temp folder. ### Returns - The path to the temp folder. \"\"\" temp_path = get_spotdl_path () / \"temp\" if not temp_path . exists () : os . mkdir ( temp_path ) return temp_path","title":"Returns"},{"location":"reference/spotdl/utils/config/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/utils/config/#configerror","text":"class ConfigError ( / , * args , ** kwargs ) View Source class ConfigError ( Exception ): \"\"\" Base class for all exceptions related to config. \"\"\"","title":"ConfigError"},{"location":"reference/spotdl/utils/config/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/config/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/utils/config/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/utils/config/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/utils/ffmpeg/","text":"Module spotdl.utils.ffmpeg Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found. View Source \"\"\" Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found. \"\"\" import os import re import shutil import subprocess import stat import platform import asyncio import shlex from typing import Any , Callable , Dict , List , Optional , Tuple , Union from pathlib import Path import requests from spotdl.utils.config import get_spotdl_path from spotdl.utils.formatter import to_ms FFMPEG_URLS = { \"windows\" : { \"amd64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/win32-x64\" , \"i686\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/win32-ia32\" , }, \"linux\" : { \"x86_64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-x64\" , \"x86\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-ia32\" , \"arm32\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-arm\" , \"aarch64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-arm64\" , }, \"darwin\" : { \"x86_64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/darwin-x64\" , \"arm\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/darwin-arm64\" , }, } FFMPEG_FORMATS = { \"mp3\" : [ \"-codec:a\" , \"libmp3lame\" ], \"flac\" : [ \"-codec:a\" , \"flac\" ], \"ogg\" : [ \"-codec:a\" , \"libvorbis\" ], \"opus\" : [ \"-codec:a\" , \"libopus\" ], \"m4a\" : [ \"-codec:a\" , \"aac\" ], } DUR_REGEX = re . compile ( r \"Duration: (?P<hour>\\d {2} ):(?P<min>\\d {2} ):(?P<sec>\\d {2} )\\.(?P<ms>\\d {2} )\" ) TIME_REGEX = re . compile ( r \"out_time=(?P<hour>\\d {2} ):(?P<min>\\d {2} ):(?P<sec>\\d {2} )\\.(?P<ms>\\d {2} )\" ) VERSION_REGEX = re . compile ( r \"ffmpeg version \\w?(\\d+\\.)?(\\d+)\" ) YEAR_REGEX = re . compile ( r \"Copyright \\(c\\) \\d\\d\\d\\d\\-\\d\\d\\d\\d\" ) class FFmpegError ( Exception ): \"\"\" Base class for all exceptions related to FFmpeg. \"\"\" def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK ) def get_ffmpeg_path () -> Optional [ Path ]: \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg () def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional [ float ], Optional [ int ]]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ): if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \" { ffmpeg } is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg , \"-version\" ], stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example: n4.3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example: Copyright (c) 2019-2020 build_years = [ int ( re . sub ( r \"[^0-9]\" , \"\" , year ) ) # remove all non numeric characters from string for year in year_result . group ( 0 ) . split ( \"-\" ) # split string into list of years ] # get the highest build year build_year = max ( build_years ) # No version and year was found, raise error if version is None and build_year is None : raise FFmpegError ( \"Could not get ffmpeg version.\" ) return ( version , build_year ) def get_local_ffmpeg () -> Optional [ Path ]: \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path (), \"ffmpeg\" + \".exe\" if platform . system () == \"Windows\" else \"\" ) if ffmpeg_path . is_file (): return ffmpeg_path return None def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path async def convert ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file asynchronously. ### Arguments - input_file: Path to input file or tuple of (url, file_format) - output_file: Path to output file - ffmpeg: ffmpeg executable to use - output_format: output format - variable_bitrate: variable bitrate - constant_bitrate: constant bitrate - ffmpeg_args: ffmpeg arguments ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg process = ( await asyncio . subprocess . create_subprocess_exec ( # pylint: disable=no-member ffmpeg , * arguments , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE , ) ) # Wait for process to finish proc_out = await process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ( proc_out ) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None def convert_sync ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], None ]] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - variable_bitrate: variable bitrate. - constant_bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : if output_format in [ \"m4a\" , \"opus\" ] and not ( bitrate or ffmpeg_args ): # Copy the audio stream to the output file arguments . extend ([ \"-vn\" , \"-c:a\" , \"copy\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg , * arguments ], stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ( proc_out ) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline () . decode ( \"utf-8\" , errors = \"replace\" ) . strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \" \\n \" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type: ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type: ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type: ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } progress_handler ( 100 ) return True , None Variables DUR_REGEX FFMPEG_FORMATS FFMPEG_URLS TIME_REGEX VERSION_REGEX YEAR_REGEX Functions convert def convert ( input_file : Union [ pathlib . Path , Tuple [ str , str ]], output_file : pathlib . Path , ffmpeg : str = 'ffmpeg' , output_format : str = 'mp3' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]] Convert the input file to the output file asynchronously. Arguments input_file: Path to input file or tuple of (url, file_format) output_file: Path to output file ffmpeg: ffmpeg executable to use output_format: output format variable_bitrate: variable bitrate constant_bitrate: constant bitrate ffmpeg_args: ffmpeg arguments Returns Tuple of conversion status and error dictionary. Notes Make sure to check if ffmpeg is installed before calling this function. View Source async def convert ( input_file : Union [ Path, Tuple[str, str ] ] , output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , ) -> Tuple [ bool, Optional[Dict[str, Any ] ]]: \"\"\" Convert the input file to the output file asynchronously. ### Arguments - input_file: Path to input file or tuple of (url, file_format) - output_file: Path to output file - ffmpeg: ffmpeg executable to use - output_format: output format - variable_bitrate: variable bitrate - constant_bitrate: constant bitrate - ffmpeg_args: ffmpeg arguments ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # - i is the input file arguments : List [ str ] = [ \"-nostdin\", \"-y\", \"-i\", str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0 ] , \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , ] file_format = ( str ( input_file . suffix ). split ( \".\" ) [ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # - c : a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ( [ \"-c:a\", \"libopus\" ] ) else : arguments . extend ( FFMPEG_FORMATS [ output_format ] ) # Add constant bitrate if specified if bitrate : arguments . extend ( [ \"-b:a\", bitrate ] ) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg process = ( await asyncio . subprocess . create_subprocess_exec ( # pylint : disable = no - member ffmpeg , * arguments , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE , ) ) # Wait for process to finish proc_out = await process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf - 8 message = b \"\" . join ( proc_out ). decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } return True , None convert_sync def convert_sync ( input_file : Union [ pathlib . Path , Tuple [ str , str ]], output_file : pathlib . Path , ffmpeg : str = 'ffmpeg' , output_format : str = 'mp3' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], NoneType ]] = None ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]] Convert the input file to the output file synchronously with progress handler. Arguments input_file: Path to input file or tuple of (url, file_format). output_file: Path to output file. ffmpeg: ffmpeg executable to use. output_format: output format. variable_bitrate: variable bitrate. constant_bitrate: constant bitrate. ffmpeg_args: ffmpeg arguments. progress_handler: progress handler, has to accept an integer as argument. Returns Tuple of conversion status and error dictionary. Notes Make sure to check if ffmpeg is installed before calling this function. View Source def convert_sync ( input_file : Union [ Path, Tuple[str, str ] ] , output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable[[int ] , None ]] = None , ) -> Tuple [ bool, Optional[Dict[str, Any ] ]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - variable_bitrate: variable bitrate. - constant_bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # - i is the input file arguments : List [ str ] = [ \"-nostdin\", \"-y\", \"-i\", str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0 ] , \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ). split ( \".\" ) [ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # - c : a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ( [ \"-c:a\", \"libopus\" ] ) else : if output_format in [ \"m4a\", \"opus\" ] and not ( bitrate or ffmpeg_args ) : # Copy the audio stream to the output file arguments . extend ( [ \"-vn\", \"-c:a\", \"copy\" ] ) else : arguments . extend ( FFMPEG_FORMATS [ output_format ] ) # Add constant bitrate if specified if bitrate : arguments . extend ( [ \"-b:a\", bitrate ] ) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg, *arguments ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf - 8 message = b \"\" . join ( proc_out ). decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline (). decode ( \"utf-8\" , errors = \"replace\" ). strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \"\\n\" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type : ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type : ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type : ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } progress_handler ( 100 ) return True , None download_ffmpeg def download_ffmpeg ( ) -> pathlib . Path Download ffmpeg binary to spotdl directory. Returns Path to ffmpeg binary. Notes ffmpeg is downloaded from github releases for current platform and architecture. executable permission is set for ffmpeg binary. View Source def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path get_ffmpeg_path def get_ffmpeg_path ( ) -> Optional [ pathlib . Path ] Get path to global ffmpeg binary or a local ffmpeg binary. Returns Path to ffmpeg binary or None if not found. View Source def get_ffmpeg_path () -> Optional [ Path ] : \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg () get_ffmpeg_version def get_ffmpeg_version ( ffmpeg : str = 'ffmpeg' ) -> Tuple [ Optional [ float ], Optional [ int ]] Get ffmpeg version. Arguments ffmpeg: ffmpeg executable to check Returns Tuple of optional version and optional year. Errors FFmpegError if ffmpeg is not installed. FFmpegError if ffmpeg version is not found. View Source def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional[float ] , Optional [ int ] ]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ) : if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \"{ffmpeg} is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg, \"-version\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example : n4 .3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example : Copyright ( c ) 2019 - 2020 build_years = [ int( re.sub(r\"[^0-9 ] \", \"\", year) ) # remove all non numeric characters from string for year in year_result.group(0).split( \" - \" ) # split string into list of years ] # get the highest build year build_year = max(build_years) # No version and year was found, raise error if version is None and build_year is None: raise FFmpegError(\" Could not get ffmpeg version . \" ) return ( version , build_year ) get_local_ffmpeg def get_local_ffmpeg ( ) -> Optional [ pathlib . Path ] Get local ffmpeg binary path. Returns Path to ffmpeg binary or None if not found. View Source def get_local_ffmpeg () -> Optional [ Path ] : \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path (), \"ffmpeg\" + \".exe\" if platform . system () == \"Windows\" else \"\" ) if ffmpeg_path . is_file () : return ffmpeg_path return None is_ffmpeg_installed def is_ffmpeg_installed ( ffmpeg : str = 'ffmpeg' ) -> bool Check if ffmpeg is installed. Arguments ffmpeg: ffmpeg executable to check Returns True if ffmpeg is installed, False otherwise. View Source def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK ) Classes FFmpegError class FFmpegError ( / , * args , ** kwargs ) View Source class FFmpegError ( Exception ): \"\"\" Base class for all exceptions related to FFmpeg. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Ffmpeg"},{"location":"reference/spotdl/utils/ffmpeg/#module-spotdlutilsffmpeg","text":"Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found. View Source \"\"\" Module for converting audio files to different formats and checking for ffmpeg binary, and downloading it if not found. \"\"\" import os import re import shutil import subprocess import stat import platform import asyncio import shlex from typing import Any , Callable , Dict , List , Optional , Tuple , Union from pathlib import Path import requests from spotdl.utils.config import get_spotdl_path from spotdl.utils.formatter import to_ms FFMPEG_URLS = { \"windows\" : { \"amd64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/win32-x64\" , \"i686\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/win32-ia32\" , }, \"linux\" : { \"x86_64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-x64\" , \"x86\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-ia32\" , \"arm32\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-arm\" , \"aarch64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/linux-arm64\" , }, \"darwin\" : { \"x86_64\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/darwin-x64\" , \"arm\" : \"https://github.com/eugeneware/ffmpeg-static/releases/download/b4.4/darwin-arm64\" , }, } FFMPEG_FORMATS = { \"mp3\" : [ \"-codec:a\" , \"libmp3lame\" ], \"flac\" : [ \"-codec:a\" , \"flac\" ], \"ogg\" : [ \"-codec:a\" , \"libvorbis\" ], \"opus\" : [ \"-codec:a\" , \"libopus\" ], \"m4a\" : [ \"-codec:a\" , \"aac\" ], } DUR_REGEX = re . compile ( r \"Duration: (?P<hour>\\d {2} ):(?P<min>\\d {2} ):(?P<sec>\\d {2} )\\.(?P<ms>\\d {2} )\" ) TIME_REGEX = re . compile ( r \"out_time=(?P<hour>\\d {2} ):(?P<min>\\d {2} ):(?P<sec>\\d {2} )\\.(?P<ms>\\d {2} )\" ) VERSION_REGEX = re . compile ( r \"ffmpeg version \\w?(\\d+\\.)?(\\d+)\" ) YEAR_REGEX = re . compile ( r \"Copyright \\(c\\) \\d\\d\\d\\d\\-\\d\\d\\d\\d\" ) class FFmpegError ( Exception ): \"\"\" Base class for all exceptions related to FFmpeg. \"\"\" def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK ) def get_ffmpeg_path () -> Optional [ Path ]: \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg () def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional [ float ], Optional [ int ]]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ): if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \" { ffmpeg } is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg , \"-version\" ], stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example: n4.3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example: Copyright (c) 2019-2020 build_years = [ int ( re . sub ( r \"[^0-9]\" , \"\" , year ) ) # remove all non numeric characters from string for year in year_result . group ( 0 ) . split ( \"-\" ) # split string into list of years ] # get the highest build year build_year = max ( build_years ) # No version and year was found, raise error if version is None and build_year is None : raise FFmpegError ( \"Could not get ffmpeg version.\" ) return ( version , build_year ) def get_local_ffmpeg () -> Optional [ Path ]: \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path (), \"ffmpeg\" + \".exe\" if platform . system () == \"Windows\" else \"\" ) if ffmpeg_path . is_file (): return ffmpeg_path return None def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path async def convert ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file asynchronously. ### Arguments - input_file: Path to input file or tuple of (url, file_format) - output_file: Path to output file - ffmpeg: ffmpeg executable to use - output_format: output format - variable_bitrate: variable bitrate - constant_bitrate: constant bitrate - ffmpeg_args: ffmpeg arguments ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg process = ( await asyncio . subprocess . create_subprocess_exec ( # pylint: disable=no-member ffmpeg , * arguments , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE , ) ) # Wait for process to finish proc_out = await process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ( proc_out ) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None def convert_sync ( input_file : Union [ Path , Tuple [ str , str ]], output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], None ]] = None , ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - variable_bitrate: variable bitrate. - constant_bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # -i is the input file arguments : List [ str ] = [ \"-nostdin\" , \"-y\" , \"-i\" , str ( input_file . resolve ()) if isinstance ( input_file , Path ) else input_file [ 0 ], \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ) . split ( \".\" )[ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # -c:a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ([ \"-c:a\" , \"libopus\" ]) else : if output_format in [ \"m4a\" , \"opus\" ] and not ( bitrate or ffmpeg_args ): # Copy the audio stream to the output file arguments . extend ([ \"-vn\" , \"-c:a\" , \"copy\" ]) else : arguments . extend ( FFMPEG_FORMATS [ output_format ]) # Add constant bitrate if specified if bitrate : arguments . extend ([ \"-b:a\" , bitrate ]) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg , * arguments ], stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf-8 message = b \"\" . join ( proc_out ) . decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline () . decode ( \"utf-8\" , errors = \"replace\" ) . strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \" \\n \" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type: ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type: ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type: ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ], \"build_year\" : version [ 1 ], } progress_handler ( 100 ) return True , None","title":"Module spotdl.utils.ffmpeg"},{"location":"reference/spotdl/utils/ffmpeg/#variables","text":"DUR_REGEX FFMPEG_FORMATS FFMPEG_URLS TIME_REGEX VERSION_REGEX YEAR_REGEX","title":"Variables"},{"location":"reference/spotdl/utils/ffmpeg/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/ffmpeg/#convert","text":"def convert ( input_file : Union [ pathlib . Path , Tuple [ str , str ]], output_file : pathlib . Path , ffmpeg : str = 'ffmpeg' , output_format : str = 'mp3' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]] Convert the input file to the output file asynchronously.","title":"convert"},{"location":"reference/spotdl/utils/ffmpeg/#arguments","text":"input_file: Path to input file or tuple of (url, file_format) output_file: Path to output file ffmpeg: ffmpeg executable to use output_format: output format variable_bitrate: variable bitrate constant_bitrate: constant bitrate ffmpeg_args: ffmpeg arguments","title":"Arguments"},{"location":"reference/spotdl/utils/ffmpeg/#returns","text":"Tuple of conversion status and error dictionary.","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#notes","text":"Make sure to check if ffmpeg is installed before calling this function. View Source async def convert ( input_file : Union [ Path, Tuple[str, str ] ] , output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , ) -> Tuple [ bool, Optional[Dict[str, Any ] ]]: \"\"\" Convert the input file to the output file asynchronously. ### Arguments - input_file: Path to input file or tuple of (url, file_format) - output_file: Path to output file - ffmpeg: ffmpeg executable to use - output_format: output format - variable_bitrate: variable bitrate - constant_bitrate: constant bitrate - ffmpeg_args: ffmpeg arguments ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # - i is the input file arguments : List [ str ] = [ \"-nostdin\", \"-y\", \"-i\", str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0 ] , \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , ] file_format = ( str ( input_file . suffix ). split ( \".\" ) [ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # - c : a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ( [ \"-c:a\", \"libopus\" ] ) else : arguments . extend ( FFMPEG_FORMATS [ output_format ] ) # Add constant bitrate if specified if bitrate : arguments . extend ( [ \"-b:a\", bitrate ] ) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg process = ( await asyncio . subprocess . create_subprocess_exec ( # pylint : disable = no - member ffmpeg , * arguments , stdout = asyncio . subprocess . PIPE , stderr = asyncio . subprocess . PIPE , ) ) # Wait for process to finish proc_out = await process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf - 8 message = b \"\" . join ( proc_out ). decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } return True , None","title":"Notes"},{"location":"reference/spotdl/utils/ffmpeg/#convert_sync","text":"def convert_sync ( input_file : Union [ pathlib . Path , Tuple [ str , str ]], output_file : pathlib . Path , ffmpeg : str = 'ffmpeg' , output_format : str = 'mp3' , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable [[ int ], NoneType ]] = None ) -> Tuple [ bool , Optional [ Dict [ str , Any ]]] Convert the input file to the output file synchronously with progress handler.","title":"convert_sync"},{"location":"reference/spotdl/utils/ffmpeg/#arguments_1","text":"input_file: Path to input file or tuple of (url, file_format). output_file: Path to output file. ffmpeg: ffmpeg executable to use. output_format: output format. variable_bitrate: variable bitrate. constant_bitrate: constant bitrate. ffmpeg_args: ffmpeg arguments. progress_handler: progress handler, has to accept an integer as argument.","title":"Arguments"},{"location":"reference/spotdl/utils/ffmpeg/#returns_1","text":"Tuple of conversion status and error dictionary.","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#notes_1","text":"Make sure to check if ffmpeg is installed before calling this function. View Source def convert_sync ( input_file : Union [ Path, Tuple[str, str ] ] , output_file : Path , ffmpeg : str = \"ffmpeg\" , output_format : str = \"mp3\" , bitrate : Optional [ str ] = None , ffmpeg_args : Optional [ str ] = None , progress_handler : Optional [ Callable[[int ] , None ]] = None , ) -> Tuple [ bool, Optional[Dict[str, Any ] ]]: \"\"\" Convert the input file to the output file synchronously with progress handler. ### Arguments - input_file: Path to input file or tuple of (url, file_format). - output_file: Path to output file. - ffmpeg: ffmpeg executable to use. - output_format: output format. - variable_bitrate: variable bitrate. - constant_bitrate: constant bitrate. - ffmpeg_args: ffmpeg arguments. - progress_handler: progress handler, has to accept an integer as argument. ### Returns - Tuple of conversion status and error dictionary. ### Notes - Make sure to check if ffmpeg is installed before calling this function. \"\"\" # Initialize ffmpeg command # - i is the input file arguments : List [ str ] = [ \"-nostdin\", \"-y\", \"-i\", str(input_file.resolve()) if isinstance(input_file, Path) else input_file[0 ] , \"-movflags\" , \"+faststart\" , \"-v\" , \"debug\" , \"-progress\" , \"-\" , \"-nostats\" , ] file_format = ( str ( input_file . suffix ). split ( \".\" ) [ 1 ] if isinstance ( input_file , Path ) else input_file [ 1 ] ) # Add output format to command # - c : a is used if the file is not an matroska container # and we want to convert to opus # otherwise we use arguments from FFMPEG_FORMATS if output_format == \"opus\" and file_format != \"webm\" : arguments . extend ( [ \"-c:a\", \"libopus\" ] ) else : if output_format in [ \"m4a\", \"opus\" ] and not ( bitrate or ffmpeg_args ) : # Copy the audio stream to the output file arguments . extend ( [ \"-vn\", \"-c:a\", \"copy\" ] ) else : arguments . extend ( FFMPEG_FORMATS [ output_format ] ) # Add constant bitrate if specified if bitrate : arguments . extend ( [ \"-b:a\", bitrate ] ) # Add other ffmpeg arguments if specified if ffmpeg_args : arguments . extend ( shlex . split ( ffmpeg_args )) # Add output file at the end arguments . append ( str ( output_file . resolve ())) # Run ffmpeg with subprocess . Popen ( [ ffmpeg, *arguments ] , stdin = subprocess . PIPE , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , universal_newlines = False , ) as process : if not progress_handler : # Wait for process to finish proc_out = process . communicate () if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) # join stdout and stderr and decode to utf - 8 message = b \"\" . join ( proc_out ). decode ( \"utf-8\" ) # return error dictionary return False , { \"error\" : message , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } return True , None progress_handler ( 0 ) stderr_buffer = [] total_dur = None stderr : str = \"\" while True : if process . stdout is None : continue stderr_line = ( process . stdout . readline (). decode ( \"utf-8\" , errors = \"replace\" ). strip () ) if stderr_line == \"\" and process . poll () is not None : break stderr_buffer . append ( stderr_line . strip ()) stderr = \"\\n\" . join ( stderr_buffer ) total_dur_match = DUR_REGEX . search ( stderr_line ) if total_dur is None and total_dur_match : total_dur = to_ms ( ** total_dur_match . groupdict ()) # type : ignore continue if total_dur : progress_time = TIME_REGEX . search ( stderr_line ) if progress_time : elapsed_time = to_ms ( ** progress_time . groupdict ()) # type : ignore progress_handler ( int ( elapsed_time / total_dur * 100 )) # type : ignore if process . returncode != 0 : # get version and build year version = get_ffmpeg_version ( ffmpeg ) return False , { \"error\" : stderr , \"arguments\" : arguments , \"ffmpeg\" : ffmpeg , \"version\" : version [ 0 ] , \"build_year\" : version [ 1 ] , } progress_handler ( 100 ) return True , None","title":"Notes"},{"location":"reference/spotdl/utils/ffmpeg/#download_ffmpeg","text":"def download_ffmpeg ( ) -> pathlib . Path Download ffmpeg binary to spotdl directory.","title":"download_ffmpeg"},{"location":"reference/spotdl/utils/ffmpeg/#returns_2","text":"Path to ffmpeg binary.","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#notes_2","text":"ffmpeg is downloaded from github releases for current platform and architecture. executable permission is set for ffmpeg binary. View Source def download_ffmpeg () -> Path : \"\"\" Download ffmpeg binary to spotdl directory. ### Returns - Path to ffmpeg binary. ### Notes - ffmpeg is downloaded from github releases for current platform and architecture. - executable permission is set for ffmpeg binary. \"\"\" os_name = platform . system () . lower () os_arch = platform . machine () . lower () ffmpeg_url = FFMPEG_URLS . get ( os_name , {}) . get ( os_arch ) ffmpeg_path = Path ( os . path . join ( get_spotdl_path (), \"ffmpeg\" + ( \".exe\" if os_name == \"windows\" else \"\" ) ) ) if ffmpeg_url is None : raise FFmpegError ( \"FFmpeg binary is not available for your system.\" ) # Download binary and save it to a file in spotdl directory ffmpeg_binary = requests . get ( ffmpeg_url , allow_redirects = True ) . content with open ( ffmpeg_path , \"wb\" ) as ffmpeg_file : ffmpeg_file . write ( ffmpeg_binary ) # Set executable permission on linux and mac if os_name in [ \"linux\" , \"darwin\" ]: ffmpeg_path . chmod ( ffmpeg_path . stat () . st_mode | stat . S_IEXEC ) return ffmpeg_path","title":"Notes"},{"location":"reference/spotdl/utils/ffmpeg/#get_ffmpeg_path","text":"def get_ffmpeg_path ( ) -> Optional [ pathlib . Path ] Get path to global ffmpeg binary or a local ffmpeg binary.","title":"get_ffmpeg_path"},{"location":"reference/spotdl/utils/ffmpeg/#returns_3","text":"Path to ffmpeg binary or None if not found. View Source def get_ffmpeg_path () -> Optional [ Path ] : \"\"\" Get path to global ffmpeg binary or a local ffmpeg binary. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" # Check if ffmpeg is installed global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg : return Path ( global_ffmpeg ) # Get local ffmpeg path return get_local_ffmpeg ()","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#get_ffmpeg_version","text":"def get_ffmpeg_version ( ffmpeg : str = 'ffmpeg' ) -> Tuple [ Optional [ float ], Optional [ int ]] Get ffmpeg version.","title":"get_ffmpeg_version"},{"location":"reference/spotdl/utils/ffmpeg/#arguments_2","text":"ffmpeg: ffmpeg executable to check","title":"Arguments"},{"location":"reference/spotdl/utils/ffmpeg/#returns_4","text":"Tuple of optional version and optional year.","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#errors","text":"FFmpegError if ffmpeg is not installed. FFmpegError if ffmpeg version is not found. View Source def get_ffmpeg_version ( ffmpeg : str = \"ffmpeg\" ) -> Tuple [ Optional[float ] , Optional [ int ] ]: \"\"\" Get ffmpeg version. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - Tuple of optional version and optional year. ### Errors - FFmpegError if ffmpeg is not installed. - FFmpegError if ffmpeg version is not found. \"\"\" # Check if ffmpeg is installed if not is_ffmpeg_installed ( ffmpeg ) : if ffmpeg == \"ffmpeg\" : raise FFmpegError ( \"ffmpeg is not installed.\" ) raise FFmpegError ( f \"{ffmpeg} is not a valid ffmpeg executable.\" ) with subprocess . Popen ( [ ffmpeg, \"-version\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE , encoding = \"utf-8\" , ) as process : output = \"\" . join ( process . communicate ()) # Search for version and build year in output version_result = VERSION_REGEX . search ( output ) year_result = YEAR_REGEX . search ( output ) build_year = None version = None if version_result is not None : # remove all non numeric characters from string example : n4 .3 version_str = re . sub ( r \"[a-zA-Z]\" , \"\" , version_result . group ( 0 )) # parse version string to float version = float ( version_str ) if version_str else None if year_result is not None : # get build years from string example : Copyright ( c ) 2019 - 2020 build_years = [ int( re.sub(r\"[^0-9 ] \", \"\", year) ) # remove all non numeric characters from string for year in year_result.group(0).split( \" - \" ) # split string into list of years ] # get the highest build year build_year = max(build_years) # No version and year was found, raise error if version is None and build_year is None: raise FFmpegError(\" Could not get ffmpeg version . \" ) return ( version , build_year )","title":"Errors"},{"location":"reference/spotdl/utils/ffmpeg/#get_local_ffmpeg","text":"def get_local_ffmpeg ( ) -> Optional [ pathlib . Path ] Get local ffmpeg binary path.","title":"get_local_ffmpeg"},{"location":"reference/spotdl/utils/ffmpeg/#returns_5","text":"Path to ffmpeg binary or None if not found. View Source def get_local_ffmpeg () -> Optional [ Path ] : \"\"\" Get local ffmpeg binary path. ### Returns - Path to ffmpeg binary or None if not found. \"\"\" ffmpeg_path = Path ( get_spotdl_path (), \"ffmpeg\" + \".exe\" if platform . system () == \"Windows\" else \"\" ) if ffmpeg_path . is_file () : return ffmpeg_path return None","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#is_ffmpeg_installed","text":"def is_ffmpeg_installed ( ffmpeg : str = 'ffmpeg' ) -> bool Check if ffmpeg is installed.","title":"is_ffmpeg_installed"},{"location":"reference/spotdl/utils/ffmpeg/#arguments_3","text":"ffmpeg: ffmpeg executable to check","title":"Arguments"},{"location":"reference/spotdl/utils/ffmpeg/#returns_6","text":"True if ffmpeg is installed, False otherwise. View Source def is_ffmpeg_installed ( ffmpeg : str = \"ffmpeg\" ) -> bool : \"\"\" Check if ffmpeg is installed. ### Arguments - ffmpeg: ffmpeg executable to check ### Returns - True if ffmpeg is installed, False otherwise. \"\"\" if ffmpeg == \"ffmpeg\" : global_ffmpeg = shutil . which ( \"ffmpeg\" ) if global_ffmpeg is None : ffmpeg_path = get_ffmpeg_path () else : ffmpeg_path = Path ( global_ffmpeg ) else : ffmpeg_path = Path ( ffmpeg ) if ffmpeg_path is None : return False # else check if path to ffmpeg is valid # and if ffmpeg has the correct access rights return ffmpeg_path . exists () and os . access ( ffmpeg_path , os . X_OK )","title":"Returns"},{"location":"reference/spotdl/utils/ffmpeg/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/utils/ffmpeg/#ffmpegerror","text":"class FFmpegError ( / , * args , ** kwargs ) View Source class FFmpegError ( Exception ): \"\"\" Base class for all exceptions related to FFmpeg. \"\"\"","title":"FFmpegError"},{"location":"reference/spotdl/utils/ffmpeg/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/ffmpeg/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/utils/ffmpeg/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/utils/ffmpeg/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/utils/formatter/","text":"Module spotdl.utils.formatter Module for formatting songs into strings. Contains functions to create search queries and song titles and file names. View Source \"\"\" Module for formatting songs into strings. Contains functions to create search queries and song titles and file names. \"\"\" import re import warnings from typing import List , Optional from pathlib import Path from yt_dlp.utils import sanitize_filename from spotdl.types import Song VARS = [ \" {title} \" , \" {artists} \" , \" {artist} \" , \" {album} \" , \"{album-artist}\" , \" {genre} \" , \"{disc-number}\" , \"{disc-count}\" , \" {duration} \" , \" {year} \" , \"{original-date}\" , \"{track-number}\" , \"{tracks-count}\" , \" {isrc} \" , \"{track-id}\" , \" {publisher} \" , \"{list-length}\" , \"{list-position}\" , \"{list-name}\" , \"{output-ext}\" , ] def create_song_title ( song_name : str , song_artists : List [ str ]) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \"Artist1, Artist2 - Song Name\" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \" { joined_artists } - { song_name } \" return song_name def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific (disallowed chars) output = \"\" . join ( char for char in output if char not in \"/? \\\\ *|<>\" ) # double quotes (\") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren't removed in the prior loop output = output . replace ( '\"' , \"'\" ) . replace ( \":\" , \"-\" ) return output def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]) and song . song_list is None ): # If the template contains {list-length} or {list-position} or {list-name}, # but the song_list is None, replace them with empty strings for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]: template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only {output-ext}, fix it # This can happen if the template consits of only list values # and song.song_list is None if template in [ \"/.{output-ext}\" , \".{output-ext}\" ]: template = \" {artists} - {title} .{output-ext}\" artists = \", \" . join ( song . artists ) # the code below is valid, song_list is actually checked for None formats = { \" {title} \" : song . name , \" {artists} \" : song . artists [ 0 ] if short is True else artists , \" {artist} \" : song . artists [ 0 ], \" {album} \" : song . album_name , \"{album-artist}\" : song . album_artist , \" {genre} \" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \" {duration} \" : song . duration , \" {year} \" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \" {isrc} \" : song . isrc , \"{track-id}\" : song . song_id , \" {publisher} \" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ] ): try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type: ignore \"{list-position}\" : str ( index + 1 ) . zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items (): if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items (): template = template . replace ( key , str ( value )) return template def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys, # append {artist} - {title} at the beggining of the template if not any ( key in template for key in VARS ): template = \" {artist} - {title} \" + template return format_query ( song , template , santitize , file_extension , short = short ) def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \"\"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\"\" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ): template += \"/ {artists} - {title} .{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ): template += \"/ {artists} - {title} .{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ): template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^\\.*](.*)[^\\.*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( \"`short` is True, but the file name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/ {artist} - {title} .{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/ {artist} - {title} .{output-ext}\" : raise RecursionError ( f '\" { song . display_name } is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file def parse_duration ( duration : Optional [ str ]) -> float : \"\"\" Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # {(1, \"s\"), (60, \"m\"), (3600, \"h\")} mapped_increments = zip ([ 1 , 60 , 3600 ], reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ): return 0.0 def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. - If \"precision\" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0 : 2 ]) minute = int ( string [ 3 : 5 ]) sec = int ( string [ 6 : 8 ]) milliseconds = int ( string [ 10 : 11 ]) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ): return round ( result , precision ) return result def restrict_filename ( pathobj : Path ) -> Path : \"\"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\"\" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result ) Variables VARS Functions create_file_name def create_file_name ( song : spotdl . types . song . Song , template : str , file_extension : str , short : bool = False ) -> pathlib . Path Create the file name for the song, by replacing template variables with the actual values. Arguments song: the song object template: the template string file_extension: the file extension to use short: whether to use the short version of the template Returns the formatted string as a Path object View Source def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \" \"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\" \" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ) : template += \"/{artists} - {title}.{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ) : template += \"/{artists} - {title}.{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ) : template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^ \\ .*](.*)[^ \\ .*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( \"`short` is True, but the file name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/{artist} - {title}.{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/{artist} - {title}.{output-ext}\" : raise RecursionError ( f '\"{song.display_name} is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file create_search_query def create_search_query ( song : spotdl . types . song . Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False ) -> str Create the search query for the song. Arguments song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template Returns the formatted string View Source def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys , # append { artist } - { title } at the beggining of the template if not any ( key in template for key in VARS ) : template = \"{artist} - {title}\" + template return format_query ( song , template , santitize , file_extension , short = short ) create_song_title def create_song_title ( song_name : str , song_artists : List [ str ] ) -> str Create the song title. Arguments song_name: the name of the song song_artists: the list of artists of the song Returns the song title Notes Example: \"Artist1, Artist2 - Song Name\" View Source def create_song_title ( song_name : str , song_artists : List [ str ] ) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \" Artist1 , Artist2 - Song Name \" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \"{joined_artists} - {song_name}\" return song_name format_query def format_query ( song : spotdl . types . song . Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False ) -> str Replace template variables with the actual values. Arguments song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template Returns the formatted string View Source def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] ) and song . song_list is None ) : # If the template contains { list - length } or { list - position } or { list - name } , # but the song_list is None , replace them with empty strings for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] : template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only { output - ext } , fix it # This can happen if the template consits of only list values # and song . song_list is None if template in [ \"/.{output-ext}\", \".{output-ext}\" ] : template = \"{artists} - {title}.{output-ext}\" artists = \", \" . join ( song . artists ) # the code below is valid , song_list is actually checked for None formats = { \"{title}\" : song . name , \"{artists}\" : song . artists [ 0 ] if short is True else artists , \"{artist}\" : song . artists [ 0 ] , \"{album}\" : song . album_name , \"{album-artist}\" : song . album_artist , \"{genre}\" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \"{duration}\" : song . duration , \"{year}\" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \"{isrc}\" : song . isrc , \"{track-id}\" : song . song_id , \"{publisher}\" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] ) : try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type : ignore \"{list-position}\" : str ( index + 1 ). zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items () : if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items () : template = template . replace ( key , str ( value )) return template parse_duration def parse_duration ( duration : Optional [ str ] ) -> float Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) Arguments duration: the string value of time Returns the float value of seconds View Source def parse_duration ( duration : Optional [ str ] ) -> float : \"\"\" Convert string value of time (duration: \" 25 : 36 : 59 \") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # { ( 1 , \"s\" ), ( 60 , \"m\" ), ( 3600 , \"h\" ) } mapped_increments = zip ( [ 1, 60, 3600 ] , reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ) : return 0.0 restrict_filename def restrict_filename ( pathobj : pathlib . Path ) -> pathlib . Path Sanitizes the filename part of a Path object. Returns modified object. Arguments pathobj: the Path object to sanitize Returns the modified Path object Notes Based on the sanitize_filename function from yt-dlp View Source def restrict_filename ( pathobj : Path ) -> Path : \" \"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\" \" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result ) sanitize_string def sanitize_string ( string : str ) -> str Sanitize the filename to be used in the file system. Arguments string: the string to sanitize Returns the sanitized string View Source def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific ( disallowed chars ) output = \"\" . join ( char for char in output if char not in \"/?\\\\*|<>\" ) # double quotes ( \") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren' t removed in the prior loop output = output . replace ( '\"', \"'\" ). replace ( \":\" , \"-\" ) return output to_ms def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float Convert a string to milliseconds. Arguments string: the string to convert precision: the number of decimals to round to kwargs: the keyword args to convert Returns the milliseconds Notes You can either pass a string, or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. If \"precision\" is set, the result is rounded to the number of decimals given. From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 View Source def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\" hour \", \" min \", \" sec \", \" ms \") to convert. - If \" precision \" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0:2 ] ) minute = int ( string [ 3:5 ] ) sec = int ( string [ 6:8 ] ) milliseconds = int ( string [ 10:11 ] ) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ) : return round ( result , precision ) return result","title":"Formatter"},{"location":"reference/spotdl/utils/formatter/#module-spotdlutilsformatter","text":"Module for formatting songs into strings. Contains functions to create search queries and song titles and file names. View Source \"\"\" Module for formatting songs into strings. Contains functions to create search queries and song titles and file names. \"\"\" import re import warnings from typing import List , Optional from pathlib import Path from yt_dlp.utils import sanitize_filename from spotdl.types import Song VARS = [ \" {title} \" , \" {artists} \" , \" {artist} \" , \" {album} \" , \"{album-artist}\" , \" {genre} \" , \"{disc-number}\" , \"{disc-count}\" , \" {duration} \" , \" {year} \" , \"{original-date}\" , \"{track-number}\" , \"{tracks-count}\" , \" {isrc} \" , \"{track-id}\" , \" {publisher} \" , \"{list-length}\" , \"{list-position}\" , \"{list-name}\" , \"{output-ext}\" , ] def create_song_title ( song_name : str , song_artists : List [ str ]) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \"Artist1, Artist2 - Song Name\" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \" { joined_artists } - { song_name } \" return song_name def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific (disallowed chars) output = \"\" . join ( char for char in output if char not in \"/? \\\\ *|<>\" ) # double quotes (\") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren't removed in the prior loop output = output . replace ( '\"' , \"'\" ) . replace ( \":\" , \"-\" ) return output def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]) and song . song_list is None ): # If the template contains {list-length} or {list-position} or {list-name}, # but the song_list is None, replace them with empty strings for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ]: template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only {output-ext}, fix it # This can happen if the template consits of only list values # and song.song_list is None if template in [ \"/.{output-ext}\" , \".{output-ext}\" ]: template = \" {artists} - {title} .{output-ext}\" artists = \", \" . join ( song . artists ) # the code below is valid, song_list is actually checked for None formats = { \" {title} \" : song . name , \" {artists} \" : song . artists [ 0 ] if short is True else artists , \" {artist} \" : song . artists [ 0 ], \" {album} \" : song . album_name , \"{album-artist}\" : song . album_artist , \" {genre} \" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \" {duration} \" : song . duration , \" {year} \" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \" {isrc} \" : song . isrc , \"{track-id}\" : song . song_id , \" {publisher} \" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\" , \"{list-position}\" , \"{list-name}\" ] ): try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type: ignore \"{list-position}\" : str ( index + 1 ) . zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items (): if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items (): template = template . replace ( key , str ( value )) return template def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys, # append {artist} - {title} at the beggining of the template if not any ( key in template for key in VARS ): template = \" {artist} - {title} \" + template return format_query ( song , template , santitize , file_extension , short = short ) def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \"\"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\"\" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ): template += \"/ {artists} - {title} .{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ): template += \"/ {artists} - {title} .{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ): template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^\\.*](.*)[^\\.*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( \"`short` is True, but the file name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/ {artist} - {title} .{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/ {artist} - {title} .{output-ext}\" : raise RecursionError ( f '\" { song . display_name } is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file def parse_duration ( duration : Optional [ str ]) -> float : \"\"\" Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # {(1, \"s\"), (60, \"m\"), (3600, \"h\")} mapped_increments = zip ([ 1 , 60 , 3600 ], reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ): return 0.0 def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. - If \"precision\" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0 : 2 ]) minute = int ( string [ 3 : 5 ]) sec = int ( string [ 6 : 8 ]) milliseconds = int ( string [ 10 : 11 ]) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ): return round ( result , precision ) return result def restrict_filename ( pathobj : Path ) -> Path : \"\"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\"\" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result )","title":"Module spotdl.utils.formatter"},{"location":"reference/spotdl/utils/formatter/#variables","text":"VARS","title":"Variables"},{"location":"reference/spotdl/utils/formatter/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/formatter/#create_file_name","text":"def create_file_name ( song : spotdl . types . song . Song , template : str , file_extension : str , short : bool = False ) -> pathlib . Path Create the file name for the song, by replacing template variables with the actual values.","title":"create_file_name"},{"location":"reference/spotdl/utils/formatter/#arguments","text":"song: the song object template: the template string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns","text":"the formatted string as a Path object View Source def create_file_name ( song : Song , template : str , file_extension : str , short : bool = False , ) -> Path : \" \"\" Create the file name for the song, by replacing template variables with the actual values. ### Arguments - song: the song object - template: the template string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string as a Path object \"\" \" # If template does not contain any of the keys, # append {artists} - {title}.{output-ext} to it if not any ( key in template for key in VARS ) : template += \"/{artists} - {title}.{output-ext}\" # If template ends with a slash. Does not have a file name with extension # at the end of the template, append {artists} - {title}.{output-ext} to it if template . endswith ( \"/\" ) or template . endswith ( r \" \\\\ \" ) or template . endswith ( \" \\\\\\\\ \" ) : template += \"/{artists} - {title}.{output-ext}\" # If template does not end with {output-ext}, append it to the end of the template if not template . endswith ( \".{output-ext}\" ) : template += \".{output-ext}\" formatted_string = format_query ( song = song , template = template , santitize = True , file_extension = file_extension , short = short , ) # Parse template as Path object file = Path ( formatted_string ) santitized_parts = [] for part in file . parts : match = re . search ( r \"[^ \\ .*](.*)[^ \\ .*$]\" , part ) if match and part != \".spotdl\" : santitized_parts . append ( match . group ( 0 )) else : santitized_parts . append ( part ) # Join the parts of the path file = Path ( * santitized_parts ) # Check if the file name length is greater than 255 if len ( file . name ) > 255 : # If the file name length is greater than 255, # and we are already using the short version of the template, # fallback to default template if short is True : warnings . warn ( \"`short` is True, but the file name is too long. Using the default template.\" ) return create_file_name ( song = song , template = \"/{artist} - {title}.{output-ext}\" , file_extension = file_extension , short = short , ) # This will probably never occur, but just in case if short is True and template == \"/{artist} - {title}.{output-ext}\" : raise RecursionError ( f '\"{song.display_name} is too long to be shortened. File a bug report on GitHub' ) return create_file_name ( song , template , file_extension , short = True , ) return file","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#create_search_query","text":"def create_search_query ( song : spotdl . types . song . Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False ) -> str Create the search query for the song.","title":"create_search_query"},{"location":"reference/spotdl/utils/formatter/#arguments_1","text":"song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_1","text":"the formatted string View Source def create_search_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Create the search query for the song. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" # If template does not contain any of the keys , # append { artist } - { title } at the beggining of the template if not any ( key in template for key in VARS ) : template = \"{artist} - {title}\" + template return format_query ( song , template , santitize , file_extension , short = short )","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#create_song_title","text":"def create_song_title ( song_name : str , song_artists : List [ str ] ) -> str Create the song title.","title":"create_song_title"},{"location":"reference/spotdl/utils/formatter/#arguments_2","text":"song_name: the name of the song song_artists: the list of artists of the song","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_2","text":"the song title","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#notes","text":"Example: \"Artist1, Artist2 - Song Name\" View Source def create_song_title ( song_name : str , song_artists : List [ str ] ) -> str : \"\"\" Create the song title. ### Arguments - song_name: the name of the song - song_artists: the list of artists of the song ### Returns - the song title ### Notes - Example: \" Artist1 , Artist2 - Song Name \" \"\"\" joined_artists = \", \" . join ( song_artists ) if len ( song_artists ) >= 1 : return f \"{joined_artists} - {song_name}\" return song_name","title":"Notes"},{"location":"reference/spotdl/utils/formatter/#format_query","text":"def format_query ( song : spotdl . types . song . Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False ) -> str Replace template variables with the actual values.","title":"format_query"},{"location":"reference/spotdl/utils/formatter/#arguments_3","text":"song: the song object template: the template string santitize: whether to sanitize the string file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_3","text":"the formatted string View Source def format_query ( song : Song , template : str , santitize : bool , file_extension : Optional [ str ] = None , short : bool = False , ) -> str : \"\"\" Replace template variables with the actual values. ### Arguments - song: the song object - template: the template string - santitize: whether to sanitize the string - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the formatted string \"\"\" if \"{output-ext}\" in template and file_extension is None : raise ValueError ( \"file_extension is None, but template contains {output-ext}\" ) if ( any ( k in template for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] ) and song . song_list is None ) : # If the template contains { list - length } or { list - position } or { list - name } , # but the song_list is None , replace them with empty strings for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] : template = template . replace ( k , \"\" ) template = template . replace ( r \"//\" , r \"/\" ) # If template has only { output - ext } , fix it # This can happen if the template consits of only list values # and song . song_list is None if template in [ \"/.{output-ext}\", \".{output-ext}\" ] : template = \"{artists} - {title}.{output-ext}\" artists = \", \" . join ( song . artists ) # the code below is valid , song_list is actually checked for None formats = { \"{title}\" : song . name , \"{artists}\" : song . artists [ 0 ] if short is True else artists , \"{artist}\" : song . artists [ 0 ] , \"{album}\" : song . album_name , \"{album-artist}\" : song . album_artist , \"{genre}\" : song . genres [ 0 ] if len ( song . genres ) > 0 else \"\" , \"{disc-number}\" : song . disc_number , \"{disc-count}\" : song . disc_count , \"{duration}\" : song . duration , \"{year}\" : song . year , \"{original-date}\" : song . date , \"{track-number}\" : song . track_number , \"{tracks-count}\" : song . tracks_count , \"{isrc}\" : song . isrc , \"{track-id}\" : song . song_id , \"{publisher}\" : song . publisher , \"{output-ext}\" : file_extension , } if song . song_list and any ( k in template for k in [ \"{list-length}\", \"{list-position}\", \"{list-name}\" ] ) : try : index = song . song_list . songs . index ( song ) except ValueError : index = song . song_list . urls . index ( song . url ) formats . update ( { \"{list-name}\" : song . song_list . name , # type : ignore \"{list-position}\" : str ( index + 1 ). zfill ( len ( str ( song . song_list . length )) ), \"{list-length}\" : song . song_list . length , } ) if santitize : # sanitize the values in formats dict for key , value in formats . items () : if value is None : continue formats [ key ] = sanitize_string ( str ( value )) # Replace all the keys with the values for key , value in formats . items () : template = template . replace ( key , str ( value )) return template","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#parse_duration","text":"def parse_duration ( duration : Optional [ str ] ) -> float Convert string value of time (duration: \"25:36:59\") to a float value of seconds (92219.0)","title":"parse_duration"},{"location":"reference/spotdl/utils/formatter/#arguments_4","text":"duration: the string value of time","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_4","text":"the float value of seconds View Source def parse_duration ( duration : Optional [ str ] ) -> float : \"\"\" Convert string value of time (duration: \" 25 : 36 : 59 \") to a float value of seconds (92219.0) ### Arguments - duration: the string value of time ### Returns - the float value of seconds \"\"\" if duration is None : return 0.0 try : # { ( 1 , \"s\" ), ( 60 , \"m\" ), ( 3600 , \"h\" ) } mapped_increments = zip ( [ 1, 60, 3600 ] , reversed ( duration . split ( \":\" ))) seconds = sum ( multiplier * int ( time ) for multiplier , time in mapped_increments ) return float ( seconds ) # This usually occurs when the wrong string is mistaken for the duration except ( ValueError , TypeError , AttributeError ) : return 0.0","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#restrict_filename","text":"def restrict_filename ( pathobj : pathlib . Path ) -> pathlib . Path Sanitizes the filename part of a Path object. Returns modified object.","title":"restrict_filename"},{"location":"reference/spotdl/utils/formatter/#arguments_5","text":"pathobj: the Path object to sanitize","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_5","text":"the modified Path object","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#notes_1","text":"Based on the sanitize_filename function from yt-dlp View Source def restrict_filename ( pathobj : Path ) -> Path : \" \"\" Sanitizes the filename part of a Path object. Returns modified object. ### Arguments - pathobj: the Path object to sanitize ### Returns - the modified Path object ### Notes - Based on the `sanitize_filename` function from yt-dlp \"\" \" result = sanitize_filename ( pathobj . name , True , False ) result = result . replace ( \"_-_\" , \"-\" ) if not result : result = \"_\" return pathobj . with_name ( result )","title":"Notes"},{"location":"reference/spotdl/utils/formatter/#sanitize_string","text":"def sanitize_string ( string : str ) -> str Sanitize the filename to be used in the file system.","title":"sanitize_string"},{"location":"reference/spotdl/utils/formatter/#arguments_6","text":"string: the string to sanitize","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_6","text":"the sanitized string View Source def sanitize_string ( string : str ) -> str : \"\"\" Sanitize the filename to be used in the file system. ### Arguments - string: the string to sanitize ### Returns - the sanitized string \"\"\" output = string # this is windows specific ( disallowed chars ) output = \"\" . join ( char for char in output if char not in \"/?\\\\*|<>\" ) # double quotes ( \") and semi-colons (:) are also disallowed characters but we would # like to retain their equivalents, so they aren' t removed in the prior loop output = output . replace ( '\"', \"'\" ). replace ( \":\" , \"-\" ) return output","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#to_ms","text":"def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float Convert a string to milliseconds.","title":"to_ms"},{"location":"reference/spotdl/utils/formatter/#arguments_7","text":"string: the string to convert precision: the number of decimals to round to kwargs: the keyword args to convert","title":"Arguments"},{"location":"reference/spotdl/utils/formatter/#returns_7","text":"the milliseconds","title":"Returns"},{"location":"reference/spotdl/utils/formatter/#notes_2","text":"You can either pass a string, or a set of keyword args (\"hour\", \"min\", \"sec\", \"ms\") to convert. If \"precision\" is set, the result is rounded to the number of decimals given. From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 View Source def to_ms ( string : Optional [ str ] = None , precision : Optional [ int ] = None , ** kwargs ) -> float : \"\"\" Convert a string to milliseconds. ### Arguments - string: the string to convert - precision: the number of decimals to round to - kwargs: the keyword args to convert ### Returns - the milliseconds ### Notes - You can either pass a string, - or a set of keyword args (\" hour \", \" min \", \" sec \", \" ms \") to convert. - If \" precision \" is set, the result is rounded to the number of decimals given. - From: https://gist.github.com/Hellowlol/5f8545e999259b4371c91ac223409209 \"\"\" if string : hour = int ( string [ 0:2 ] ) minute = int ( string [ 3:5 ] ) sec = int ( string [ 6:8 ] ) milliseconds = int ( string [ 10:11 ] ) else : hour = int ( kwargs . get ( \"hour\" , 0 )) minute = int ( kwargs . get ( \"min\" , 0 )) sec = int ( kwargs . get ( \"sec\" , 0 )) milliseconds = int ( kwargs . get ( \"ms\" , 0 )) result = ( ( hour * 60 * 60 * 1000 ) + ( minute * 60 * 1000 ) + ( sec * 1000 ) + milliseconds ) if precision and isinstance ( precision , int ) : return round ( result , precision ) return result","title":"Notes"},{"location":"reference/spotdl/utils/github/","text":"Module spotdl.utils.github Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates. View Source \"\"\" Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates. \"\"\" from typing import Tuple import re import os import requests from spotdl import _version REPO = \"spotdl/spotify-downloader\" WEB_APP_URL = \"https://github.com/spotdl/web-ui/tree/master/dist\" def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/ { repo } /compare/ { start } ... { end } \" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], ) def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/ { repo } /releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v { _version . __version__ } \" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: { latest_version } . \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \" { name } is { status } by { behind_by } commits. \\n \" elif status == \"ahead\" : message += f \" { name } is { status } by { ahead_by } commits. \\n \" else : message += f \" { name } is up to date. \\n \" return message def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" ) def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ): \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ) . json () if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ])) else : path = os . path . join ( dir_out , file [ \"path\" ]) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ) . content ) else : download_github_dir ( file [ \"html_url\" ], flatten , output_dir ) Variables REPO WEB_APP_URL Functions check_for_updates def check_for_updates ( repo : str = 'spotdl/spotify-downloader' ) -> str Check for updates to the current version. Arguments repo: the repo to check (defaults to spotdl/spotify-downloader) Returns the latest version View Source def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/{repo}/releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: {response.status_code}\" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v{_version.__version__}\" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: {latest_version}. \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \"{name} is {status} by {behind_by} commits. \\n \" elif status == \"ahead\" : message += f \"{name} is {status} by {ahead_by} commits. \\n \" else : message += f \"{name} is up to date. \\n \" return message create_github_url def create_github_url ( url : str = 'https://github.com/spotdl/web-ui/tree/master/dist' ) From the given url, produce a URL that is compatible with Github's REST API. Arguments url: the url to convert Notes Can handle blob or tree paths. View Source def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" ) download_github_dir def download_github_dir ( repo_url : str = 'https://github.com/spotdl/web-ui/tree/master/dist' , flatten : bool = False , output_dir : str = './' ) Downloads the files and directories in repo_url. Arguments repo_url: the url to the repo to download flatten: whether to flatten the directory structure output_dir: the directory to download the files to Notes Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py View Source def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ) : \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ). json () if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ] )) else : path = os . path . join ( dir_out , file [ \"path\" ] ) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ). content ) else : download_github_dir ( file [ \"html_url\" ] , flatten , output_dir ) get_status def get_status ( start : str , end : str , repo : str = 'spotdl/spotify-downloader' ) -> Tuple [ str , int , int ] Get the status of a commit range. Arguments start: the starting commit/branch/tag end: the ending commit/branch/tag repo: the repo to check (defaults to spotdl/spotify-downloader) Returns tuple of (status, ahead_by, behind_by) View Source def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/{repo}/compare/{start}...{end}\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: {response.status_code}\" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], )","title":"Github"},{"location":"reference/spotdl/utils/github/#module-spotdlutilsgithub","text":"Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates. View Source \"\"\" Module for getting information about the current version of spotdl from GitHub, downloading the latest version, and checking for updates. \"\"\" from typing import Tuple import re import os import requests from spotdl import _version REPO = \"spotdl/spotify-downloader\" WEB_APP_URL = \"https://github.com/spotdl/web-ui/tree/master/dist\" def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/ { repo } /compare/ { start } ... { end } \" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], ) def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/ { repo } /releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: { response . status_code } \" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v { _version . __version__ } \" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: { latest_version } . \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \" { name } is { status } by { behind_by } commits. \\n \" elif status == \"ahead\" : message += f \" { name } is { status } by { ahead_by } commits. \\n \" else : message += f \" { name } is up to date. \\n \" return message def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" ) def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ): \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ) . json () if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ])) else : path = os . path . join ( dir_out , file [ \"path\" ]) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ) . content ) else : download_github_dir ( file [ \"html_url\" ], flatten , output_dir )","title":"Module spotdl.utils.github"},{"location":"reference/spotdl/utils/github/#variables","text":"REPO WEB_APP_URL","title":"Variables"},{"location":"reference/spotdl/utils/github/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/github/#check_for_updates","text":"def check_for_updates ( repo : str = 'spotdl/spotify-downloader' ) -> str Check for updates to the current version.","title":"check_for_updates"},{"location":"reference/spotdl/utils/github/#arguments","text":"repo: the repo to check (defaults to spotdl/spotify-downloader)","title":"Arguments"},{"location":"reference/spotdl/utils/github/#returns","text":"the latest version View Source def check_for_updates ( repo : str = REPO ) -> str : \"\"\" Check for updates to the current version. ### Arguments - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - the latest version \"\"\" message = \"\" url = f \"https://api.github.com/repos/{repo}/releases/latest\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: {response.status_code}\" ) data = response . json () latest_version = data [ \"name\" ] # returns \"vx.x.x\" current_version = f \"v{_version.__version__}\" # returns \"vx.x.x\" if latest_version != current_version : message = f \"New version available: {latest_version}. \\n\\n \" else : message = \"No updates available. \\n\\n \" master = get_status ( current_version , \"master\" ) dev = get_status ( current_version , \"dev\" ) for branch in [ \"master\" , \"dev\" ]: name = branch . capitalize () if branch == \"master\" : status , ahead_by , behind_by = master else : status , ahead_by , behind_by = dev if status == \"behind\" : message += f \"{name} is {status} by {behind_by} commits. \\n \" elif status == \"ahead\" : message += f \"{name} is {status} by {ahead_by} commits. \\n \" else : message += f \"{name} is up to date. \\n \" return message","title":"Returns"},{"location":"reference/spotdl/utils/github/#create_github_url","text":"def create_github_url ( url : str = 'https://github.com/spotdl/web-ui/tree/master/dist' ) From the given url, produce a URL that is compatible with Github's REST API.","title":"create_github_url"},{"location":"reference/spotdl/utils/github/#arguments_1","text":"url: the url to convert","title":"Arguments"},{"location":"reference/spotdl/utils/github/#notes","text":"Can handle blob or tree paths. View Source def create_github_url ( url : str = WEB_APP_URL ): \"\"\" From the given url, produce a URL that is compatible with Github's REST API. ### Arguments - url: the url to convert ### Notes - Can handle blob or tree paths. \"\"\" repo_only_url = re . compile ( r \"https:\\/\\/github\\.com\\/[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/[a-zA-Z0-9]+$\" ) re_branch = re . compile ( \"/(tree|blob)/(.+?)/\" ) # Check if the given url is a url to a GitHub repo. If it is, tell the # user to use 'git clone' to download it if re . match ( repo_only_url , url ): raise ValueError ( \"The given URL is a GitHub repo. Please use 'git clone' to download it.\" ) # extract the branch name from the given url (e.g master) branch = re_branch . search ( url ) if branch : download_dirs = url [ branch . end () :] api_url = ( url [: branch . start ()] . replace ( \"github.com\" , \"api.github.com/repos\" , 1 ) + \"/contents/\" + download_dirs + \"?ref=\" + branch . group ( 2 ) ) return api_url raise ValueError ( \"The given url is not a valid GitHub url\" )","title":"Notes"},{"location":"reference/spotdl/utils/github/#download_github_dir","text":"def download_github_dir ( repo_url : str = 'https://github.com/spotdl/web-ui/tree/master/dist' , flatten : bool = False , output_dir : str = './' ) Downloads the files and directories in repo_url.","title":"download_github_dir"},{"location":"reference/spotdl/utils/github/#arguments_2","text":"repo_url: the url to the repo to download flatten: whether to flatten the directory structure output_dir: the directory to download the files to","title":"Arguments"},{"location":"reference/spotdl/utils/github/#notes_1","text":"Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py View Source def download_github_dir ( repo_url : str = WEB_APP_URL , flatten : bool = False , output_dir : str = \"./\" ) : \"\"\" Downloads the files and directories in repo_url. ### Arguments - repo_url: the url to the repo to download - flatten: whether to flatten the directory structure - output_dir: the directory to download the files to ### Notes - Modification of https://github.com/sdushantha/gitdir/blob/master/gitdir/gitdir.py \"\"\" # generate the url which returns the JSON data api_url = create_github_url ( repo_url ) dir_out = output_dir response = requests . get ( api_url ). json () if not flatten : # make a directory with the name which is taken from # the actual repo os . makedirs ( dir_out , exist_ok = True ) if isinstance ( response , dict ) and response [ \"type\" ] == \"file\" : response = [ response ] for file in response : file_url = file [ \"download_url\" ] if flatten : path = os . path . join ( dir_out , os . path . basename ( file [ \"path\" ] )) else : path = os . path . join ( dir_out , file [ \"path\" ] ) dirname = os . path . dirname ( path ) if dirname != \"\" : os . makedirs ( dirname , exist_ok = True ) if file_url is not None : with open ( path , \"wb\" ) as new_file : new_file . write ( requests . get ( file_url ). content ) else : download_github_dir ( file [ \"html_url\" ] , flatten , output_dir )","title":"Notes"},{"location":"reference/spotdl/utils/github/#get_status","text":"def get_status ( start : str , end : str , repo : str = 'spotdl/spotify-downloader' ) -> Tuple [ str , int , int ] Get the status of a commit range.","title":"get_status"},{"location":"reference/spotdl/utils/github/#arguments_3","text":"start: the starting commit/branch/tag end: the ending commit/branch/tag repo: the repo to check (defaults to spotdl/spotify-downloader)","title":"Arguments"},{"location":"reference/spotdl/utils/github/#returns_1","text":"tuple of (status, ahead_by, behind_by) View Source def get_status ( start : str , end : str , repo : str = REPO ) -> Tuple [ str , int , int ]: \"\"\" Get the status of a commit range. ### Arguments - start: the starting commit/branch/tag - end: the ending commit/branch/tag - repo: the repo to check (defaults to spotdl/spotify-downloader) ### Returns - tuple of (status, ahead_by, behind_by) \"\"\" url = f \"https://api.github.com/repos/{repo}/compare/{start}...{end}\" response = requests . get ( url ) if response . status_code != 200 : raise RuntimeError ( f \"Failed to get commit count. Status code: {response.status_code}\" ) data = response . json () return ( data [ \"status\" ], data [ \"ahead_by\" ], data [ \"behind_by\" ], )","title":"Returns"},{"location":"reference/spotdl/utils/m3u/","text":"Module spotdl.utils.m3u Module for creating m3u content and writing it to a file. None View Source \"\"\" Module for creating m3u content and writing it to a file. \"\"\" from typing import List from spotdl.types.song import Song from spotdl.utils.formatter import create_file_name def create_m3u_content ( song_list : List [ Song ], template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \" \\n \" return text def create_m3u_file ( file_name : str , song_list : List [ Song ], template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content Functions create_m3u_content def create_m3u_content ( song_list : List [ spotdl . types . song . Song ], template : str , file_extension : str , short : bool = False ) -> str Create m3u content and return it as a string. Arguments song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template Returns the m3u content as a string View Source def create_m3u_content ( song_list : List [ Song ] , template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \"\\n\" return text create_m3u_file def create_m3u_file ( file_name : str , song_list : List [ spotdl . types . song . Song ], template : str , file_extension : str , short : bool = False ) -> str Create the m3u file. Arguments file_name: the file name to use song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template Returns the m3u content as a string View Source def create_m3u_file ( file_name : str , song_list : List [ Song ] , template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content","title":"M3U"},{"location":"reference/spotdl/utils/m3u/#module-spotdlutilsm3u","text":"Module for creating m3u content and writing it to a file. None View Source \"\"\" Module for creating m3u content and writing it to a file. \"\"\" from typing import List from spotdl.types.song import Song from spotdl.utils.formatter import create_file_name def create_m3u_content ( song_list : List [ Song ], template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \" \\n \" return text def create_m3u_file ( file_name : str , song_list : List [ Song ], template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content","title":"Module spotdl.utils.m3u"},{"location":"reference/spotdl/utils/m3u/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/m3u/#create_m3u_content","text":"def create_m3u_content ( song_list : List [ spotdl . types . song . Song ], template : str , file_extension : str , short : bool = False ) -> str Create m3u content and return it as a string.","title":"create_m3u_content"},{"location":"reference/spotdl/utils/m3u/#arguments","text":"song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/spotdl/utils/m3u/#returns","text":"the m3u content as a string View Source def create_m3u_content ( song_list : List [ Song ] , template : str , file_extension : str , short : bool = False ) -> str : \"\"\" Create m3u content and return it as a string. ### Arguments - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" text = \"\" for song in song_list : text += str ( create_file_name ( song , template , file_extension , short )) + \"\\n\" return text","title":"Returns"},{"location":"reference/spotdl/utils/m3u/#create_m3u_file","text":"def create_m3u_file ( file_name : str , song_list : List [ spotdl . types . song . Song ], template : str , file_extension : str , short : bool = False ) -> str Create the m3u file.","title":"create_m3u_file"},{"location":"reference/spotdl/utils/m3u/#arguments_1","text":"file_name: the file name to use song_list: the list of songs template: the template to use file_extension: the file extension to use short: whether to use the short version of the template","title":"Arguments"},{"location":"reference/spotdl/utils/m3u/#returns_1","text":"the m3u content as a string View Source def create_m3u_file ( file_name : str , song_list : List [ Song ] , template : str , file_extension : str , short : bool = False , ) -> str : \"\"\" Create the m3u file. ### Arguments - file_name: the file name to use - song_list: the list of songs - template: the template to use - file_extension: the file extension to use - short: whether to use the short version of the template ### Returns - the m3u content as a string \"\"\" m3u_content = create_m3u_content ( song_list , template , file_extension , short ) with open ( file_name , \"w\" , encoding = \"utf-8\" ) as m3u_file : m3u_file . write ( m3u_content ) return m3u_content","title":"Returns"},{"location":"reference/spotdl/utils/metadata/","text":"Module spotdl.utils.metadata Module for embedding metadata into audio files using Mutagen. embed_metadata( output_file Path(\"test.mp3\"), song: song_object, file_format: \"mp3\", lyrics: str = \"\", ) View Source \"\"\" Module for embedding metadata into audio files using Mutagen. >>> embed_metadata( output_file Path(\"test.mp3\"), song: song_object, file_format: \"mp3\", lyrics: str = \"\", ) \"\"\" import base64 from pathlib import Path from urllib.request import urlopen from mutagen.oggopus import OggOpus from mutagen.mp4 import MP4 , MP4Cover from mutagen.flac import Picture , FLAC from mutagen.oggvorbis import OggVorbis from mutagen.easyid3 import EasyID3 , ID3 from mutagen.id3 import APIC as AlbumCover , USLT from spotdl.types import Song class MetadataError ( Exception ): \"\"\" Base class for all exceptions related to metadata and id3 embedding. \"\"\" # Apple has specific tags - see mutagen docs - # http://mutagen.readthedocs.io/en/latest/api/mp4.html M4A_TAG_PRESET = { \"album\" : \" \\xa9 alb\" , \"artist\" : \" \\xa9 ART\" , \"date\" : \" \\xa9 day\" , \"title\" : \" \\xa9 nam\" , \"year\" : \" \\xa9 day\" , \"originaldate\" : \"purd\" , \"comment\" : \" \\xa9 cmt\" , \"group\" : \" \\xa9 grp\" , \"writer\" : \" \\xa9 wrt\" , \"genre\" : \" \\xa9 gen\" , \"tracknumber\" : \"trkn\" , \"albumartist\" : \"aART\" , \"discnumber\" : \"disk\" , \"cpil\" : \"cpil\" , \"albumart\" : \"covr\" , \"encodedby\" : \" \\xa9 too\" , \"copyright\" : \"cprt\" , \"tempo\" : \"tmpo\" , \"lyrics\" : \" \\xa9 lyr\" , \"explicit\" : \"rtng\" , } TAG_PRESET = { key : key for key in M4A_TAG_PRESET } def _set_id3_mp3 ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for MP3 files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = EasyID3 ( str ( output_file . resolve ())) audio_file = _embed_mp3_metadata ( audio_file , song ) audio_file . save ( v2_version = 3 ) audio_file = _embed_mp3_cover ( output_file , song ) audio_file = _embed_mp3_lyrics ( audio_file , lyrics ) audio_file . save ( v2_version = 3 ) def _set_id3_m4a ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for M4A files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = MP4 ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"m4a\" , M4A_TAG_PRESET ) audio_file = _embed_m4a_metadata ( audio_file , song , lyrics ) audio_file . save () def _set_id3_flac ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for FLAC files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = FLAC ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"flac\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"flac\" ) audio_file . save () def _set_id3_opus ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for Opus files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = OggOpus ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"opus\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"opus\" ) audio_file . save () def _set_id3_ogg ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for OGG files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = OggVorbis ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"ogg\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"ogg\" ) audio_file . save () def _embed_mp3_metadata ( audio_file , song : Song ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. ### Returns - Modified audio_file object. \"\"\" audio_file . delete () audio_file [ \"title\" ] = song . name audio_file [ \"titlesort\" ] = song . name audio_file [ \"tracknumber\" ] = [ song . track_number , song . tracks_count ] audio_file [ \"discnumber\" ] = [ song . disc_number , song . disc_count ] audio_file [ \"artist\" ] = song . artists audio_file [ \"album\" ] = song . album_name audio_file [ \"albumartist\" ] = song . artists audio_file [ \"date\" ] = song . date audio_file [ \"originaldate\" ] = song . date audio_file [ \"encodedby\" ] = song . publisher if song . copyright_text : audio_file [ \"copyright\" ] = song . copyright_text genres = song . genres if len ( genres ) > 0 : audio_file [ \"genre\" ] = genres [ 0 ] return audio_file def _embed_mp3_cover ( file_path , song : Song ): \"\"\" Embed cover into the audio file. ### Arguments - file_path: Path to the audio file. - song: Song object. ### Returns - Modified audio_file object. \"\"\" audio_file = ID3 ( file_path ) if song . cover_url : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ \"APIC\" ] = AlbumCover ( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = raw_album_art . read (), ) return audio_file def _embed_mp3_lyrics ( audio_file , lyrics : str = \"\" ): \"\"\" Embed lyrics into the audio file. ### Arguments - audio_file: Mutagen audio file object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" uslt_output = USLT ( encoding = 3 , lang = \"eng\" , desc = \"desc\" , text = lyrics ) audio_file [ \"USLT::'eng'\" ] = uslt_output return audio_file def _embed_m4a_metadata ( audio_file , song : Song , lyrics : str = \"\" ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" audio_file [ M4A_TAG_PRESET [ \"year\" ]] = str ( song . year ) audio_file [ M4A_TAG_PRESET [ \"lyrics\" ]] = lyrics audio_file [ M4A_TAG_PRESET [ \"explicit\" ]] = ( 4 if song . explicit is True else 2 ,) if song . cover_url : try : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ M4A_TAG_PRESET [ \"albumart\" ]] = [ MP4Cover ( raw_album_art . read (), imageformat = MP4Cover . FORMAT_JPEG , ) ] except IndexError : pass return audio_file def _embed_basic_metadata ( audio_file , song : Song , encoding , preset = TAG_PRESET ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - encoding: Encoding of the audio file. - preset: Preset of the audio file. ### Returns - Modified audio_file object. \"\"\" album_name = song . album_name if album_name : audio_file [ preset [ \"album\" ]] = album_name audio_file [ preset [ \"artist\" ]] = song . artist audio_file [ preset [ \"albumartist\" ]] = song . artist audio_file [ preset [ \"title\" ]] = song . name audio_file [ preset [ \"date\" ]] = song . date audio_file [ preset [ \"originaldate\" ]] = song . date if len ( song . genres ) > 0 : audio_file [ preset [ \"genre\" ]] = song . genres [ 0 ] if song . copyright_text : audio_file [ preset [ \"copyright\" ]] = song . copyright_text if encoding in [ \"flac\" , \"ogg\" , \"opus\" ]: zfilled_disc_number = str ( song . disc_number ) . zfill ( len ( str ( song . disc_count ))) audio_file [ preset [ \"discnumber\" ]] = zfilled_disc_number else : audio_file [ preset [ \"discnumber\" ]] = [( song . disc_number , song . disc_count )] if encoding in [ \"flac\" , \"ogg\" , \"opus\" ]: zfilled_track_number = str ( song . track_number ) . zfill ( len ( str ( song . tracks_count ))) audio_file [ preset [ \"tracknumber\" ]] = zfilled_track_number else : audio_file [ preset [ \"tracknumber\" ]] = [( song . track_number , song . tracks_count )] if encoding == \"m4a\" : audio_file [ preset [ \"encodedby\" ]] = song . publisher return audio_file def _embed_ogg_metadata ( audio_file , song : Song , lyrics : str = \"\" ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" audio_file [ \"year\" ] = str ( song . year ) audio_file [ \"lyrics\" ] = lyrics return audio_file def _embed_cover ( audio_file , song : Song , encoding : str ): \"\"\" Embed cover into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - encoding: Encoding of the audio file. ### Returns - Modified audio_file object. \"\"\" if song . cover_url is None : return audio_file image = Picture () image . type = 3 image . desc = \"Cover\" image . mime = \"image/jpeg\" with urlopen ( song . cover_url ) as raw_album_art : image . data = raw_album_art . read () if encoding == \"flac\" : audio_file . add_picture ( image ) elif encoding in [ \"ogg\" , \"opus\" ]: image_data = image . write () encoded_data = base64 . b64encode ( image_data ) vcomment_value = encoded_data . decode ( \"ascii\" ) audio_file [ \"metadata_block_picture\" ] = [ vcomment_value ] return audio_file AVAILABLE_FORMATS = { \"mp3\" : _set_id3_mp3 , \"flac\" : _set_id3_flac , \"opus\" : _set_id3_opus , \"ogg\" : _set_id3_ogg , \"m4a\" : _set_id3_m4a , } def embed_metadata ( output_file : Path , song : Song , file_format : str , lyrics : str = \"\" ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. - lyrics: Lyrics to embed. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song , lyrics ) Variables AVAILABLE_FORMATS M4A_TAG_PRESET TAG_PRESET Functions embed_metadata def embed_metadata ( output_file : pathlib . Path , song : spotdl . types . song . Song , file_format : str , lyrics : str = '' ) -> None Embeds metadata into the output file. Arguments output_file: Path to the output file. song: Song object. file_format: File format of the output file. lyrics: Lyrics to embed. View Source def embed_metadata ( output_file : Path , song : Song , file_format : str , lyrics : str = \"\" ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. - lyrics: Lyrics to embed. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song , lyrics ) Classes MetadataError class MetadataError ( / , * args , ** kwargs ) View Source class MetadataError ( Exception ): \"\"\" Base class for all exceptions related to metadata and id3 embedding. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Metadata"},{"location":"reference/spotdl/utils/metadata/#module-spotdlutilsmetadata","text":"Module for embedding metadata into audio files using Mutagen. embed_metadata( output_file Path(\"test.mp3\"), song: song_object, file_format: \"mp3\", lyrics: str = \"\", ) View Source \"\"\" Module for embedding metadata into audio files using Mutagen. >>> embed_metadata( output_file Path(\"test.mp3\"), song: song_object, file_format: \"mp3\", lyrics: str = \"\", ) \"\"\" import base64 from pathlib import Path from urllib.request import urlopen from mutagen.oggopus import OggOpus from mutagen.mp4 import MP4 , MP4Cover from mutagen.flac import Picture , FLAC from mutagen.oggvorbis import OggVorbis from mutagen.easyid3 import EasyID3 , ID3 from mutagen.id3 import APIC as AlbumCover , USLT from spotdl.types import Song class MetadataError ( Exception ): \"\"\" Base class for all exceptions related to metadata and id3 embedding. \"\"\" # Apple has specific tags - see mutagen docs - # http://mutagen.readthedocs.io/en/latest/api/mp4.html M4A_TAG_PRESET = { \"album\" : \" \\xa9 alb\" , \"artist\" : \" \\xa9 ART\" , \"date\" : \" \\xa9 day\" , \"title\" : \" \\xa9 nam\" , \"year\" : \" \\xa9 day\" , \"originaldate\" : \"purd\" , \"comment\" : \" \\xa9 cmt\" , \"group\" : \" \\xa9 grp\" , \"writer\" : \" \\xa9 wrt\" , \"genre\" : \" \\xa9 gen\" , \"tracknumber\" : \"trkn\" , \"albumartist\" : \"aART\" , \"discnumber\" : \"disk\" , \"cpil\" : \"cpil\" , \"albumart\" : \"covr\" , \"encodedby\" : \" \\xa9 too\" , \"copyright\" : \"cprt\" , \"tempo\" : \"tmpo\" , \"lyrics\" : \" \\xa9 lyr\" , \"explicit\" : \"rtng\" , } TAG_PRESET = { key : key for key in M4A_TAG_PRESET } def _set_id3_mp3 ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for MP3 files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = EasyID3 ( str ( output_file . resolve ())) audio_file = _embed_mp3_metadata ( audio_file , song ) audio_file . save ( v2_version = 3 ) audio_file = _embed_mp3_cover ( output_file , song ) audio_file = _embed_mp3_lyrics ( audio_file , lyrics ) audio_file . save ( v2_version = 3 ) def _set_id3_m4a ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for M4A files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = MP4 ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"m4a\" , M4A_TAG_PRESET ) audio_file = _embed_m4a_metadata ( audio_file , song , lyrics ) audio_file . save () def _set_id3_flac ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for FLAC files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = FLAC ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"flac\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"flac\" ) audio_file . save () def _set_id3_opus ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for Opus files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = OggOpus ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"opus\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"opus\" ) audio_file . save () def _set_id3_ogg ( output_file : Path , song : Song , lyrics : str = \"\" ): \"\"\" Set ID3 tags for OGG files. ### Arguments - output_file: Path to the output file. - song: Song object. - lyrics: Lyrics to embed. \"\"\" audio_file = OggVorbis ( str ( output_file . resolve ())) audio_file = _embed_basic_metadata ( audio_file , song , \"ogg\" ) audio_file = _embed_ogg_metadata ( audio_file , song , lyrics ) audio_file = _embed_cover ( audio_file , song , \"ogg\" ) audio_file . save () def _embed_mp3_metadata ( audio_file , song : Song ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. ### Returns - Modified audio_file object. \"\"\" audio_file . delete () audio_file [ \"title\" ] = song . name audio_file [ \"titlesort\" ] = song . name audio_file [ \"tracknumber\" ] = [ song . track_number , song . tracks_count ] audio_file [ \"discnumber\" ] = [ song . disc_number , song . disc_count ] audio_file [ \"artist\" ] = song . artists audio_file [ \"album\" ] = song . album_name audio_file [ \"albumartist\" ] = song . artists audio_file [ \"date\" ] = song . date audio_file [ \"originaldate\" ] = song . date audio_file [ \"encodedby\" ] = song . publisher if song . copyright_text : audio_file [ \"copyright\" ] = song . copyright_text genres = song . genres if len ( genres ) > 0 : audio_file [ \"genre\" ] = genres [ 0 ] return audio_file def _embed_mp3_cover ( file_path , song : Song ): \"\"\" Embed cover into the audio file. ### Arguments - file_path: Path to the audio file. - song: Song object. ### Returns - Modified audio_file object. \"\"\" audio_file = ID3 ( file_path ) if song . cover_url : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ \"APIC\" ] = AlbumCover ( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = raw_album_art . read (), ) return audio_file def _embed_mp3_lyrics ( audio_file , lyrics : str = \"\" ): \"\"\" Embed lyrics into the audio file. ### Arguments - audio_file: Mutagen audio file object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" uslt_output = USLT ( encoding = 3 , lang = \"eng\" , desc = \"desc\" , text = lyrics ) audio_file [ \"USLT::'eng'\" ] = uslt_output return audio_file def _embed_m4a_metadata ( audio_file , song : Song , lyrics : str = \"\" ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" audio_file [ M4A_TAG_PRESET [ \"year\" ]] = str ( song . year ) audio_file [ M4A_TAG_PRESET [ \"lyrics\" ]] = lyrics audio_file [ M4A_TAG_PRESET [ \"explicit\" ]] = ( 4 if song . explicit is True else 2 ,) if song . cover_url : try : with urlopen ( song . cover_url ) as raw_album_art : audio_file [ M4A_TAG_PRESET [ \"albumart\" ]] = [ MP4Cover ( raw_album_art . read (), imageformat = MP4Cover . FORMAT_JPEG , ) ] except IndexError : pass return audio_file def _embed_basic_metadata ( audio_file , song : Song , encoding , preset = TAG_PRESET ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - encoding: Encoding of the audio file. - preset: Preset of the audio file. ### Returns - Modified audio_file object. \"\"\" album_name = song . album_name if album_name : audio_file [ preset [ \"album\" ]] = album_name audio_file [ preset [ \"artist\" ]] = song . artist audio_file [ preset [ \"albumartist\" ]] = song . artist audio_file [ preset [ \"title\" ]] = song . name audio_file [ preset [ \"date\" ]] = song . date audio_file [ preset [ \"originaldate\" ]] = song . date if len ( song . genres ) > 0 : audio_file [ preset [ \"genre\" ]] = song . genres [ 0 ] if song . copyright_text : audio_file [ preset [ \"copyright\" ]] = song . copyright_text if encoding in [ \"flac\" , \"ogg\" , \"opus\" ]: zfilled_disc_number = str ( song . disc_number ) . zfill ( len ( str ( song . disc_count ))) audio_file [ preset [ \"discnumber\" ]] = zfilled_disc_number else : audio_file [ preset [ \"discnumber\" ]] = [( song . disc_number , song . disc_count )] if encoding in [ \"flac\" , \"ogg\" , \"opus\" ]: zfilled_track_number = str ( song . track_number ) . zfill ( len ( str ( song . tracks_count ))) audio_file [ preset [ \"tracknumber\" ]] = zfilled_track_number else : audio_file [ preset [ \"tracknumber\" ]] = [( song . track_number , song . tracks_count )] if encoding == \"m4a\" : audio_file [ preset [ \"encodedby\" ]] = song . publisher return audio_file def _embed_ogg_metadata ( audio_file , song : Song , lyrics : str = \"\" ): \"\"\" Embed basic metadata into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - lyrics: Lyrics to embed. ### Returns - Modified audio_file object. \"\"\" audio_file [ \"year\" ] = str ( song . year ) audio_file [ \"lyrics\" ] = lyrics return audio_file def _embed_cover ( audio_file , song : Song , encoding : str ): \"\"\" Embed cover into the audio file. ### Arguments - audio_file: Mutagen audio file object. - song: Song object. - encoding: Encoding of the audio file. ### Returns - Modified audio_file object. \"\"\" if song . cover_url is None : return audio_file image = Picture () image . type = 3 image . desc = \"Cover\" image . mime = \"image/jpeg\" with urlopen ( song . cover_url ) as raw_album_art : image . data = raw_album_art . read () if encoding == \"flac\" : audio_file . add_picture ( image ) elif encoding in [ \"ogg\" , \"opus\" ]: image_data = image . write () encoded_data = base64 . b64encode ( image_data ) vcomment_value = encoded_data . decode ( \"ascii\" ) audio_file [ \"metadata_block_picture\" ] = [ vcomment_value ] return audio_file AVAILABLE_FORMATS = { \"mp3\" : _set_id3_mp3 , \"flac\" : _set_id3_flac , \"opus\" : _set_id3_opus , \"ogg\" : _set_id3_ogg , \"m4a\" : _set_id3_m4a , } def embed_metadata ( output_file : Path , song : Song , file_format : str , lyrics : str = \"\" ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. - lyrics: Lyrics to embed. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song , lyrics )","title":"Module spotdl.utils.metadata"},{"location":"reference/spotdl/utils/metadata/#variables","text":"AVAILABLE_FORMATS M4A_TAG_PRESET TAG_PRESET","title":"Variables"},{"location":"reference/spotdl/utils/metadata/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/metadata/#embed_metadata","text":"def embed_metadata ( output_file : pathlib . Path , song : spotdl . types . song . Song , file_format : str , lyrics : str = '' ) -> None Embeds metadata into the output file.","title":"embed_metadata"},{"location":"reference/spotdl/utils/metadata/#arguments","text":"output_file: Path to the output file. song: Song object. file_format: File format of the output file. lyrics: Lyrics to embed. View Source def embed_metadata ( output_file : Path , song : Song , file_format : str , lyrics : str = \"\" ) -> None : \"\"\" Embeds metadata into the output file. ### Arguments - output_file: Path to the output file. - song: Song object. - file_format: File format of the output file. - lyrics: Lyrics to embed. \"\"\" function = AVAILABLE_FORMATS . get ( file_format ) if function : function ( output_file , song , lyrics )","title":"Arguments"},{"location":"reference/spotdl/utils/metadata/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/utils/metadata/#metadataerror","text":"class MetadataError ( / , * args , ** kwargs ) View Source class MetadataError ( Exception ): \"\"\" Base class for all exceptions related to metadata and id3 embedding. \"\"\"","title":"MetadataError"},{"location":"reference/spotdl/utils/metadata/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/metadata/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/utils/metadata/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/utils/metadata/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/utils/providers/","text":"Module spotdl.utils.providers Module for provider utilities. None View Source \"\"\" Module for provider utilities. \"\"\" from rapidfuzz import fuzz from slugify import slugify def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float : \"\"\" A wrapper around `partial_ratio` to handle UTF-8 encoded characters. ### Arguments - str1: The first string to compare. - str2: The second string to compare. - score_cutoff: The score cutoff to use. ### Returns - The percentage of similarity between the two strings. ### Notes - Uses slugify to normalize the strings \"\"\" try : return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = None ) except Exception : # On error, use slugify to handle unicode characters. return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = slugify ) Functions match_percentage def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float A wrapper around partial_ratio to handle UTF-8 encoded characters. Arguments str1: The first string to compare. str2: The second string to compare. score_cutoff: The score cutoff to use. Returns The percentage of similarity between the two strings. Notes Uses slugify to normalize the strings View Source def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float : \" \"\" A wrapper around `partial_ratio` to handle UTF-8 encoded characters. ### Arguments - str1: The first string to compare. - str2: The second string to compare. - score_cutoff: The score cutoff to use. ### Returns - The percentage of similarity between the two strings. ### Notes - Uses slugify to normalize the strings \"\" \" try : return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = None ) except Exception : # On error, use slugify to handle unicode characters. return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = slugify )","title":"Providers"},{"location":"reference/spotdl/utils/providers/#module-spotdlutilsproviders","text":"Module for provider utilities. None View Source \"\"\" Module for provider utilities. \"\"\" from rapidfuzz import fuzz from slugify import slugify def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float : \"\"\" A wrapper around `partial_ratio` to handle UTF-8 encoded characters. ### Arguments - str1: The first string to compare. - str2: The second string to compare. - score_cutoff: The score cutoff to use. ### Returns - The percentage of similarity between the two strings. ### Notes - Uses slugify to normalize the strings \"\"\" try : return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = None ) except Exception : # On error, use slugify to handle unicode characters. return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = slugify )","title":"Module spotdl.utils.providers"},{"location":"reference/spotdl/utils/providers/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/providers/#match_percentage","text":"def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float A wrapper around partial_ratio to handle UTF-8 encoded characters.","title":"match_percentage"},{"location":"reference/spotdl/utils/providers/#arguments","text":"str1: The first string to compare. str2: The second string to compare. score_cutoff: The score cutoff to use.","title":"Arguments"},{"location":"reference/spotdl/utils/providers/#returns","text":"The percentage of similarity between the two strings.","title":"Returns"},{"location":"reference/spotdl/utils/providers/#notes","text":"Uses slugify to normalize the strings View Source def match_percentage ( str1 : str , str2 : str , score_cutoff : float = 0 ) -> float : \" \"\" A wrapper around `partial_ratio` to handle UTF-8 encoded characters. ### Arguments - str1: The first string to compare. - str2: The second string to compare. - score_cutoff: The score cutoff to use. ### Returns - The percentage of similarity between the two strings. ### Notes - Uses slugify to normalize the strings \"\" \" try : return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = None ) except Exception : # On error, use slugify to handle unicode characters. return fuzz . partial_ratio ( str1 , str2 , score_cutoff = score_cutoff , processor = slugify )","title":"Notes"},{"location":"reference/spotdl/utils/search/","text":"Module spotdl.utils.search Module for creating Song objects by interacting with Spotify API or by parsing a query. To use this module you must first initialize the SpotifyClient. View Source \"\"\" Module for creating Song objects by interacting with Spotify API or by parsing a query. To use this module you must first initialize the SpotifyClient. \"\"\" import json import concurrent.futures from typing import List , Optional from spotdl.utils.spotify import SpotifyClient from spotdl.types import Playlist , Album , Artist , Saved from spotdl.types.song import SongList , SongError , Song class QueryError ( Exception ): \"\"\" Base class for all exceptions related to query. \"\"\" def get_search_results ( search_term : str ) -> List [ Song ]: \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ]): songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs def parse_query ( query : List [ str ], threads : int = 1 , ) -> List [ Song ]: \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ]) . json , \"download_url\" : split_urls [ 0 ], } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ): urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ): songs . append ( song ) return songs def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type: ignore artists = artists , # type: ignore artist = None if artists is None else artists [ 0 ], # type: ignore album_name = album_name , # type: ignore album_artist = album_artist , # type: ignore genres = genres , # type: ignore disc_number = disc_number , # type: ignore disc_count = disc_count , # type: ignore duration = duration , # type: ignore year = year , # type: ignore date = date , # type: ignore track_number = track_number , # type: ignore tracks_count = tracks_count , # type: ignore isrc = isrc , # type: ignore song_id = song_id , # type: ignore cover_url = cover_url , # type: ignore explicit = explicit , # type: ignore publisher = publisher , # type: ignore url = url , # type: ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , ) def get_simple_songs ( query : List [ str ], ) -> List [ Song ]: \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( create_empty_song ( url = split_urls [ 1 ], download_url = split_urls [ 0 ]) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type: ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song ( url = url , song_list = song_list ) for url in song_list . urls ] ) # type: ignore return songs Functions create_empty_song def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ ForwardRef ( 'SongList' )] = None ) -> spotdl . types . song . Song Create an empty song. Arguments name: Name of the song artists: List of artists album_name: Name of the album album_artist: Name of the album artist genres: List of genres disc_number: Disc number disc_count: Disc count duration: Duration of the song in seconds year: Year of release date: Date of release track_number: Track number tracks_count: Number of tracks isrc: ISRC code song_id: Spotify song ID cover_url: URL of the cover art explicit: Explicit flag publisher: Publisher url: URL of the song copyright_text: Copyright text download_url: Download URL song_list: Song list Returns Song object View Source def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List[str ] ] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List[str ] ] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type : ignore artists = artists , # type : ignore artist = None if artists is None else artists [ 0 ] , # type : ignore album_name = album_name , # type : ignore album_artist = album_artist , # type : ignore genres = genres , # type : ignore disc_number = disc_number , # type : ignore disc_count = disc_count , # type : ignore duration = duration , # type : ignore year = year , # type : ignore date = date , # type : ignore track_number = track_number , # type : ignore tracks_count = tracks_count , # type : ignore isrc = isrc , # type : ignore song_id = song_id , # type : ignore cover_url = cover_url , # type : ignore explicit = explicit , # type : ignore publisher = publisher , # type : ignore url = url , # type : ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , ) get_search_results def get_search_results ( search_term : str ) -> List [ spotdl . types . song . Song ] Creates a list of Song objects from a search term. Arguments search_term: the search term to use Returns a list of Song objects View Source def get_search_results ( search_term : str ) -> List [ Song ] : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ] ) : songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs get_simple_songs def get_simple_songs ( query : List [ str ] ) -> List [ spotdl . types . song . Song ] Parse query and return list containing simple song objects Arguments query: List of strings containing query Returns List of simple song objects View Source def get_simple_songs ( query : List [ str ] , ) -> List [ Song ] : \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ) : split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ) : raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( create_empty_song ( url = split_urls [ 1 ] , download_url = split_urls [ 0 ] ) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type : ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ) : with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ) : # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song(url=url, song_list=song_list) for url in song_list.urls ] ) # type : ignore return songs parse_query def parse_query ( query : List [ str ], threads : int = 1 ) -> List [ spotdl . types . song . Song ] Parse query and return list containing song object Arguments query: List of strings containing query threads: Number of threads to use Returns List of song objects View Source def parse_query ( query : List [ str ] , threads : int = 1 , ) -> List [ Song ] : \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ) : split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ) : raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ] ). json , \"download_url\" : split_urls [ 0 ] , } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ) : urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ) : with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ) : # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ) : songs . append ( song ) return songs Classes QueryError class QueryError ( / , * args , ** kwargs ) View Source class QueryError ( Exception ): \"\"\" Base class for all exceptions related to query. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Search"},{"location":"reference/spotdl/utils/search/#module-spotdlutilssearch","text":"Module for creating Song objects by interacting with Spotify API or by parsing a query. To use this module you must first initialize the SpotifyClient. View Source \"\"\" Module for creating Song objects by interacting with Spotify API or by parsing a query. To use this module you must first initialize the SpotifyClient. \"\"\" import json import concurrent.futures from typing import List , Optional from spotdl.utils.spotify import SpotifyClient from spotdl.types import Playlist , Album , Artist , Saved from spotdl.types.song import SongList , SongError , Song class QueryError ( Exception ): \"\"\" Base class for all exceptions related to query. \"\"\" def get_search_results ( search_term : str ) -> List [ Song ]: \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {}) . get ( \"items\" , [])) == 0 ): raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ]): songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs def parse_query ( query : List [ str ], threads : int = 1 , ) -> List [ Song ]: \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ]) . json , \"download_url\" : split_urls [ 0 ], } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ): urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ): songs . append ( song ) return songs def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type: ignore artists = artists , # type: ignore artist = None if artists is None else artists [ 0 ], # type: ignore album_name = album_name , # type: ignore album_artist = album_artist , # type: ignore genres = genres , # type: ignore disc_number = disc_number , # type: ignore disc_count = disc_count , # type: ignore duration = duration , # type: ignore year = year , # type: ignore date = date , # type: ignore track_number = track_number , # type: ignore tracks_count = tracks_count , # type: ignore isrc = isrc , # type: ignore song_id = song_id , # type: ignore cover_url = cover_url , # type: ignore explicit = explicit , # type: ignore publisher = publisher , # type: ignore url = url , # type: ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , ) def get_simple_songs ( query : List [ str ], ) -> List [ Song ]: \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ): split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ): raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( create_empty_song ( url = split_urls [ 1 ], download_url = split_urls [ 0 ]) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type: ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ): with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ): # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song ( url = url , song_list = song_list ) for url in song_list . urls ] ) # type: ignore return songs","title":"Module spotdl.utils.search"},{"location":"reference/spotdl/utils/search/#functions","text":"","title":"Functions"},{"location":"reference/spotdl/utils/search/#create_empty_song","text":"def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List [ str ]] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List [ str ]] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ ForwardRef ( 'SongList' )] = None ) -> spotdl . types . song . Song Create an empty song.","title":"create_empty_song"},{"location":"reference/spotdl/utils/search/#arguments","text":"name: Name of the song artists: List of artists album_name: Name of the album album_artist: Name of the album artist genres: List of genres disc_number: Disc number disc_count: Disc count duration: Duration of the song in seconds year: Year of release date: Date of release track_number: Track number tracks_count: Number of tracks isrc: ISRC code song_id: Spotify song ID cover_url: URL of the cover art explicit: Explicit flag publisher: Publisher url: URL of the song copyright_text: Copyright text download_url: Download URL song_list: Song list","title":"Arguments"},{"location":"reference/spotdl/utils/search/#returns","text":"Song object View Source def create_empty_song ( name : Optional [ str ] = None , artists : Optional [ List[str ] ] = None , album_name : Optional [ str ] = None , album_artist : Optional [ str ] = None , genres : Optional [ List[str ] ] = None , disc_number : Optional [ int ] = None , disc_count : Optional [ int ] = None , duration : Optional [ int ] = None , year : Optional [ int ] = None , date : Optional [ str ] = None , track_number : Optional [ int ] = None , tracks_count : Optional [ int ] = None , isrc : Optional [ str ] = None , song_id : Optional [ str ] = None , cover_url : Optional [ str ] = None , explicit : Optional [ bool ] = None , publisher : Optional [ str ] = None , url : Optional [ str ] = None , copyright_text : Optional [ str ] = None , download_url : Optional [ str ] = None , song_list : Optional [ \"SongList\" ] = None , ) -> Song : \"\"\" Create an empty song. ### Arguments - name: Name of the song - artists: List of artists - album_name: Name of the album - album_artist: Name of the album artist - genres: List of genres - disc_number: Disc number - disc_count: Disc count - duration: Duration of the song in seconds - year: Year of release - date: Date of release - track_number: Track number - tracks_count: Number of tracks - isrc: ISRC code - song_id: Spotify song ID - cover_url: URL of the cover art - explicit: Explicit flag - publisher: Publisher - url: URL of the song - copyright_text: Copyright text - download_url: Download URL - song_list: Song list ### Returns - Song object \"\"\" return Song ( name = name , # type : ignore artists = artists , # type : ignore artist = None if artists is None else artists [ 0 ] , # type : ignore album_name = album_name , # type : ignore album_artist = album_artist , # type : ignore genres = genres , # type : ignore disc_number = disc_number , # type : ignore disc_count = disc_count , # type : ignore duration = duration , # type : ignore year = year , # type : ignore date = date , # type : ignore track_number = track_number , # type : ignore tracks_count = tracks_count , # type : ignore isrc = isrc , # type : ignore song_id = song_id , # type : ignore cover_url = cover_url , # type : ignore explicit = explicit , # type : ignore publisher = publisher , # type : ignore url = url , # type : ignore copyright_text = copyright_text , download_url = download_url , song_list = song_list , )","title":"Returns"},{"location":"reference/spotdl/utils/search/#get_search_results","text":"def get_search_results ( search_term : str ) -> List [ spotdl . types . song . Song ] Creates a list of Song objects from a search term.","title":"get_search_results"},{"location":"reference/spotdl/utils/search/#arguments_1","text":"search_term: the search term to use","title":"Arguments"},{"location":"reference/spotdl/utils/search/#returns_1","text":"a list of Song objects View Source def get_search_results ( search_term : str ) -> List [ Song ] : \"\"\" Creates a list of Song objects from a search term. ### Arguments - search_term: the search term to use ### Returns - a list of Song objects \"\"\" spotify_client = SpotifyClient () raw_search_results = spotify_client . search ( search_term ) if ( raw_search_results is None or len ( raw_search_results . get ( \"tracks\" , {} ). get ( \"items\" , [] )) == 0 ) : raise SongError ( \"No songs matches found on spotify\" ) songs = [] for index , _ in enumerate ( raw_search_results [ \"tracks\" ][ \"items\" ] ) : songs . append ( Song . from_url ( \"http://open.spotify.com/track/\" + raw_search_results [ \"tracks\" ][ \"items\" ][ index ][ \"id\" ] ) ) return songs","title":"Returns"},{"location":"reference/spotdl/utils/search/#get_simple_songs","text":"def get_simple_songs ( query : List [ str ] ) -> List [ spotdl . types . song . Song ] Parse query and return list containing simple song objects","title":"get_simple_songs"},{"location":"reference/spotdl/utils/search/#arguments_2","text":"query: List of strings containing query","title":"Arguments"},{"location":"reference/spotdl/utils/search/#returns_2","text":"List of simple song objects View Source def get_simple_songs ( query : List [ str ] , ) -> List [ Song ] : \"\"\" Parse query and return list containing simple song objects ### Arguments - query: List of strings containing query ### Returns - List of simple song objects \"\"\" songs : List [ Song ] = [] lists : List [ SongList ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ) : split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ) : raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( create_empty_song ( url = split_urls [ 1 ] , download_url = split_urls [ 0 ] ) ) elif \"open.spotify.com\" in request and \"track\" in request : songs . append ( create_empty_song ( url = request )) # type : ignore elif \"open.spotify.com\" in request and \"playlist\" in request : lists . append ( Playlist . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"album\" in request : lists . append ( Album . create_basic_list ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : lists . append ( Artist . create_basic_list ( request )) elif request == \"saved\" : lists . append ( Saved . create_basic_list ()) elif request . endswith ( \".spotdl\" ) : with open ( request , \"r\" , encoding = \"utf-8\" ) as save_file : for track in json . load ( save_file ) : # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) for song_list in lists : songs . extend ( [ create_empty_song(url=url, song_list=song_list) for url in song_list.urls ] ) # type : ignore return songs","title":"Returns"},{"location":"reference/spotdl/utils/search/#parse_query","text":"def parse_query ( query : List [ str ], threads : int = 1 ) -> List [ spotdl . types . song . Song ] Parse query and return list containing song object","title":"parse_query"},{"location":"reference/spotdl/utils/search/#arguments_3","text":"query: List of strings containing query threads: Number of threads to use","title":"Arguments"},{"location":"reference/spotdl/utils/search/#returns_3","text":"List of song objects View Source def parse_query ( query : List [ str ] , threads : int = 1 , ) -> List [ Song ] : \"\"\" Parse query and return list containing song object ### Arguments - query: List of strings containing query - threads: Number of threads to use ### Returns - List of song objects \"\"\" urls : List [ str ] = [] songs : List [ Song ] = [] for request in query : if ( \"youtube.com/watch?v=\" in request or \"youtu.be/\" in request and \"open.spotify.com\" in request and \"track\" in request and \"|\" in request ) : split_urls = request . split ( \"|\" ) if ( len ( split_urls ) <= 1 or \"youtube\" not in split_urls [ 0 ] and \"youtu.be\" not in split_urls [ 0 ] or \"spotify\" not in split_urls [ 1 ] ) : raise QueryError ( \"Incorrect format used, please use YouTubeURL|SpotifyURL\" ) songs . append ( Song . from_dict ( { ** Song . from_url ( split_urls [ 1 ] ). json , \"download_url\" : split_urls [ 0 ] , } ) ) elif \"open.spotify.com\" in request and \"track\" in request : urls . append ( request ) elif \"open.spotify.com\" in request and \"playlist\" in request : urls . extend ( Playlist . get_urls ( request )) elif \"open.spotify.com\" in request and \"album\" in request : urls . extend ( Album . get_urls ( request )) elif \"open.spotify.com\" in request and \"artist\" in request : for album_url in Artist . get_albums ( request ) : urls . extend ( Album . get_urls ( album_url )) elif request == \"saved\" : urls . extend ( Saved . get_urls ( \"saved\" )) elif request . endswith ( \".spotdl\" ) : with open ( request , \"r\" , encoding = \"utf-8\" ) as m3u_file : for track in json . load ( m3u_file ) : # Append to songs songs . append ( Song . from_dict ( track )) else : songs . append ( Song . from_search_term ( request )) with concurrent . futures . ThreadPoolExecutor ( max_workers = threads ) as executor : for song in executor . map ( Song . from_url , urls ) : songs . append ( song ) return songs","title":"Returns"},{"location":"reference/spotdl/utils/search/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/utils/search/#queryerror","text":"class QueryError ( / , * args , ** kwargs ) View Source class QueryError ( Exception ): \"\"\" Base class for all exceptions related to query. \"\"\"","title":"QueryError"},{"location":"reference/spotdl/utils/search/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/search/#class-variables","text":"args","title":"Class variables"},{"location":"reference/spotdl/utils/search/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/utils/search/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/spotdl/utils/spotify/","text":"Module spotdl.utils.spotify Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret. >>> import spotdl.utils.spotify >>> spotify . Spotify . init ( client_id , client_secret ) View Source \"\"\" Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret. >>> import spotdl.utils.spotify >>> spotify.Spotify.init(client_id, client_secret) \"\"\" from typing import Optional from spotipy import Spotify from spotipy.cache_handler import CacheFileHandler , MemoryCacheHandler from spotipy.oauth2 import SpotifyClientCredentials , SpotifyOAuth from spotdl.utils.config import get_cache_path class SpotifyError ( Exception ): \"\"\" Base class for all exceptions related to SpotifyClient. \"\"\" class Singleton ( type ): \"\"\" Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance. \"\"\" _instance = None def __call__ ( self ): # pylint: disable=bad-mcs-method-argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance def init ( # pylint: disable=bad-mcs-method-argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed, if yes, raise an Exception if isinstance ( self . _instance , self ): raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super () . __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance class SpotifyClient ( Spotify , metaclass = Singleton ): \"\"\" This is the Spotify client meant to be used in the app. Has to be initialized first by calling `SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)`. \"\"\" _initialized = False def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth_manager: The auth manager to use. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _initialized = True Classes Singleton class Singleton ( / , * args , ** kwargs ) View Source class Singleton ( type ) : \"\"\" Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance. \"\"\" _instance = None def __call__ ( self ) : # pylint : disable = bad - mcs - method - argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance def init ( # pylint : disable = bad - mcs - method - argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed , if yes , raise an Exception if isinstance ( self . _instance , self ) : raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super (). __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance Ancestors (in MRO) builtins.type Methods init def init ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True ) -> 'Singleton' Initializes the SpotifyClient. Arguments client_id: The client ID of the application. client_secret: The client secret of the application. user_auth: Whether or not to use user authentication. cache_path: The path to the cache file. no_cache: Whether or not to use the cache. open_browser: Whether or not to open the browser. Returns The instance of the SpotifyClient. View Source def init ( # pylint : disable = bad - mcs - method - argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed , if yes , raise an Exception if isinstance ( self . _instance , self ) : raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super (). __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance mro def mro ( self , / ) Return a type's method resolution order. SpotifyClient class SpotifyClient ( * args , ** kwargs ) View Source class SpotifyClient ( Spotify , metaclass = Singleton ): \"\"\" This is the Spotify client meant to be used in the app. Has to be initialized first by calling `SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)`. \"\"\" _initialized = False def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth_manager: The auth manager to use. \"\"\" super (). __init__ (* args , ** kwargs ) self . _initialized = True Ancestors (in MRO) spotipy.client.Spotify Class variables country_codes default_retry_codes max_retries Instance variables auth_manager Methods add_to_queue def add_to_queue ( self , uri , device_id = None ) Adds a song to the end of a user's queue If device A is currently playing music and you try to add to the queue and pass in the id for device B, you will get a 'Player command failed: Restriction violated' error I therefore reccomend leaving device_id as None so that the active device is targeted Parameters: Name Type Description Default uri None song uri, id, or url None device_id None the id of a Spotify device. If None, then the active device is used. None View Source def add_to_queue ( self , uri , device_id = None ) : \"\"\" Adds a song to the end of a user's queue If device A is currently playing music and you try to add to the queue and pass in the id for device B , you will get a ' Player command failed: Restriction violated ' error I therefore reccomend leaving device_id as None so that the active device is targeted : param uri : song uri , id , or url : param device_id : the id of a Spotify device . If None , then the active device is used . \"\"\" uri = self . _get_uri ( \" track \" , uri ) endpoint = \" me/player/queue?uri=%s \" % uri if device_id is not None : endpoint += \" &device_id=%s \" % device_id return self . _post ( endpoint ) album def album ( self , album_id ) returns a single album given the album's ID, URIs or URL Parameters: - album_id - the album ID, URI or URL View Source def album ( self , album_id ) : \"\"\" returns a single album given the album's ID, URIs or URL Parameters : - album_id - the album ID , URI or URL \"\"\" trid = self . _get_id ( \" album \" , album_id ) return self . _get ( \" albums/ \" + trid ) album_tracks def album_tracks ( self , album_id , limit = 50 , offset = 0 , market = None ) Get Spotify catalog information about an album's tracks Parameters: - album_id - the album ID, URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166-1 alpha-2 country code. View Source def album_tracks ( self , album_id , limit = 50 , offset = 0 , market = None ) : \"\"\" Get Spotify catalog information about an album's tracks Parameters : - album_id - the album ID , URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" trid = self . _get_id ( \" album \" , album_id ) return self . _get ( \" albums/ \" + trid + \" /tracks/ \" , limit = limit , offset = offset , market = market ) albums def albums ( self , albums ) returns a list of albums given the album IDs, URIs, or URLs Parameters: - albums - a list of album IDs, URIs or URLs View Source def albums ( self , albums ) : \"\"\" returns a list of albums given the album IDs, URIs, or URLs Parameters : - albums - a list of album IDs , URIs or URLs \"\"\" tlist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _get ( \" albums/?ids= \" + \" , \" . join ( tlist )) artist def artist ( self , artist_id ) returns a single artist given the artist's ID, URI or URL Parameters: - artist_id - an artist ID, URI or URL View Source def artist ( self , artist_id ) : \"\"\" returns a single artist given the artist's ID, URI or URL Parameters : - artist_id - an artist ID , URI or URL \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid ) artist_albums def artist_albums ( self , artist_id , album_type = None , country = None , limit = 20 , offset = 0 ) Get Spotify catalog information about an artist's albums Parameters: - artist_id - the artist ID, URI or URL - album_type - 'album', 'single', 'appears_on', 'compilation' - country - limit the response to one particular country. - limit - the number of albums to return - offset - the index of the first album to return View Source def artist_albums ( self , artist_id , album_type = None , country = None , limit = 20 , offset = 0 ) : \"\"\" Get Spotify catalog information about an artist's albums Parameters : - artist_id - the artist ID , URI or URL - album_type - ' album ' , ' single ' , ' appears_on ' , ' compilation ' - country - limit the response to one particular country . - limit - the number of albums to return - offset - the index of the first album to return \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /albums \" , album_type = album_type , country = country , limit = limit , offset = offset , ) artist_related_artists def artist_related_artists ( self , artist_id ) Get Spotify catalog information about artists similar to an identified artist. Similarity is based on analysis of the Spotify community's listening history. Parameters: - artist_id - the artist ID, URI or URL View Source def artist_related_artists ( self , artist_id ) : \"\"\" Get Spotify catalog information about artists similar to an identified artist . Similarity is based on analysis of the Spotify community ' s listening history. Parameters : - artist_id - the artist ID , URI or URL \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /related-artists \" ) artist_top_tracks def artist_top_tracks ( self , artist_id , country = 'US' ) Get Spotify catalog information about an artist's top 10 tracks by country. Parameters: - artist_id - the artist ID, URI or URL - country - limit the response to one particular country. View Source def artist_top_tracks ( self , artist_id , country = \" US \" ) : \"\"\" Get Spotify catalog information about an artist's top 10 tracks by country . Parameters : - artist_id - the artist ID , URI or URL - country - limit the response to one particular country . \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /top-tracks \" , country = country ) artists def artists ( self , artists ) returns a list of artists given the artist IDs, URIs, or URLs Parameters: - artists - a list of artist IDs, URIs or URLs View Source def artists ( self , artists ) : \"\"\" returns a list of artists given the artist IDs, URIs, or URLs Parameters : - artists - a list of artist IDs , URIs or URLs \"\"\" tlist = [ self . _get_id ( \" artist \" , a ) for a in artists ] return self . _get ( \" artists/?ids= \" + \" , \" . join ( tlist )) audio_analysis def audio_analysis ( self , track_id ) Get audio analysis for a track based upon its Spotify ID Parameters: - track_id - a track URI, URL or ID View Source def audio_analysis ( self , track_id ) : \"\"\" Get audio analysis for a track based upon its Spotify ID Parameters : - track_id - a track URI , URL or ID \"\"\" trid = self . _get_id ( \" track \" , track_id ) return self . _get ( \" audio-analysis/ \" + trid ) audio_features def audio_features ( self , tracks = [] ) Get audio features for one or multiple tracks based upon their Spotify IDs Parameters: Name Type Description Default - tracks - a list of track URIs, URLs or IDs, maximum None 100 ids None View Source def audio_features ( self , tracks = [] ) : \"\"\" Get audio features for one or multiple tracks based upon their Spotify IDs Parameters : - tracks - a list of track URIs , URLs or IDs , maximum : 100 ids \"\"\" if isinstance ( tracks , str ) : trackid = self . _get_id ( \" track \" , tracks ) results = self . _get ( \" audio-features/?ids= \" + trackid ) else : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] results = self . _get ( \" audio-features/?ids= \" + \" , \" . join ( tlist )) # the response has changed , look for the new style first , and if # its not there , fallback on the old style if \" audio_features \" in results : return results [ \" audio_features \" ] else : return results available_markets def available_markets ( self ) Get the list of markets where Spotify is available. Returns a list of the countries in which Spotify is available, identified by their ISO 3166-1 alpha-2 country code with additional country codes for special territories. View Source def available_markets ( self ) : \"\"\" Get the list of markets where Spotify is available. Returns a list of the countries in which Spotify is available , identified by their ISO 3166 - 1 alpha - 2 country code with additional country codes for special territories . \"\"\" return self . _get ( \" markets \" ) categories def categories ( self , country = None , locale = None , limit = 20 , offset = 0 ) Get a list of categories Parameters: - country - An ISO 3166-1 alpha-2 country code. - locale - The desired language, consisting of an ISO 639 language code and an ISO 3166-1 alpha-2 country code, joined by an underscore. - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def categories ( self , country = None , locale = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of categories Parameters : - country - An ISO 3166 - 1 alpha - 2 country code . - locale - The desired language , consisting of an ISO 639 language code and an ISO 3166 - 1 alpha - 2 country code , joined by an underscore . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/categories \" , country = country , locale = locale , limit = limit , offset = offset , ) category def category ( self , category_id , country = None , locale = None ) Get info about a category Parameters: - category_id - The Spotify category ID for the category. - country - An ISO 3166-1 alpha-2 country code. - locale - The desired language, consisting of an ISO 639 language code and an ISO 3166-1 alpha-2 country code, joined by an underscore. View Source def category ( self , category_id , country = None , locale = None ) : \"\"\" Get info about a category Parameters : - category_id - The Spotify category ID for the category . - country - An ISO 3166 - 1 alpha - 2 country code . - locale - The desired language , consisting of an ISO 639 language code and an ISO 3166 - 1 alpha - 2 country code , joined by an underscore . \"\"\" return self . _get ( \" browse/categories/ \" + category_id , country = country , locale = locale , ) category_playlists def category_playlists ( self , category_id = None , country = None , limit = 20 , offset = 0 ) Get a list of playlists for a specific Spotify category Parameters: - category_id - The Spotify category ID for the category. - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def category_playlists ( self , category_id = None , country = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of playlists for a specific Spotify category Parameters : - category_id - The Spotify category ID for the category . - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/categories/ \" + category_id + \" /playlists \" , country = country , limit = limit , offset = offset , ) current_playback def current_playback ( self , market = None , additional_types = None ) Get information about user's current playback. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - episode to get podcast track information View Source def current_playback ( self , market = None , additional_types = None ) : \" \"\" Get information about user's current playback. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - `episode` to get podcast track information \"\" \" return self . _get ( \"me/player\" , market = market , additional_types = additional_types ) current_user def current_user ( self ) Get detailed profile information about the current user. An alias for the 'me' method. View Source def current_user ( self ) : \"\"\" Get detailed profile information about the current user. An alias for the ' me ' method . \"\"\" return self . me () current_user_follow_playlist def current_user_follow_playlist ( self , playlist_id ) Add the current authenticated user as a follower of a playlist. Parameters: - playlist_id - the id of the playlist View Source def current_user_follow_playlist ( self , playlist_id ) : \"\"\" Add the current authenticated user as a follower of a playlist . Parameters : - playlist_id - the id of the playlist \"\"\" return self . _put ( \" playlists/{}/followers \" . format ( playlist_id ) ) current_user_followed_artists def current_user_followed_artists ( self , limit = 20 , after = None ) Gets a list of the artists followed by the current authorized user Parameters: - limit - the number of artists to return - after - the last artist ID retrieved from the previous request View Source def current_user_followed_artists ( self , limit = 20 , after = None ) : \"\"\" Gets a list of the artists followed by the current authorized user Parameters : - limit - the number of artists to return - after - the last artist ID retrieved from the previous request \"\"\" return self . _get ( \" me/following \" , type = \" artist \" , limit = limit , after = after ) current_user_following_artists def current_user_following_artists ( self , ids = None ) Check if the current user is following certain artists Returns list of booleans respective to ids Parameters: - ids - a list of artist URIs, URLs or IDs View Source def current_user_following_artists ( self , ids = None ) : \"\"\" Check if the current user is following certain artists Returns list of booleans respective to ids Parameters : - ids - a list of artist URIs , URLs or IDs \"\"\" idlist = [] if ids is not None : idlist = [ self . _get_id ( \" artist \" , i ) for i in ids ] return self . _get ( \" me/following/contains \" , ids = \" , \" . join ( idlist ) , type = \" artist \" ) current_user_following_users def current_user_following_users ( self , ids = None ) Check if the current user is following certain artists Returns list of booleans respective to ids Parameters: - ids - a list of user URIs, URLs or IDs View Source def current_user_following_users ( self , ids = None ) : \"\"\" Check if the current user is following certain artists Returns list of booleans respective to ids Parameters : - ids - a list of user URIs , URLs or IDs \"\"\" idlist = [] if ids is not None : idlist = [ self . _get_id ( \" user \" , i ) for i in ids ] return self . _get ( \" me/following/contains \" , ids = \" , \" . join ( idlist ) , type = \" user \" ) current_user_playing_track def current_user_playing_track ( self ) Get information about the current users currently playing track. View Source def current_user_playing_track ( self ) : \"\"\" Get information about the current users currently playing track. \"\"\" return self . _get ( \" me/player/currently-playing \" ) current_user_playlists def current_user_playlists ( self , limit = 50 , offset = 0 ) Get current user playlists without required getting his profile Parameters: - limit - the number of items to return - offset - the index of the first item to return View Source def current_user_playlists ( self , limit = 50 , offset = 0 ) : \"\"\" Get current user playlists without required getting his profile Parameters : - limit - the number of items to return - offset - the index of the first item to return \"\"\" return self . _get ( \" me/playlists \" , limit = limit , offset = offset ) current_user_recently_played def current_user_recently_played ( self , limit = 50 , after = None , before = None ) Get the current user's recently played tracks Parameters: - limit - the number of entities to return - after - unix timestamp in milliseconds. Returns all items after (but not including) this cursor position. Cannot be used if before is specified. - before - unix timestamp in milliseconds. Returns all items before (but not including) this cursor position. Cannot be used if after is specified View Source def current_user_recently_played ( self , limit = 50 , after = None , before = None ) : \"\"\" Get the current user's recently played tracks Parameters : - limit - the number of entities to return - after - unix timestamp in milliseconds . Returns all items after ( but not including ) this cursor position . Cannot be used if before is specified . - before - unix timestamp in milliseconds . Returns all items before ( but not including ) this cursor position . Cannot be used if after is specified \"\"\" return self . _get ( \" me/player/recently-played \" , limit = limit , after = after , before = before , ) current_user_saved_albums def current_user_saved_albums ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the albums saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of albums to return (MAX_LIMIT=50) - offset - the index of the first album to return - market - an ISO 3166-1 alpha-2 country code. View Source def current_user_saved_albums ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the albums saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of albums to return ( MAX_LIMIT = 50 ) - offset - the index of the first album to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" return self . _get ( \" me/albums \" , limit = limit , offset = offset , market = market ) current_user_saved_albums_add def current_user_saved_albums_add ( self , albums = [] ) Add one or more albums to the current user's \"Your Music\" library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_add ( self , albums = [] ) : \"\"\" Add one or more albums to the current user's \" Your Music \" library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _put ( \" me/albums?ids= \" + \" , \" . join ( alist )) current_user_saved_albums_contains def current_user_saved_albums_contains ( self , albums = [] ) Check if one or more albums is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_contains ( self , albums = [] ) : \"\"\" Check if one or more albums is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _get ( \" me/albums/contains?ids= \" + \" , \" . join ( alist )) current_user_saved_albums_delete def current_user_saved_albums_delete ( self , albums = [] ) Remove one or more albums from the current user's \"Your Music\" library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_delete ( self , albums = [] ) : \"\"\" Remove one or more albums from the current user's \" Your Music \" library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _delete ( \" me/albums/?ids= \" + \" , \" . join ( alist )) current_user_saved_episodes def current_user_saved_episodes ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the episodes saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of episodes to return - offset - the index of the first episode to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_episodes ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the episodes saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of episodes to return - offset - the index of the first episode to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/episodes \" , limit = limit , offset = offset , market = market ) current_user_saved_episodes_add def current_user_saved_episodes_add ( self , episodes = None ) Add one or more episodes to the current user's \"Your Music\" library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_add ( self , episodes = None ) : \"\"\" Add one or more episodes to the current user's \" Your Music \" library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _put ( \" me/episodes/?ids= \" + \" , \" . join ( elist )) current_user_saved_episodes_contains def current_user_saved_episodes_contains ( self , episodes = None ) Check if one or more episodes is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_contains ( self , episodes = None ) : \"\"\" Check if one or more episodes is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _get ( \" me/episodes/contains?ids= \" + \" , \" . join ( elist )) current_user_saved_episodes_delete def current_user_saved_episodes_delete ( self , episodes = None ) Remove one or more episodes from the current user's \"Your Music\" library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_delete ( self , episodes = None ) : \"\"\" Remove one or more episodes from the current user's \" Your Music \" library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _delete ( \" me/episodes/?ids= \" + \" , \" . join ( elist )) current_user_saved_shows def current_user_saved_shows ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the shows saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of shows to return - offset - the index of the first show to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_shows ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the shows saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of shows to return - offset - the index of the first show to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/shows \" , limit = limit , offset = offset , market = market ) current_user_saved_shows_add def current_user_saved_shows_add ( self , shows = [] ) Add one or more albums to the current user's \"Your Music\" library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_add ( self , shows = [] ) : \"\"\" Add one or more albums to the current user's \" Your Music \" library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _put ( \" me/shows?ids= \" + \" , \" . join ( slist )) current_user_saved_shows_contains def current_user_saved_shows_contains ( self , shows = [] ) Check if one or more shows is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_contains ( self , shows = [] ) : \"\"\" Check if one or more shows is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _get ( \" me/shows/contains?ids= \" + \" , \" . join ( slist )) current_user_saved_shows_delete def current_user_saved_shows_delete ( self , shows = [] ) Remove one or more shows from the current user's \"Your Music\" library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_delete ( self , shows = [] ) : \"\"\" Remove one or more shows from the current user's \" Your Music \" library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _delete ( \" me/shows/?ids= \" + \" , \" . join ( slist )) current_user_saved_tracks def current_user_saved_tracks ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the tracks saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_tracks ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the tracks saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/tracks \" , limit = limit , offset = offset , market = market ) current_user_saved_tracks_add def current_user_saved_tracks_add ( self , tracks = None ) Add one or more tracks to the current user's \"Your Music\" library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_add ( self , tracks = None ) : \"\"\" Add one or more tracks to the current user's \" Your Music \" library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _put ( \" me/tracks/?ids= \" + \" , \" . join ( tlist )) current_user_saved_tracks_contains def current_user_saved_tracks_contains ( self , tracks = None ) Check if one or more tracks is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_contains ( self , tracks = None ) : \"\"\" Check if one or more tracks is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _get ( \" me/tracks/contains?ids= \" + \" , \" . join ( tlist )) current_user_saved_tracks_delete def current_user_saved_tracks_delete ( self , tracks = None ) Remove one or more tracks from the current user's \"Your Music\" library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_delete ( self , tracks = None ) : \"\"\" Remove one or more tracks from the current user's \" Your Music \" library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _delete ( \" me/tracks/?ids= \" + \" , \" . join ( tlist )) current_user_top_artists def current_user_top_artists ( self , limit = 20 , offset = 0 , time_range = 'medium_term' ) Get the current user's top artists Parameters: - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid-values: short_term, medium_term, long_term View Source def current_user_top_artists ( self , limit = 20 , offset = 0 , time_range = \" medium_term \" ) : \"\"\" Get the current user's top artists Parameters : - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid - values : short_term , medium_term , long_term \"\"\" return self . _get ( \" me/top/artists \" , time_range = time_range , limit = limit , offset = offset ) current_user_top_tracks def current_user_top_tracks ( self , limit = 20 , offset = 0 , time_range = 'medium_term' ) Get the current user's top tracks Parameters: - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid-values: short_term, medium_term, long_term View Source def current_user_top_tracks ( self , limit = 20 , offset = 0 , time_range = \" medium_term \" ) : \"\"\" Get the current user's top tracks Parameters : - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid - values : short_term , medium_term , long_term \"\"\" return self . _get ( \" me/top/tracks \" , time_range = time_range , limit = limit , offset = offset ) current_user_unfollow_playlist def current_user_unfollow_playlist ( self , playlist_id ) Unfollows (deletes) a playlist for the current authenticated user Parameters: - name - the name of the playlist View Source def current_user_unfollow_playlist ( self , playlist_id ) : \"\"\" Unfollows (deletes) a playlist for the current authenticated user Parameters : - name - the name of the playlist \"\"\" return self . _delete ( \" playlists/%s/followers \" % ( playlist_id ) ) currently_playing def currently_playing ( self , market = None , additional_types = None ) Get user's currently playing track. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - episode to get podcast track information View Source def currently_playing ( self , market = None , additional_types = None ) : \" \"\" Get user's currently playing track. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - `episode` to get podcast track information \"\" \" return self . _get ( \"me/player/currently-playing\" , market = market , additional_types = additional_types ) devices def devices ( self ) Get a list of user's available devices. View Source def devices ( self ) : \"\"\" Get a list of user's available devices. \"\"\" return self . _get ( \" me/player/devices \" ) episode def episode ( self , episode_id , market = None ) returns a single episode given the episode's ID, URIs or URL Parameters: - episode_id - the episode ID, URI or URL - market - an ISO 3166-1 alpha-2 country code. The episode must be available in the given market. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def episode ( self , episode_id , market = None ) : \"\"\" returns a single episode given the episode's ID, URIs or URL Parameters : - episode_id - the episode ID , URI or URL - market - an ISO 3166 - 1 alpha - 2 country code . The episode must be available in the given market . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" episode \" , episode_id ) return self . _get ( \" episodes/ \" + trid , market = market ) episodes def episodes ( self , episodes , market = None ) returns a list of episodes given the episode IDs, URIs, or URLs Parameters: - episodes - a list of episode IDs, URIs or URLs - market - an ISO 3166-1 alpha-2 country code. Only episodes available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def episodes ( self , episodes , market = None ) : \"\"\" returns a list of episodes given the episode IDs, URIs, or URLs Parameters : - episodes - a list of episode IDs , URIs or URLs - market - an ISO 3166 - 1 alpha - 2 country code . Only episodes available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" tlist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _get ( \" episodes/?ids= \" + \" , \" . join ( tlist ) , market = market ) featured_playlists def featured_playlists ( self , locale = None , country = None , timestamp = None , limit = 20 , offset = 0 ) Get a list of Spotify featured playlists Parameters: - locale - The desired language, consisting of a lowercase ISO 639 language code and an uppercase ISO 3166-1 alpha-2 country code, joined by an underscore. - country - An ISO 3166 - 1 alpha - 2 country code . - timestamp - A timestamp in ISO 8601 format : yyyy - MM - ddTHH : mm : ss . Use this parameter to specify the user ' s local time to get results tailored for that specific date and time in the day - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def featured_playlists ( self , locale = None , country = None , timestamp = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of Spotify featured playlists Parameters : - locale - The desired language , consisting of a lowercase ISO 639 language code and an uppercase ISO 3166 - 1 alpha - 2 country code , joined by an underscore . - country - An ISO 3166 - 1 alpha - 2 country code . - timestamp - A timestamp in ISO 8601 format : yyyy - MM - ddTHH : mm : ss . Use this parameter to specify the user ' s local time to get results tailored for that specific date and time in the day - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/featured-playlists \" , locale = locale , country = country , timestamp = timestamp , limit = limit , offset = offset , ) me def me ( self ) Get detailed profile information about the current user. An alias for the 'current_user' method. View Source def me ( self ) : \"\"\" Get detailed profile information about the current user. An alias for the ' current_user ' method . \"\"\" return self . _get ( \" me/ \" ) new_releases def new_releases ( self , country = None , limit = 20 , offset = 0 ) Get a list of new album releases featured in Spotify Parameters: - country - An ISO 3166-1 alpha-2 country code. - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def new_releases ( self , country = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of new album releases featured in Spotify Parameters : - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/new-releases \" , country = country , limit = limit , offset = offset ) next def next ( self , result ) returns the next result given a paged result Parameters: - result - a previously returned paged result View Source def next ( self , result ) : \"\"\" returns the next result given a paged result Parameters : - result - a previously returned paged result \"\"\" if result [ \" next \" ]: return self . _get ( result [ \" next \" ] ) else : return None next_track def next_track ( self , device_id = None ) Skip user's playback to next track. Parameters: - device_id - device target for playback View Source def next_track ( self , device_id = None ) : \"\"\" Skip user's playback to next track. Parameters : - device_id - device target for playback \"\"\" return self . _post ( self . _append_device_id ( \" me/player/next \" , device_id )) pause_playback def pause_playback ( self , device_id = None ) Pause user's playback. Parameters: - device_id - device target for playback View Source def pause_playback ( self , device_id = None ) : \"\"\" Pause user's playback. Parameters : - device_id - device target for playback \"\"\" return self . _put ( self . _append_device_id ( \" me/player/pause \" , device_id )) playlist def playlist ( self , playlist_id , fields = None , market = None , additional_types = ( 'track' ,) ) Gets playlist by id. Parameters: - playlist - the id of the playlist - fields - which fields to return - market - An ISO 3166-1 alpha-2 country code or the string from_token. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist ( self , playlist_id , fields = None , market = None , additional_types = ( \" track \" , )) : \"\"\" Gets playlist by id. Parameters : - playlist - the id of the playlist - fields - which fields to return - market - An ISO 3166 - 1 alpha - 2 country code or the string from_token . - additional_types - list of item types to return . valid types are : track and episode \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s \" % ( plid ) , fields = fields , market = market , additional_types = \" , \" . join ( additional_types ) , ) playlist_add_items def playlist_add_items ( self , playlist_id , items , position = None ) Adds tracks/episodes to a playlist Parameters: - playlist_id - the id of the playlist - items - a list of track/episode URIs, URLs or IDs - position - the position to add the tracks View Source def playlist_add_items ( self , playlist_id , items , position = None ): \"\"\" Adds tracks/episodes to a playlist Parameters: - playlist_id - the id of the playlist - items - a list of track/episode URIs, URLs or IDs - position - the position to add the tracks \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] return self . _post ( \"playlists/ %s /tracks\" % ( plid ), payload = ftracks , position = position , ) playlist_change_details def playlist_change_details ( self , playlist_id , name = None , public = None , collaborative = None , description = None ) Changes a playlist's name and/or public/private state Parameters: - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist View Source def playlist_change_details ( self , playlist_id , name = None , public = None , collaborative = None , description = None , ): \"\"\" Changes a playlist's name and/or public/private state Parameters: - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist \"\"\" data = {} if isinstance ( name , six . string_types ): data [ \"name\" ] = name if isinstance ( public , bool ): data [ \"public\" ] = public if isinstance ( collaborative , bool ): data [ \"collaborative\" ] = collaborative if isinstance ( description , six . string_types ): data [ \"description\" ] = description return self . _put ( \"playlists/ %s \" % ( self . _get_id ( \"playlist\" , playlist_id )), payload = data ) playlist_cover_image def playlist_cover_image ( self , playlist_id ) Get cover of a playlist. Parameters: - playlist_id - the id of the playlist View Source def playlist_cover_image ( self , playlist_id ) : \"\"\" Get cover of a playlist. Parameters : - playlist_id - the id of the playlist \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s/images \" % ( plid )) playlist_is_following def playlist_is_following ( self , playlist_id , user_ids ) Check to see if the given users are following the given playlist Parameters: - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist. Maximum: 5 ids. View Source def playlist_is_following ( self , playlist_id , user_ids ) : \"\"\" Check to see if the given users are following the given playlist Parameters : - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist . Maximum : 5 ids . \"\"\" endpoint = \" playlists/{}/followers/contains?ids={} \" return self . _get ( endpoint . format ( playlist_id , \" , \" . join ( user_ids )) ) playlist_items def playlist_items ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( 'track' , 'episode' ) ) Get full details of the tracks and episodes of a playlist. Parameters: - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist_items ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( \" track \" , \" episode \" ) ) : \"\"\" Get full details of the tracks and episodes of a playlist. Parameters : - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . - additional_types - list of item types to return . valid types are : track and episode \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s/tracks \" % ( plid ) , limit = limit , offset = offset , fields = fields , market = market , additional_types = \" , \" . join ( additional_types ) ) playlist_remove_all_occurrences_of_items def playlist_remove_all_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot View Source def playlist_remove_all_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] payload = { \"tracks\" : [{ \"uri\" : track } for track in ftracks ]} if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"playlists/ %s /tracks\" % ( plid ), payload = payload ) playlist_remove_specific_occurrences_of_items def playlist_remove_specific_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - an array of objects containing Spotify URIs of the tracks/episodes to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot View Source def playlist_remove_specific_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - an array of objects containing Spotify URIs of the tracks/episodes to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [] for tr in items : ftracks . append ( { \"uri\" : self . _get_uri ( \"track\" , tr [ \"uri\" ]), \"positions\" : tr [ \"positions\" ], } ) payload = { \"tracks\" : ftracks } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"playlists/ %s /tracks\" % ( plid ), payload = payload ) playlist_reorder_items def playlist_reorder_items ( self , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None ) Reorder tracks in a playlist Parameters: - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID View Source def playlist_reorder_items ( self , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None , ): \"\"\" Reorder tracks in a playlist Parameters: - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) payload = { \"range_start\" : range_start , \"range_length\" : range_length , \"insert_before\" : insert_before , } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _put ( \"playlists/ %s /tracks\" % ( plid ), payload = payload ) playlist_replace_items def playlist_replace_items ( self , playlist_id , items ) Replace all tracks/episodes in a playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to comprise playlist View Source def playlist_replace_items ( self , playlist_id , items ): \"\"\" Replace all tracks/episodes in a playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to comprise playlist \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] payload = { \"uris\" : ftracks } return self . _put ( \"playlists/ %s /tracks\" % ( plid ), payload = payload ) playlist_tracks def playlist_tracks ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( 'track' ,) ) Get full details of the tracks of a playlist. Parameters: - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist_tracks ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( \" track \" , ) ) : \"\"\" Get full details of the tracks of a playlist. Parameters : - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . - additional_types - list of item types to return . valid types are : track and episode \"\"\" warnings . warn ( \" You should use `playlist_items(playlist_id, ..., \" \" additional_types=('track',))` instead \" , DeprecationWarning , ) return self . playlist_items ( playlist_id , fields , limit , offset , market , additional_types ) playlist_upload_cover_image def playlist_upload_cover_image ( self , playlist_id , image_b64 ) Replace the image used to represent a specific playlist Parameters: - playlist_id - the id of the playlist - image_b64 - image data as a Base64 encoded JPEG image string (maximum payload size is 256 KB) View Source def playlist_upload_cover_image ( self , playlist_id , image_b64 ): \"\"\" Replace the image used to represent a specific playlist Parameters: - playlist_id - the id of the playlist - image_b64 - image data as a Base64 encoded JPEG image string (maximum payload size is 256 KB) \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) return self . _put ( \"playlists/{}/images\" . format ( plid ), payload = image_b64 , content_type = \"image/jpeg\" , ) previous def previous ( self , result ) returns the previous result given a paged result Parameters: - result - a previously returned paged result View Source def previous ( self , result ) : \"\"\" returns the previous result given a paged result Parameters : - result - a previously returned paged result \"\"\" if result [ \" previous \" ]: return self . _get ( result [ \" previous \" ] ) else : return None previous_track def previous_track ( self , device_id = None ) Skip user's playback to previous track. Parameters: - device_id - device target for playback View Source def previous_track ( self , device_id = None ) : \"\"\" Skip user's playback to previous track. Parameters : - device_id - device target for playback \"\"\" return self . _post ( self . _append_device_id ( \" me/player/previous \" , device_id ) ) recommendation_genre_seeds def recommendation_genre_seeds ( self ) Get a list of genres available for the recommendations function. View Source def recommendation_genre_seeds ( self ) : \"\"\" Get a list of genres available for the recommendations function. \"\"\" return self . _get ( \" recommendations/available-genre-seeds \" ) recommendations def recommendations ( self , seed_artists = None , seed_genres = None , seed_tracks = None , limit = 20 , country = None , ** kwargs ) Get a list of recommended tracks for one to five seeds. (at least one of seed_artists , seed_tracks and seed_genres are needed) Parameters: - seed_artists - a list of artist IDs, URIs or URLs - seed_tracks - a list of track IDs, URIs or URLs - seed_genres - a list of genre names. Available genres for recommendations can be found by calling recommendation_genre_seeds - country - An ISO 3166 - 1 alpha - 2 country code . If provided , all results will be playable in this country . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 100 - min / max / target_ < attribute > - For the tuneable track attributes listed in the documentation , these values provide filters and targeting on results . View Source def recommendations ( self , seed_artists = None , seed_genres = None , seed_tracks = None , limit = 20 , country = None , ** kwargs ) : \" \"\" Get a list of recommended tracks for one to five seeds. (at least one of `seed_artists`, `seed_tracks` and `seed_genres` are needed) Parameters: - seed_artists - a list of artist IDs, URIs or URLs - seed_tracks - a list of track IDs, URIs or URLs - seed_genres - a list of genre names. Available genres for recommendations can be found by calling recommendation_genre_seeds - country - An ISO 3166-1 alpha-2 country code. If provided, all results will be playable in this country. - limit - The maximum number of items to return. Default: 20. Minimum: 1. Maximum: 100 - min/max/target_<attribute> - For the tuneable track attributes listed in the documentation, these values provide filters and targeting on results. \"\" \" params = dict ( limit = limit ) if seed_artists : params [ \"seed_artists\" ] = \",\" . join ( [ self . _get_id ( \"artist\" , a ) for a in seed_artists ] ) if seed_genres : params [ \"seed_genres\" ] = \",\" . join ( seed_genres ) if seed_tracks : params [ \"seed_tracks\" ] = \",\" . join ( [ self . _get_id ( \"track\" , t ) for t in seed_tracks ] ) if country : params [ \"market\" ] = country for attribute in [ \"acousticness\" , \"danceability\" , \"duration_ms\" , \"energy\" , \"instrumentalness\" , \"key\" , \"liveness\" , \"loudness\" , \"mode\" , \"popularity\" , \"speechiness\" , \"tempo\" , \"time_signature\" , \"valence\" , ] : for prefix in [ \"min_\" , \"max_\" , \"target_\" ] : param = prefix + attribute if param in kwargs : params [ param ] = kwargs [ param ] return self . _get ( \"recommendations\" , ** params ) repeat def repeat ( self , state , device_id = None ) Set repeat mode for playback. Parameters: - state - track , context , or off - device_id - device target for playback View Source def repeat ( self , state , device_id = None ) : \" \"\" Set repeat mode for playback. Parameters: - state - `track`, `context`, or `off` - device_id - device target for playback \"\" \" if state not in [ \"track\" , \"context\" , \"off\" ] : logger . warning ( \"Invalid state\" ) return self . _put ( self . _append_device_id ( \"me/player/repeat?state=%s\" % state , device_id ) ) search def search ( self , q , limit = 10 , offset = 0 , type = 'track' , market = None ) searches for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied within each type, not on the total response. - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', and 'episode'. If multiple types are desired, pass in a comma separated string; e.g., 'track,album,episode'. - market - An ISO 3166-1 alpha-2 country code or the string from_token. View Source def search ( self , q , limit = 10 , offset = 0 , type = \"track\" , market = None ): \"\"\" searches for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied within each type, not on the total response. - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', and 'episode'. If multiple types are desired, pass in a comma separated string; e.g., 'track,album,episode'. - market - An ISO 3166-1 alpha-2 country code or the string from_token. \"\"\" return self . _get ( \"search\" , q = q , limit = limit , offset = offset , type = type , market = market ) search_markets def search_markets ( self , q , limit = 10 , offset = 0 , type = 'track' , markets = None , total = None ) (experimental) Searches multiple markets for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). If a search is to be done on multiple markets, then this limit is applied to each market. (e.g. search US, CA, MX each with a limit of 10). - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', or 'episode'. If multiple types are desired, pass in a comma separated string. - markets - A list of ISO 3166-1 alpha-2 country codes. Search all country markets by default. - total - the total number of results to return if multiple markets are supplied in the search. If multiple types are specified, this only applies to the first type. View Source def search_markets ( self , q , limit = 10 , offset = 0 , type = \" track \" , markets = None , total = None ) : \"\"\" (experimental) Searches multiple markets for an item Parameters : - q - the search query ( see how to write a query in the official documentation https : // developer . spotify . com / documentation / web - api / reference / search / ) # noqa - limit - the number of items to return ( min = 1 , default = 10 , max = 50 ) . If a search is to be done on multiple markets , then this limit is applied to each market . ( e . g . search US , CA , MX each with a limit of 10 ) . - offset - the index of the first item to return - type - the types of items to return . One or more of ' artist ' , ' album ' , ' track ' , ' playlist ' , ' show ' , or ' episode ' . If multiple types are desired , pass in a comma separated string . - markets - A list of ISO 3166 - 1 alpha - 2 country codes . Search all country markets by default . - total - the total number of results to return if multiple markets are supplied in the search . If multiple types are specified , this only applies to the first type . \"\"\" warnings . warn ( \" Searching multiple markets is an experimental feature. \" \" Please be aware that this method's inputs and outputs can change in the future. \" , UserWarning , ) if not markets : markets = self . country_codes if not ( isinstance ( markets , list ) or isinstance ( markets , tuple )) : markets = [] warnings . warn ( \" Searching multiple markets is poorly performing. \" , UserWarning , ) return self . _search_multiple_markets ( q , limit , offset , type , markets , total ) seek_track def seek_track ( self , position_ms , device_id = None ) Seek to position in current track. Parameters: - position_ms - position in milliseconds to seek to - device_id - device target for playback View Source def seek_track ( self , position_ms , device_id = None ) : \"\"\" Seek to position in current track. Parameters : - position_ms - position in milliseconds to seek to - device_id - device target for playback \"\"\" if not isinstance ( position_ms , int ) : logger . warning ( \" Position_ms must be an integer \" ) return return self . _put ( self . _append_device_id ( \" me/player/seek?position_ms=%s \" % position_ms , device_id ) ) set_auth def set_auth ( self , auth ) View Source def set_auth(self, auth): self._auth = auth show def show ( self , show_id , market = None ) returns a single show given the show's ID, URIs or URL Parameters: - show_id - the show ID, URI or URL - market - an ISO 3166-1 alpha-2 country code. The show must be available in the given market. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def show ( self , show_id , market = None ) : \"\"\" returns a single show given the show's ID, URIs or URL Parameters : - show_id - the show ID , URI or URL - market - an ISO 3166 - 1 alpha - 2 country code . The show must be available in the given market . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" show \" , show_id ) return self . _get ( \" shows/ \" + trid , market = market ) show_episodes def show_episodes ( self , show_id , limit = 50 , offset = 0 , market = None ) Get Spotify catalog information about a show's episodes Parameters: - show_id - the show ID, URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166-1 alpha-2 country code. Only episodes available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def show_episodes ( self , show_id , limit = 50 , offset = 0 , market = None ) : \"\"\" Get Spotify catalog information about a show's episodes Parameters : - show_id - the show ID , URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166 - 1 alpha - 2 country code . Only episodes available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" show \" , show_id ) return self . _get ( \" shows/ \" + trid + \" /episodes/ \" , limit = limit , offset = offset , market = market ) shows def shows ( self , shows , market = None ) returns a list of shows given the show IDs, URIs, or URLs Parameters: - shows - a list of show IDs, URIs or URLs - market - an ISO 3166-1 alpha-2 country code. Only shows available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def shows ( self , shows , market = None ) : \"\"\" returns a list of shows given the show IDs, URIs, or URLs Parameters : - shows - a list of show IDs , URIs or URLs - market - an ISO 3166 - 1 alpha - 2 country code . Only shows available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" tlist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _get ( \" shows/?ids= \" + \" , \" . join ( tlist ) , market = market ) shuffle def shuffle ( self , state , device_id = None ) Toggle playback shuffling. Parameters: - state - true or false - device_id - device target for playback View Source def shuffle ( self , state , device_id = None ) : \"\"\" Toggle playback shuffling. Parameters : - state - true or false - device_id - device target for playback \"\"\" if not isinstance ( state , bool ) : logger . warning ( \" state must be a boolean \" ) return state = str ( state ) . lower () self . _put ( self . _append_device_id ( \" me/player/shuffle?state=%s \" % state , device_id ) ) start_playback def start_playback ( self , device_id = None , context_uri = None , uris = None , offset = None , position_ms = None ) Start or resume user's playback. Provide a context_uri to start playback or a album, artist, or playlist. Provide a uris list to start playback of one or more tracks. Provide offset as {\"position\": } or {\"uri\": \" \"} to start playback at a particular offset. Parameters: - device_id - device target for playback - context_uri - spotify context uri to play - uris - spotify track uris - offset - offset into context by index or track - position_ms - (optional) indicates from what position to start playback. Must be a positive number. Passing in a position that is greater than the length of the track will cause the player to start playing the next song. View Source def start_playback ( self , device_id = None , context_uri = None , uris = None , offset = None , position_ms = None ) : \" \"\" Start or resume user's playback. Provide a `context_uri` to start playback or a album, artist, or playlist. Provide a `uris` list to start playback of one or more tracks. Provide `offset` as {\" position \": <int>} or {\" uri \": \" < track uri > \"} to start playback at a particular offset. Parameters: - device_id - device target for playback - context_uri - spotify context uri to play - uris - spotify track uris - offset - offset into context by index or track - position_ms - (optional) indicates from what position to start playback. Must be a positive number. Passing in a position that is greater than the length of the track will cause the player to start playing the next song. \"\" \" if context_uri is not None and uris is not None : logger . warning ( \"Specify either context uri or uris, not both\" ) return if uris is not None and not isinstance ( uris , list ) : logger . warning ( \"URIs must be a list\" ) return data = {} if context_uri is not None : data [ \"context_uri\" ] = context_uri if uris is not None : data [ \"uris\" ] = uris if offset is not None : data [ \"offset\" ] = offset if position_ms is not None : data [ \"position_ms\" ] = position_ms return self . _put ( self . _append_device_id ( \"me/player/play\" , device_id ), payload = data ) track def track ( self , track_id , market = None ) returns a single track given the track's ID, URI or URL Parameters: - track_id - a spotify URI, URL or ID - market - an ISO 3166-1 alpha-2 country code. View Source def track ( self , track_id , market = None ) : \"\"\" returns a single track given the track's ID, URI or URL Parameters : - track_id - a spotify URI , URL or ID - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" trid = self . _get_id ( \" track \" , track_id ) return self . _get ( \" tracks/ \" + trid , market = market ) tracks def tracks ( self , tracks , market = None ) returns a list of tracks given a list of track IDs, URIs, or URLs Parameters: - tracks - a list of spotify URIs, URLs or IDs. Maximum: 50 IDs. - market - an ISO 3166-1 alpha-2 country code. View Source def tracks ( self , tracks , market = None ) : \"\"\" returns a list of tracks given a list of track IDs, URIs, or URLs Parameters : - tracks - a list of spotify URIs , URLs or IDs . Maximum : 50 IDs . - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _get ( \" tracks/?ids= \" + \" , \" . join ( tlist ) , market = market ) transfer_playback def transfer_playback ( self , device_id , force_play = True ) Transfer playback to another device. Note that the API accepts a list of device ids, but only actually supports one. Parameters: - device_id - transfer playback to this device - force_play - true: after transfer, play. false: keep current state. View Source def transfer_playback ( self , device_id , force_play = True ) : \"\"\" Transfer playback to another device. Note that the API accepts a list of device ids, but only actually supports one. Parameters: - device_id - transfer playback to this device - force_play - true: after transfer, play. false: keep current state. \"\"\" data = { \"device_ids\" : [ device_id ] , \"play\" : force_play } return self . _put ( \"me/player\" , payload = data ) user def user ( self , user ) Gets basic profile information about a Spotify User Parameters: - user - the id of the usr View Source def user ( self , user ) : \"\"\" Gets basic profile information about a Spotify User Parameters : - user - the id of the usr \"\"\" return self . _get ( \" users/ \" + user ) user_follow_artists def user_follow_artists ( self , ids = [] ) Follow one or more artists Parameters: - ids - a list of artist IDs View Source def user_follow_artists ( self , ids = [] ) : \"\"\" Follow one or more artists Parameters : - ids - a list of artist IDs \"\"\" return self . _put ( \" me/following?type=artist&ids= \" + \" , \" . join ( ids )) user_follow_users def user_follow_users ( self , ids = [] ) Follow one or more users Parameters: - ids - a list of user IDs View Source def user_follow_users ( self , ids = [] ) : \"\"\" Follow one or more users Parameters : - ids - a list of user IDs \"\"\" return self . _put ( \" me/following?type=user&ids= \" + \" , \" . join ( ids )) user_playlist def user_playlist ( self , user , playlist_id = None , fields = None , market = None ) View Source def user_playlist ( self , user , playlist_id = None , fields = None , market = None ) : warnings . warn ( \" You should use `playlist(playlist_id)` instead \" , DeprecationWarning , ) \"\"\" Gets playlist of a user Parameters : - user - the id of the user - playlist_id - the id of the playlist - fields - which fields to return \"\"\" if playlist_id is None : return self . _get ( \" users/%s/starred \" % user ) return self . playlist ( playlist_id , fields = fields , market = market ) user_playlist_add_tracks def user_playlist_add_tracks ( self , user , playlist_id , tracks , position = None ) View Source def user_playlist_add_tracks ( self , user , playlist_id , tracks , position = None ) : warnings . warn ( \" You should use `playlist_add_items(playlist_id, tracks)` instead \" , DeprecationWarning , ) \"\"\" Adds tracks to a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - a list of track URIs , URLs or IDs - position - the position to add the tracks \"\"\" return self . playlist_add_items ( playlist_id , tracks , position ) user_playlist_change_details def user_playlist_change_details ( self , user , playlist_id , name = None , public = None , collaborative = None , description = None ) View Source def user_playlist_change_details ( self , user , playlist_id , name = None , public = None , collaborative = None , description = None , ) : warnings . warn ( \" You should use `playlist_change_details(playlist_id, ...)` instead \" , DeprecationWarning , ) \"\"\" Changes a playlist's name and/or public/private state Parameters : - user - the id of the user - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist \"\"\" return self . playlist_change_details ( playlist_id , name , public , collaborative , description ) user_playlist_create def user_playlist_create ( self , user , name , public = True , collaborative = False , description = '' ) Creates a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist - public - is the created playlist public - collaborative - is the created playlist collaborative - description - the description of the playlist View Source def user_playlist_create ( self , user , name , public = True , collaborative = False , description = \"\" ): \"\"\" Creates a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist - public - is the created playlist public - collaborative - is the created playlist collaborative - description - the description of the playlist \"\"\" data = { \"name\" : name , \"public\" : public , \"collaborative\" : collaborative , \"description\" : description } return self . _post ( \"users/ %s /playlists\" % ( user ,), payload = data ) user_playlist_follow_playlist def user_playlist_follow_playlist ( self , playlist_owner_id , playlist_id ) Add the current authenticated user as a follower of a playlist. Parameters: - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist View Source def user_playlist_follow_playlist ( self , playlist_owner_id , playlist_id ) : \"\"\" Add the current authenticated user as a follower of a playlist . Parameters : - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist \"\"\" warnings . warn ( \" You should use `current_user_follow_playlist(playlist_id)` instead \" , DeprecationWarning , ) return self . current_user_follow_playlist ( playlist_id ) user_playlist_is_following def user_playlist_is_following ( self , playlist_owner_id , playlist_id , user_ids ) Check to see if the given users are following the given playlist Parameters: - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist. Maximum: 5 ids. View Source def user_playlist_is_following ( self , playlist_owner_id , playlist_id , user_ids ) : \"\"\" Check to see if the given users are following the given playlist Parameters : - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist . Maximum : 5 ids . \"\"\" warnings . warn ( \" You should use `playlist_is_following(playlist_id, user_ids)` instead \" , DeprecationWarning , ) return self . playlist_is_following ( playlist_id , user_ids ) user_playlist_remove_all_occurrences_of_tracks def user_playlist_remove_all_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot View Source def user_playlist_remove_all_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) : \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot \"\"\" warnings . warn ( \" You should use `playlist_remove_all_occurrences_of_items \" \" (playlist_id, tracks)` instead \" , DeprecationWarning , ) return self . playlist_remove_all_occurrences_of_items ( playlist_id , tracks , snapshot_id ) user_playlist_remove_specific_occurrences_of_tracks def user_playlist_remove_specific_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - an array of objects containing Spotify URIs of the tracks to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot View Source def user_playlist_remove_specific_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - an array of objects containing Spotify URIs of the tracks to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot \"\"\" warnings . warn ( \"You should use `playlist_remove_specific_occurrences_of_items\" \"(playlist_id, tracks)` instead\" , DeprecationWarning , ) plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [] for tr in tracks : ftracks . append ( { \"uri\" : self . _get_uri ( \"track\" , tr [ \"uri\" ]), \"positions\" : tr [ \"positions\" ], } ) payload = { \"tracks\" : ftracks } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"users/ %s /playlists/ %s /tracks\" % ( user , plid ), payload = payload ) user_playlist_reorder_tracks def user_playlist_reorder_tracks ( self , user , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None ) Reorder tracks in a playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID View Source def user_playlist_reorder_tracks ( self , user , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None , ) : \"\"\" Reorder tracks in a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered ( default : 1 ) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist ' s snapshot ID \"\"\" warnings . warn ( \" You should use `playlist_reorder_items(playlist_id, ...)` instead \" , DeprecationWarning , ) return self . playlist_reorder_items ( playlist_id , range_start , insert_before , range_length , snapshot_id ) user_playlist_replace_tracks def user_playlist_replace_tracks ( self , user , playlist_id , tracks ) Replace all tracks in a playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to add to the playlist View Source def user_playlist_replace_tracks ( self , user , playlist_id , tracks ) : \"\"\" Replace all tracks in a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to add to the playlist \"\"\" warnings . warn ( \" You should use `playlist_replace_items(playlist_id, tracks)` instead \" , DeprecationWarning , ) return self . playlist_replace_items ( playlist_id , tracks ) user_playlist_tracks def user_playlist_tracks ( self , user = None , playlist_id = None , fields = None , limit = 100 , offset = 0 , market = None ) View Source def user_playlist_tracks ( self , user = None , playlist_id = None , fields = None , limit = 100 , offset = 0 , market = None , ) : warnings . warn ( \" You should use `playlist_tracks(playlist_id)` instead \" , DeprecationWarning , ) \"\"\" Get full details of the tracks of a playlist owned by a user. Parameters : - user - the id of the user - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" return self . playlist_tracks ( playlist_id , limit = limit , offset = offset , fields = fields , market = market , ) user_playlist_unfollow def user_playlist_unfollow ( self , user , playlist_id ) Unfollows (deletes) a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist View Source def user_playlist_unfollow ( self , user , playlist_id ) : \"\"\" Unfollows (deletes) a playlist for a user Parameters : - user - the id of the user - name - the name of the playlist \"\"\" warnings . warn ( \" You should use `current_user_unfollow_playlist(playlist_id)` instead \" , DeprecationWarning , ) return self . current_user_unfollow_playlist ( playlist_id ) user_playlists def user_playlists ( self , user , limit = 50 , offset = 0 ) Gets playlists of a user Parameters: - user - the id of the usr - limit - the number of items to return - offset - the index of the first item to return View Source def user_playlists ( self , user , limit = 50 , offset = 0 ) : \"\"\" Gets playlists of a user Parameters : - user - the id of the usr - limit - the number of items to return - offset - the index of the first item to return \"\"\" return self . _get ( \" users/%s/playlists \" % user , limit = limit , offset = offset ) user_unfollow_artists def user_unfollow_artists ( self , ids = [] ) Unfollow one or more artists Parameters: - ids - a list of artist IDs View Source def user_unfollow_artists ( self , ids = [] ) : \"\"\" Unfollow one or more artists Parameters : - ids - a list of artist IDs \"\"\" return self . _delete ( \" me/following?type=artist&ids= \" + \" , \" . join ( ids )) user_unfollow_users def user_unfollow_users ( self , ids = [] ) Unfollow one or more users Parameters: - ids - a list of user IDs View Source def user_unfollow_users ( self , ids = [] ) : \"\"\" Unfollow one or more users Parameters : - ids - a list of user IDs \"\"\" return self . _delete ( \" me/following?type=user&ids= \" + \" , \" . join ( ids )) volume def volume ( self , volume_percent , device_id = None ) Set playback volume. Parameters: - volume_percent - volume between 0 and 100 - device_id - device target for playback View Source def volume ( self , volume_percent , device_id = None ) : \"\"\" Set playback volume. Parameters : - volume_percent - volume between 0 and 100 - device_id - device target for playback \"\"\" if not isinstance ( volume_percent , int ) : logger . warning ( \" Volume must be an integer \" ) return if volume_percent < 0 or volume_percent > 100 : logger . warning ( \" Volume must be between 0 and 100, inclusive \" ) return self . _put ( self . _append_device_id ( \" me/player/volume?volume_percent=%s \" % volume_percent , device_id , ) ) SpotifyError class SpotifyError ( / , * args , ** kwargs ) View Source class SpotifyError ( Exception ): \"\"\" Base class for all exceptions related to SpotifyClient. \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Spotify"},{"location":"reference/spotdl/utils/spotify/#module-spotdlutilsspotify","text":"Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret. >>> import spotdl.utils.spotify >>> spotify . Spotify . init ( client_id , client_secret ) View Source \"\"\" Module for interacting with Spotify API. To use this module, you must have a Spotify API key and Spotify API secret. >>> import spotdl.utils.spotify >>> spotify.Spotify.init(client_id, client_secret) \"\"\" from typing import Optional from spotipy import Spotify from spotipy.cache_handler import CacheFileHandler , MemoryCacheHandler from spotipy.oauth2 import SpotifyClientCredentials , SpotifyOAuth from spotdl.utils.config import get_cache_path class SpotifyError ( Exception ): \"\"\" Base class for all exceptions related to SpotifyClient. \"\"\" class Singleton ( type ): \"\"\" Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance. \"\"\" _instance = None def __call__ ( self ): # pylint: disable=bad-mcs-method-argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance def init ( # pylint: disable=bad-mcs-method-argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed, if yes, raise an Exception if isinstance ( self . _instance , self ): raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super () . __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance class SpotifyClient ( Spotify , metaclass = Singleton ): \"\"\" This is the Spotify client meant to be used in the app. Has to be initialized first by calling `SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)`. \"\"\" _initialized = False def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth_manager: The auth manager to use. \"\"\" super () . __init__ ( * args , ** kwargs ) self . _initialized = True","title":"Module spotdl.utils.spotify"},{"location":"reference/spotdl/utils/spotify/#classes","text":"","title":"Classes"},{"location":"reference/spotdl/utils/spotify/#singleton","text":"class Singleton ( / , * args , ** kwargs ) View Source class Singleton ( type ) : \"\"\" Singleton metaclass for SpotifyClient. Ensures that SpotifyClient is not instantiated without prior initialization. Every other instantiation of SpotifyClient will return the same instance. \"\"\" _instance = None def __call__ ( self ) : # pylint : disable = bad - mcs - method - argument \"\"\" Call method for Singleton metaclass. ### Returns - The instance of the SpotifyClient. \"\"\" if self . _instance is None : raise SpotifyError ( \"Spotify client not created. Call SpotifyClient.init\" \"(client_id, client_secret, user_auth, cache_path, no_cache, open_browser) first.\" ) return self . _instance def init ( # pylint : disable = bad - mcs - method - argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed , if yes , raise an Exception if isinstance ( self . _instance , self ) : raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super (). __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance","title":"Singleton"},{"location":"reference/spotdl/utils/spotify/#ancestors-in-mro","text":"builtins.type","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/spotify/#methods","text":"","title":"Methods"},{"location":"reference/spotdl/utils/spotify/#init","text":"def init ( self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True ) -> 'Singleton' Initializes the SpotifyClient.","title":"init"},{"location":"reference/spotdl/utils/spotify/#arguments","text":"client_id: The client ID of the application. client_secret: The client secret of the application. user_auth: Whether or not to use user authentication. cache_path: The path to the cache file. no_cache: Whether or not to use the cache. open_browser: Whether or not to open the browser.","title":"Arguments"},{"location":"reference/spotdl/utils/spotify/#returns","text":"The instance of the SpotifyClient. View Source def init ( # pylint : disable = bad - mcs - method - argument self , client_id : str , client_secret : str , user_auth : bool = False , cache_path : Optional [ str ] = None , no_cache : bool = False , open_browser : bool = True , ) -> \"Singleton\" : \"\"\" Initializes the SpotifyClient. ### Arguments - client_id: The client ID of the application. - client_secret: The client secret of the application. - user_auth: Whether or not to use user authentication. - cache_path: The path to the cache file. - no_cache: Whether or not to use the cache. - open_browser: Whether or not to open the browser. ### Returns - The instance of the SpotifyClient. \"\"\" # check if initialization has been completed , if yes , raise an Exception if isinstance ( self . _instance , self ) : raise SpotifyError ( \"A spotify client has already been initialized\" ) credential_manager = None cache_handler = ( CacheFileHandler ( cache_path or get_cache_path ()) if not no_cache else MemoryCacheHandler () ) # Use SpotifyOAuth as auth manager if user_auth : credential_manager = SpotifyOAuth ( client_id = client_id , client_secret = client_secret , redirect_uri = \"http://127.0.0.1:8080/\" , scope = \"user-library-read\" , cache_handler = cache_handler , open_browser = open_browser , ) # Use SpotifyClientCredentials as auth manager else : credential_manager = SpotifyClientCredentials ( client_id = client_id , client_secret = client_secret , cache_handler = cache_handler , ) self . user_auth = user_auth # Create instance self . _instance = super (). __call__ ( auth_manager = credential_manager , status_forcelist = ( 429 , 500 , 502 , 503 , 504 , 404 ), ) # Return instance return self . _instance","title":"Returns"},{"location":"reference/spotdl/utils/spotify/#mro","text":"def mro ( self , / ) Return a type's method resolution order.","title":"mro"},{"location":"reference/spotdl/utils/spotify/#spotifyclient","text":"class SpotifyClient ( * args , ** kwargs ) View Source class SpotifyClient ( Spotify , metaclass = Singleton ): \"\"\" This is the Spotify client meant to be used in the app. Has to be initialized first by calling `SpotifyClient.init(client_id, client_secret, user_auth, cache_path, no_cache, open_browser)`. \"\"\" _initialized = False def __init__ ( self , * args , ** kwargs ): \"\"\" Initializes the SpotifyClient. ### Arguments - auth_manager: The auth manager to use. \"\"\" super (). __init__ (* args , ** kwargs ) self . _initialized = True","title":"SpotifyClient"},{"location":"reference/spotdl/utils/spotify/#ancestors-in-mro_1","text":"spotipy.client.Spotify","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/spotify/#class-variables","text":"country_codes default_retry_codes max_retries","title":"Class variables"},{"location":"reference/spotdl/utils/spotify/#instance-variables","text":"auth_manager","title":"Instance variables"},{"location":"reference/spotdl/utils/spotify/#methods_1","text":"","title":"Methods"},{"location":"reference/spotdl/utils/spotify/#add_to_queue","text":"def add_to_queue ( self , uri , device_id = None ) Adds a song to the end of a user's queue If device A is currently playing music and you try to add to the queue and pass in the id for device B, you will get a 'Player command failed: Restriction violated' error I therefore reccomend leaving device_id as None so that the active device is targeted Parameters: Name Type Description Default uri None song uri, id, or url None device_id None the id of a Spotify device. If None, then the active device is used. None View Source def add_to_queue ( self , uri , device_id = None ) : \"\"\" Adds a song to the end of a user's queue If device A is currently playing music and you try to add to the queue and pass in the id for device B , you will get a ' Player command failed: Restriction violated ' error I therefore reccomend leaving device_id as None so that the active device is targeted : param uri : song uri , id , or url : param device_id : the id of a Spotify device . If None , then the active device is used . \"\"\" uri = self . _get_uri ( \" track \" , uri ) endpoint = \" me/player/queue?uri=%s \" % uri if device_id is not None : endpoint += \" &device_id=%s \" % device_id return self . _post ( endpoint )","title":"add_to_queue"},{"location":"reference/spotdl/utils/spotify/#album","text":"def album ( self , album_id ) returns a single album given the album's ID, URIs or URL Parameters: - album_id - the album ID, URI or URL View Source def album ( self , album_id ) : \"\"\" returns a single album given the album's ID, URIs or URL Parameters : - album_id - the album ID , URI or URL \"\"\" trid = self . _get_id ( \" album \" , album_id ) return self . _get ( \" albums/ \" + trid )","title":"album"},{"location":"reference/spotdl/utils/spotify/#album_tracks","text":"def album_tracks ( self , album_id , limit = 50 , offset = 0 , market = None ) Get Spotify catalog information about an album's tracks Parameters: - album_id - the album ID, URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166-1 alpha-2 country code. View Source def album_tracks ( self , album_id , limit = 50 , offset = 0 , market = None ) : \"\"\" Get Spotify catalog information about an album's tracks Parameters : - album_id - the album ID , URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" trid = self . _get_id ( \" album \" , album_id ) return self . _get ( \" albums/ \" + trid + \" /tracks/ \" , limit = limit , offset = offset , market = market )","title":"album_tracks"},{"location":"reference/spotdl/utils/spotify/#albums","text":"def albums ( self , albums ) returns a list of albums given the album IDs, URIs, or URLs Parameters: - albums - a list of album IDs, URIs or URLs View Source def albums ( self , albums ) : \"\"\" returns a list of albums given the album IDs, URIs, or URLs Parameters : - albums - a list of album IDs , URIs or URLs \"\"\" tlist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _get ( \" albums/?ids= \" + \" , \" . join ( tlist ))","title":"albums"},{"location":"reference/spotdl/utils/spotify/#artist","text":"def artist ( self , artist_id ) returns a single artist given the artist's ID, URI or URL Parameters: - artist_id - an artist ID, URI or URL View Source def artist ( self , artist_id ) : \"\"\" returns a single artist given the artist's ID, URI or URL Parameters : - artist_id - an artist ID , URI or URL \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid )","title":"artist"},{"location":"reference/spotdl/utils/spotify/#artist_albums","text":"def artist_albums ( self , artist_id , album_type = None , country = None , limit = 20 , offset = 0 ) Get Spotify catalog information about an artist's albums Parameters: - artist_id - the artist ID, URI or URL - album_type - 'album', 'single', 'appears_on', 'compilation' - country - limit the response to one particular country. - limit - the number of albums to return - offset - the index of the first album to return View Source def artist_albums ( self , artist_id , album_type = None , country = None , limit = 20 , offset = 0 ) : \"\"\" Get Spotify catalog information about an artist's albums Parameters : - artist_id - the artist ID , URI or URL - album_type - ' album ' , ' single ' , ' appears_on ' , ' compilation ' - country - limit the response to one particular country . - limit - the number of albums to return - offset - the index of the first album to return \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /albums \" , album_type = album_type , country = country , limit = limit , offset = offset , )","title":"artist_albums"},{"location":"reference/spotdl/utils/spotify/#artist_related_artists","text":"def artist_related_artists ( self , artist_id ) Get Spotify catalog information about artists similar to an identified artist. Similarity is based on analysis of the Spotify community's listening history. Parameters: - artist_id - the artist ID, URI or URL View Source def artist_related_artists ( self , artist_id ) : \"\"\" Get Spotify catalog information about artists similar to an identified artist . Similarity is based on analysis of the Spotify community ' s listening history. Parameters : - artist_id - the artist ID , URI or URL \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /related-artists \" )","title":"artist_related_artists"},{"location":"reference/spotdl/utils/spotify/#artist_top_tracks","text":"def artist_top_tracks ( self , artist_id , country = 'US' ) Get Spotify catalog information about an artist's top 10 tracks by country. Parameters: - artist_id - the artist ID, URI or URL - country - limit the response to one particular country. View Source def artist_top_tracks ( self , artist_id , country = \" US \" ) : \"\"\" Get Spotify catalog information about an artist's top 10 tracks by country . Parameters : - artist_id - the artist ID , URI or URL - country - limit the response to one particular country . \"\"\" trid = self . _get_id ( \" artist \" , artist_id ) return self . _get ( \" artists/ \" + trid + \" /top-tracks \" , country = country )","title":"artist_top_tracks"},{"location":"reference/spotdl/utils/spotify/#artists","text":"def artists ( self , artists ) returns a list of artists given the artist IDs, URIs, or URLs Parameters: - artists - a list of artist IDs, URIs or URLs View Source def artists ( self , artists ) : \"\"\" returns a list of artists given the artist IDs, URIs, or URLs Parameters : - artists - a list of artist IDs , URIs or URLs \"\"\" tlist = [ self . _get_id ( \" artist \" , a ) for a in artists ] return self . _get ( \" artists/?ids= \" + \" , \" . join ( tlist ))","title":"artists"},{"location":"reference/spotdl/utils/spotify/#audio_analysis","text":"def audio_analysis ( self , track_id ) Get audio analysis for a track based upon its Spotify ID Parameters: - track_id - a track URI, URL or ID View Source def audio_analysis ( self , track_id ) : \"\"\" Get audio analysis for a track based upon its Spotify ID Parameters : - track_id - a track URI , URL or ID \"\"\" trid = self . _get_id ( \" track \" , track_id ) return self . _get ( \" audio-analysis/ \" + trid )","title":"audio_analysis"},{"location":"reference/spotdl/utils/spotify/#audio_features","text":"def audio_features ( self , tracks = [] ) Get audio features for one or multiple tracks based upon their Spotify IDs Parameters: Name Type Description Default - tracks - a list of track URIs, URLs or IDs, maximum None 100 ids None View Source def audio_features ( self , tracks = [] ) : \"\"\" Get audio features for one or multiple tracks based upon their Spotify IDs Parameters : - tracks - a list of track URIs , URLs or IDs , maximum : 100 ids \"\"\" if isinstance ( tracks , str ) : trackid = self . _get_id ( \" track \" , tracks ) results = self . _get ( \" audio-features/?ids= \" + trackid ) else : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] results = self . _get ( \" audio-features/?ids= \" + \" , \" . join ( tlist )) # the response has changed , look for the new style first , and if # its not there , fallback on the old style if \" audio_features \" in results : return results [ \" audio_features \" ] else : return results","title":"audio_features"},{"location":"reference/spotdl/utils/spotify/#available_markets","text":"def available_markets ( self ) Get the list of markets where Spotify is available. Returns a list of the countries in which Spotify is available, identified by their ISO 3166-1 alpha-2 country code with additional country codes for special territories. View Source def available_markets ( self ) : \"\"\" Get the list of markets where Spotify is available. Returns a list of the countries in which Spotify is available , identified by their ISO 3166 - 1 alpha - 2 country code with additional country codes for special territories . \"\"\" return self . _get ( \" markets \" )","title":"available_markets"},{"location":"reference/spotdl/utils/spotify/#categories","text":"def categories ( self , country = None , locale = None , limit = 20 , offset = 0 ) Get a list of categories Parameters: - country - An ISO 3166-1 alpha-2 country code. - locale - The desired language, consisting of an ISO 639 language code and an ISO 3166-1 alpha-2 country code, joined by an underscore. - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def categories ( self , country = None , locale = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of categories Parameters : - country - An ISO 3166 - 1 alpha - 2 country code . - locale - The desired language , consisting of an ISO 639 language code and an ISO 3166 - 1 alpha - 2 country code , joined by an underscore . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/categories \" , country = country , locale = locale , limit = limit , offset = offset , )","title":"categories"},{"location":"reference/spotdl/utils/spotify/#category","text":"def category ( self , category_id , country = None , locale = None ) Get info about a category Parameters: - category_id - The Spotify category ID for the category. - country - An ISO 3166-1 alpha-2 country code. - locale - The desired language, consisting of an ISO 639 language code and an ISO 3166-1 alpha-2 country code, joined by an underscore. View Source def category ( self , category_id , country = None , locale = None ) : \"\"\" Get info about a category Parameters : - category_id - The Spotify category ID for the category . - country - An ISO 3166 - 1 alpha - 2 country code . - locale - The desired language , consisting of an ISO 639 language code and an ISO 3166 - 1 alpha - 2 country code , joined by an underscore . \"\"\" return self . _get ( \" browse/categories/ \" + category_id , country = country , locale = locale , )","title":"category"},{"location":"reference/spotdl/utils/spotify/#category_playlists","text":"def category_playlists ( self , category_id = None , country = None , limit = 20 , offset = 0 ) Get a list of playlists for a specific Spotify category Parameters: - category_id - The Spotify category ID for the category. - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def category_playlists ( self , category_id = None , country = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of playlists for a specific Spotify category Parameters : - category_id - The Spotify category ID for the category . - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/categories/ \" + category_id + \" /playlists \" , country = country , limit = limit , offset = offset , )","title":"category_playlists"},{"location":"reference/spotdl/utils/spotify/#current_playback","text":"def current_playback ( self , market = None , additional_types = None ) Get information about user's current playback. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - episode to get podcast track information View Source def current_playback ( self , market = None , additional_types = None ) : \" \"\" Get information about user's current playback. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - `episode` to get podcast track information \"\" \" return self . _get ( \"me/player\" , market = market , additional_types = additional_types )","title":"current_playback"},{"location":"reference/spotdl/utils/spotify/#current_user","text":"def current_user ( self ) Get detailed profile information about the current user. An alias for the 'me' method. View Source def current_user ( self ) : \"\"\" Get detailed profile information about the current user. An alias for the ' me ' method . \"\"\" return self . me ()","title":"current_user"},{"location":"reference/spotdl/utils/spotify/#current_user_follow_playlist","text":"def current_user_follow_playlist ( self , playlist_id ) Add the current authenticated user as a follower of a playlist. Parameters: - playlist_id - the id of the playlist View Source def current_user_follow_playlist ( self , playlist_id ) : \"\"\" Add the current authenticated user as a follower of a playlist . Parameters : - playlist_id - the id of the playlist \"\"\" return self . _put ( \" playlists/{}/followers \" . format ( playlist_id ) )","title":"current_user_follow_playlist"},{"location":"reference/spotdl/utils/spotify/#current_user_followed_artists","text":"def current_user_followed_artists ( self , limit = 20 , after = None ) Gets a list of the artists followed by the current authorized user Parameters: - limit - the number of artists to return - after - the last artist ID retrieved from the previous request View Source def current_user_followed_artists ( self , limit = 20 , after = None ) : \"\"\" Gets a list of the artists followed by the current authorized user Parameters : - limit - the number of artists to return - after - the last artist ID retrieved from the previous request \"\"\" return self . _get ( \" me/following \" , type = \" artist \" , limit = limit , after = after )","title":"current_user_followed_artists"},{"location":"reference/spotdl/utils/spotify/#current_user_following_artists","text":"def current_user_following_artists ( self , ids = None ) Check if the current user is following certain artists Returns list of booleans respective to ids Parameters: - ids - a list of artist URIs, URLs or IDs View Source def current_user_following_artists ( self , ids = None ) : \"\"\" Check if the current user is following certain artists Returns list of booleans respective to ids Parameters : - ids - a list of artist URIs , URLs or IDs \"\"\" idlist = [] if ids is not None : idlist = [ self . _get_id ( \" artist \" , i ) for i in ids ] return self . _get ( \" me/following/contains \" , ids = \" , \" . join ( idlist ) , type = \" artist \" )","title":"current_user_following_artists"},{"location":"reference/spotdl/utils/spotify/#current_user_following_users","text":"def current_user_following_users ( self , ids = None ) Check if the current user is following certain artists Returns list of booleans respective to ids Parameters: - ids - a list of user URIs, URLs or IDs View Source def current_user_following_users ( self , ids = None ) : \"\"\" Check if the current user is following certain artists Returns list of booleans respective to ids Parameters : - ids - a list of user URIs , URLs or IDs \"\"\" idlist = [] if ids is not None : idlist = [ self . _get_id ( \" user \" , i ) for i in ids ] return self . _get ( \" me/following/contains \" , ids = \" , \" . join ( idlist ) , type = \" user \" )","title":"current_user_following_users"},{"location":"reference/spotdl/utils/spotify/#current_user_playing_track","text":"def current_user_playing_track ( self ) Get information about the current users currently playing track. View Source def current_user_playing_track ( self ) : \"\"\" Get information about the current users currently playing track. \"\"\" return self . _get ( \" me/player/currently-playing \" )","title":"current_user_playing_track"},{"location":"reference/spotdl/utils/spotify/#current_user_playlists","text":"def current_user_playlists ( self , limit = 50 , offset = 0 ) Get current user playlists without required getting his profile Parameters: - limit - the number of items to return - offset - the index of the first item to return View Source def current_user_playlists ( self , limit = 50 , offset = 0 ) : \"\"\" Get current user playlists without required getting his profile Parameters : - limit - the number of items to return - offset - the index of the first item to return \"\"\" return self . _get ( \" me/playlists \" , limit = limit , offset = offset )","title":"current_user_playlists"},{"location":"reference/spotdl/utils/spotify/#current_user_recently_played","text":"def current_user_recently_played ( self , limit = 50 , after = None , before = None ) Get the current user's recently played tracks Parameters: - limit - the number of entities to return - after - unix timestamp in milliseconds. Returns all items after (but not including) this cursor position. Cannot be used if before is specified. - before - unix timestamp in milliseconds. Returns all items before (but not including) this cursor position. Cannot be used if after is specified View Source def current_user_recently_played ( self , limit = 50 , after = None , before = None ) : \"\"\" Get the current user's recently played tracks Parameters : - limit - the number of entities to return - after - unix timestamp in milliseconds . Returns all items after ( but not including ) this cursor position . Cannot be used if before is specified . - before - unix timestamp in milliseconds . Returns all items before ( but not including ) this cursor position . Cannot be used if after is specified \"\"\" return self . _get ( \" me/player/recently-played \" , limit = limit , after = after , before = before , )","title":"current_user_recently_played"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_albums","text":"def current_user_saved_albums ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the albums saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of albums to return (MAX_LIMIT=50) - offset - the index of the first album to return - market - an ISO 3166-1 alpha-2 country code. View Source def current_user_saved_albums ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the albums saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of albums to return ( MAX_LIMIT = 50 ) - offset - the index of the first album to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" return self . _get ( \" me/albums \" , limit = limit , offset = offset , market = market )","title":"current_user_saved_albums"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_albums_add","text":"def current_user_saved_albums_add ( self , albums = [] ) Add one or more albums to the current user's \"Your Music\" library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_add ( self , albums = [] ) : \"\"\" Add one or more albums to the current user's \" Your Music \" library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _put ( \" me/albums?ids= \" + \" , \" . join ( alist ))","title":"current_user_saved_albums_add"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_albums_contains","text":"def current_user_saved_albums_contains ( self , albums = [] ) Check if one or more albums is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_contains ( self , albums = [] ) : \"\"\" Check if one or more albums is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _get ( \" me/albums/contains?ids= \" + \" , \" . join ( alist ))","title":"current_user_saved_albums_contains"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_albums_delete","text":"def current_user_saved_albums_delete ( self , albums = [] ) Remove one or more albums from the current user's \"Your Music\" library. Parameters: - albums - a list of album URIs, URLs or IDs View Source def current_user_saved_albums_delete ( self , albums = [] ) : \"\"\" Remove one or more albums from the current user's \" Your Music \" library . Parameters : - albums - a list of album URIs , URLs or IDs \"\"\" alist = [ self . _get_id ( \" album \" , a ) for a in albums ] return self . _delete ( \" me/albums/?ids= \" + \" , \" . join ( alist ))","title":"current_user_saved_albums_delete"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_episodes","text":"def current_user_saved_episodes ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the episodes saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of episodes to return - offset - the index of the first episode to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_episodes ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the episodes saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of episodes to return - offset - the index of the first episode to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/episodes \" , limit = limit , offset = offset , market = market )","title":"current_user_saved_episodes"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_episodes_add","text":"def current_user_saved_episodes_add ( self , episodes = None ) Add one or more episodes to the current user's \"Your Music\" library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_add ( self , episodes = None ) : \"\"\" Add one or more episodes to the current user's \" Your Music \" library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _put ( \" me/episodes/?ids= \" + \" , \" . join ( elist ))","title":"current_user_saved_episodes_add"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_episodes_contains","text":"def current_user_saved_episodes_contains ( self , episodes = None ) Check if one or more episodes is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_contains ( self , episodes = None ) : \"\"\" Check if one or more episodes is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _get ( \" me/episodes/contains?ids= \" + \" , \" . join ( elist ))","title":"current_user_saved_episodes_contains"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_episodes_delete","text":"def current_user_saved_episodes_delete ( self , episodes = None ) Remove one or more episodes from the current user's \"Your Music\" library. Parameters: - episodes - a list of episode URIs, URLs or IDs View Source def current_user_saved_episodes_delete ( self , episodes = None ) : \"\"\" Remove one or more episodes from the current user's \" Your Music \" library . Parameters : - episodes - a list of episode URIs , URLs or IDs \"\"\" elist = [] if episodes is not None : elist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _delete ( \" me/episodes/?ids= \" + \" , \" . join ( elist ))","title":"current_user_saved_episodes_delete"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_shows","text":"def current_user_saved_shows ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the shows saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of shows to return - offset - the index of the first show to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_shows ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the shows saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of shows to return - offset - the index of the first show to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/shows \" , limit = limit , offset = offset , market = market )","title":"current_user_saved_shows"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_shows_add","text":"def current_user_saved_shows_add ( self , shows = [] ) Add one or more albums to the current user's \"Your Music\" library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_add ( self , shows = [] ) : \"\"\" Add one or more albums to the current user's \" Your Music \" library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _put ( \" me/shows?ids= \" + \" , \" . join ( slist ))","title":"current_user_saved_shows_add"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_shows_contains","text":"def current_user_saved_shows_contains ( self , shows = [] ) Check if one or more shows is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_contains ( self , shows = [] ) : \"\"\" Check if one or more shows is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _get ( \" me/shows/contains?ids= \" + \" , \" . join ( slist ))","title":"current_user_saved_shows_contains"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_shows_delete","text":"def current_user_saved_shows_delete ( self , shows = [] ) Remove one or more shows from the current user's \"Your Music\" library. Parameters: - shows - a list of show URIs, URLs or IDs View Source def current_user_saved_shows_delete ( self , shows = [] ) : \"\"\" Remove one or more shows from the current user's \" Your Music \" library . Parameters : - shows - a list of show URIs , URLs or IDs \"\"\" slist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _delete ( \" me/shows/?ids= \" + \" , \" . join ( slist ))","title":"current_user_saved_shows_delete"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_tracks","text":"def current_user_saved_tracks ( self , limit = 20 , offset = 0 , market = None ) Gets a list of the tracks saved in the current authorized user's \"Your Music\" library Parameters: - limit - the number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code View Source def current_user_saved_tracks ( self , limit = 20 , offset = 0 , market = None ) : \"\"\" Gets a list of the tracks saved in the current authorized user's \" Your Music \" library Parameters : - limit - the number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code \"\"\" return self . _get ( \" me/tracks \" , limit = limit , offset = offset , market = market )","title":"current_user_saved_tracks"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_tracks_add","text":"def current_user_saved_tracks_add ( self , tracks = None ) Add one or more tracks to the current user's \"Your Music\" library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_add ( self , tracks = None ) : \"\"\" Add one or more tracks to the current user's \" Your Music \" library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _put ( \" me/tracks/?ids= \" + \" , \" . join ( tlist ))","title":"current_user_saved_tracks_add"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_tracks_contains","text":"def current_user_saved_tracks_contains ( self , tracks = None ) Check if one or more tracks is already saved in the current Spotify user\u2019s \u201cYour Music\u201d library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_contains ( self , tracks = None ) : \"\"\" Check if one or more tracks is already saved in the current Spotify user \u2019 s \u201c Your Music \u201d library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _get ( \" me/tracks/contains?ids= \" + \" , \" . join ( tlist ))","title":"current_user_saved_tracks_contains"},{"location":"reference/spotdl/utils/spotify/#current_user_saved_tracks_delete","text":"def current_user_saved_tracks_delete ( self , tracks = None ) Remove one or more tracks from the current user's \"Your Music\" library. Parameters: - tracks - a list of track URIs, URLs or IDs View Source def current_user_saved_tracks_delete ( self , tracks = None ) : \"\"\" Remove one or more tracks from the current user's \" Your Music \" library . Parameters : - tracks - a list of track URIs , URLs or IDs \"\"\" tlist = [] if tracks is not None : tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _delete ( \" me/tracks/?ids= \" + \" , \" . join ( tlist ))","title":"current_user_saved_tracks_delete"},{"location":"reference/spotdl/utils/spotify/#current_user_top_artists","text":"def current_user_top_artists ( self , limit = 20 , offset = 0 , time_range = 'medium_term' ) Get the current user's top artists Parameters: - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid-values: short_term, medium_term, long_term View Source def current_user_top_artists ( self , limit = 20 , offset = 0 , time_range = \" medium_term \" ) : \"\"\" Get the current user's top artists Parameters : - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid - values : short_term , medium_term , long_term \"\"\" return self . _get ( \" me/top/artists \" , time_range = time_range , limit = limit , offset = offset )","title":"current_user_top_artists"},{"location":"reference/spotdl/utils/spotify/#current_user_top_tracks","text":"def current_user_top_tracks ( self , limit = 20 , offset = 0 , time_range = 'medium_term' ) Get the current user's top tracks Parameters: - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid-values: short_term, medium_term, long_term View Source def current_user_top_tracks ( self , limit = 20 , offset = 0 , time_range = \" medium_term \" ) : \"\"\" Get the current user's top tracks Parameters : - limit - the number of entities to return - offset - the index of the first entity to return - time_range - Over what time frame are the affinities computed Valid - values : short_term , medium_term , long_term \"\"\" return self . _get ( \" me/top/tracks \" , time_range = time_range , limit = limit , offset = offset )","title":"current_user_top_tracks"},{"location":"reference/spotdl/utils/spotify/#current_user_unfollow_playlist","text":"def current_user_unfollow_playlist ( self , playlist_id ) Unfollows (deletes) a playlist for the current authenticated user Parameters: - name - the name of the playlist View Source def current_user_unfollow_playlist ( self , playlist_id ) : \"\"\" Unfollows (deletes) a playlist for the current authenticated user Parameters : - name - the name of the playlist \"\"\" return self . _delete ( \" playlists/%s/followers \" % ( playlist_id ) )","title":"current_user_unfollow_playlist"},{"location":"reference/spotdl/utils/spotify/#currently_playing","text":"def currently_playing ( self , market = None , additional_types = None ) Get user's currently playing track. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - episode to get podcast track information View Source def currently_playing ( self , market = None , additional_types = None ) : \" \"\" Get user's currently playing track. Parameters: - market - an ISO 3166-1 alpha-2 country code. - additional_types - `episode` to get podcast track information \"\" \" return self . _get ( \"me/player/currently-playing\" , market = market , additional_types = additional_types )","title":"currently_playing"},{"location":"reference/spotdl/utils/spotify/#devices","text":"def devices ( self ) Get a list of user's available devices. View Source def devices ( self ) : \"\"\" Get a list of user's available devices. \"\"\" return self . _get ( \" me/player/devices \" )","title":"devices"},{"location":"reference/spotdl/utils/spotify/#episode","text":"def episode ( self , episode_id , market = None ) returns a single episode given the episode's ID, URIs or URL Parameters: - episode_id - the episode ID, URI or URL - market - an ISO 3166-1 alpha-2 country code. The episode must be available in the given market. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def episode ( self , episode_id , market = None ) : \"\"\" returns a single episode given the episode's ID, URIs or URL Parameters : - episode_id - the episode ID , URI or URL - market - an ISO 3166 - 1 alpha - 2 country code . The episode must be available in the given market . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" episode \" , episode_id ) return self . _get ( \" episodes/ \" + trid , market = market )","title":"episode"},{"location":"reference/spotdl/utils/spotify/#episodes","text":"def episodes ( self , episodes , market = None ) returns a list of episodes given the episode IDs, URIs, or URLs Parameters: - episodes - a list of episode IDs, URIs or URLs - market - an ISO 3166-1 alpha-2 country code. Only episodes available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def episodes ( self , episodes , market = None ) : \"\"\" returns a list of episodes given the episode IDs, URIs, or URLs Parameters : - episodes - a list of episode IDs , URIs or URLs - market - an ISO 3166 - 1 alpha - 2 country code . Only episodes available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" tlist = [ self . _get_id ( \" episode \" , e ) for e in episodes ] return self . _get ( \" episodes/?ids= \" + \" , \" . join ( tlist ) , market = market )","title":"episodes"},{"location":"reference/spotdl/utils/spotify/#featured_playlists","text":"def featured_playlists ( self , locale = None , country = None , timestamp = None , limit = 20 , offset = 0 ) Get a list of Spotify featured playlists Parameters: - locale - The desired language, consisting of a lowercase ISO 639 language code and an uppercase ISO 3166-1 alpha-2 country code, joined by an underscore. - country - An ISO 3166 - 1 alpha - 2 country code . - timestamp - A timestamp in ISO 8601 format : yyyy - MM - ddTHH : mm : ss . Use this parameter to specify the user ' s local time to get results tailored for that specific date and time in the day - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def featured_playlists ( self , locale = None , country = None , timestamp = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of Spotify featured playlists Parameters : - locale - The desired language , consisting of a lowercase ISO 639 language code and an uppercase ISO 3166 - 1 alpha - 2 country code , joined by an underscore . - country - An ISO 3166 - 1 alpha - 2 country code . - timestamp - A timestamp in ISO 8601 format : yyyy - MM - ddTHH : mm : ss . Use this parameter to specify the user ' s local time to get results tailored for that specific date and time in the day - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/featured-playlists \" , locale = locale , country = country , timestamp = timestamp , limit = limit , offset = offset , )","title":"featured_playlists"},{"location":"reference/spotdl/utils/spotify/#me","text":"def me ( self ) Get detailed profile information about the current user. An alias for the 'current_user' method. View Source def me ( self ) : \"\"\" Get detailed profile information about the current user. An alias for the ' current_user ' method . \"\"\" return self . _get ( \" me/ \" )","title":"me"},{"location":"reference/spotdl/utils/spotify/#new_releases","text":"def new_releases ( self , country = None , limit = 20 , offset = 0 ) Get a list of new album releases featured in Spotify Parameters: - country - An ISO 3166-1 alpha-2 country code. - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . View Source def new_releases ( self , country = None , limit = 20 , offset = 0 ) : \"\"\" Get a list of new album releases featured in Spotify Parameters : - country - An ISO 3166 - 1 alpha - 2 country code . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 50 - offset - The index of the first item to return . Default : 0 ( the first object ) . Use with limit to get the next set of items . \"\"\" return self . _get ( \" browse/new-releases \" , country = country , limit = limit , offset = offset )","title":"new_releases"},{"location":"reference/spotdl/utils/spotify/#next","text":"def next ( self , result ) returns the next result given a paged result Parameters: - result - a previously returned paged result View Source def next ( self , result ) : \"\"\" returns the next result given a paged result Parameters : - result - a previously returned paged result \"\"\" if result [ \" next \" ]: return self . _get ( result [ \" next \" ] ) else : return None","title":"next"},{"location":"reference/spotdl/utils/spotify/#next_track","text":"def next_track ( self , device_id = None ) Skip user's playback to next track. Parameters: - device_id - device target for playback View Source def next_track ( self , device_id = None ) : \"\"\" Skip user's playback to next track. Parameters : - device_id - device target for playback \"\"\" return self . _post ( self . _append_device_id ( \" me/player/next \" , device_id ))","title":"next_track"},{"location":"reference/spotdl/utils/spotify/#pause_playback","text":"def pause_playback ( self , device_id = None ) Pause user's playback. Parameters: - device_id - device target for playback View Source def pause_playback ( self , device_id = None ) : \"\"\" Pause user's playback. Parameters : - device_id - device target for playback \"\"\" return self . _put ( self . _append_device_id ( \" me/player/pause \" , device_id ))","title":"pause_playback"},{"location":"reference/spotdl/utils/spotify/#playlist","text":"def playlist ( self , playlist_id , fields = None , market = None , additional_types = ( 'track' ,) ) Gets playlist by id. Parameters: - playlist - the id of the playlist - fields - which fields to return - market - An ISO 3166-1 alpha-2 country code or the string from_token. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist ( self , playlist_id , fields = None , market = None , additional_types = ( \" track \" , )) : \"\"\" Gets playlist by id. Parameters : - playlist - the id of the playlist - fields - which fields to return - market - An ISO 3166 - 1 alpha - 2 country code or the string from_token . - additional_types - list of item types to return . valid types are : track and episode \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s \" % ( plid ) , fields = fields , market = market , additional_types = \" , \" . join ( additional_types ) , )","title":"playlist"},{"location":"reference/spotdl/utils/spotify/#playlist_add_items","text":"def playlist_add_items ( self , playlist_id , items , position = None ) Adds tracks/episodes to a playlist Parameters: - playlist_id - the id of the playlist - items - a list of track/episode URIs, URLs or IDs - position - the position to add the tracks View Source def playlist_add_items ( self , playlist_id , items , position = None ): \"\"\" Adds tracks/episodes to a playlist Parameters: - playlist_id - the id of the playlist - items - a list of track/episode URIs, URLs or IDs - position - the position to add the tracks \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] return self . _post ( \"playlists/ %s /tracks\" % ( plid ), payload = ftracks , position = position , )","title":"playlist_add_items"},{"location":"reference/spotdl/utils/spotify/#playlist_change_details","text":"def playlist_change_details ( self , playlist_id , name = None , public = None , collaborative = None , description = None ) Changes a playlist's name and/or public/private state Parameters: - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist View Source def playlist_change_details ( self , playlist_id , name = None , public = None , collaborative = None , description = None , ): \"\"\" Changes a playlist's name and/or public/private state Parameters: - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist \"\"\" data = {} if isinstance ( name , six . string_types ): data [ \"name\" ] = name if isinstance ( public , bool ): data [ \"public\" ] = public if isinstance ( collaborative , bool ): data [ \"collaborative\" ] = collaborative if isinstance ( description , six . string_types ): data [ \"description\" ] = description return self . _put ( \"playlists/ %s \" % ( self . _get_id ( \"playlist\" , playlist_id )), payload = data )","title":"playlist_change_details"},{"location":"reference/spotdl/utils/spotify/#playlist_cover_image","text":"def playlist_cover_image ( self , playlist_id ) Get cover of a playlist. Parameters: - playlist_id - the id of the playlist View Source def playlist_cover_image ( self , playlist_id ) : \"\"\" Get cover of a playlist. Parameters : - playlist_id - the id of the playlist \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s/images \" % ( plid ))","title":"playlist_cover_image"},{"location":"reference/spotdl/utils/spotify/#playlist_is_following","text":"def playlist_is_following ( self , playlist_id , user_ids ) Check to see if the given users are following the given playlist Parameters: - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist. Maximum: 5 ids. View Source def playlist_is_following ( self , playlist_id , user_ids ) : \"\"\" Check to see if the given users are following the given playlist Parameters : - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist . Maximum : 5 ids . \"\"\" endpoint = \" playlists/{}/followers/contains?ids={} \" return self . _get ( endpoint . format ( playlist_id , \" , \" . join ( user_ids )) )","title":"playlist_is_following"},{"location":"reference/spotdl/utils/spotify/#playlist_items","text":"def playlist_items ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( 'track' , 'episode' ) ) Get full details of the tracks and episodes of a playlist. Parameters: - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist_items ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( \" track \" , \" episode \" ) ) : \"\"\" Get full details of the tracks and episodes of a playlist. Parameters : - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . - additional_types - list of item types to return . valid types are : track and episode \"\"\" plid = self . _get_id ( \" playlist \" , playlist_id ) return self . _get ( \" playlists/%s/tracks \" % ( plid ) , limit = limit , offset = offset , fields = fields , market = market , additional_types = \" , \" . join ( additional_types ) )","title":"playlist_items"},{"location":"reference/spotdl/utils/spotify/#playlist_remove_all_occurrences_of_items","text":"def playlist_remove_all_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot View Source def playlist_remove_all_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] payload = { \"tracks\" : [{ \"uri\" : track } for track in ftracks ]} if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"playlists/ %s /tracks\" % ( plid ), payload = payload )","title":"playlist_remove_all_occurrences_of_items"},{"location":"reference/spotdl/utils/spotify/#playlist_remove_specific_occurrences_of_items","text":"def playlist_remove_specific_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - an array of objects containing Spotify URIs of the tracks/episodes to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot View Source def playlist_remove_specific_occurrences_of_items ( self , playlist_id , items , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - playlist_id - the id of the playlist - items - an array of objects containing Spotify URIs of the tracks/episodes to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [] for tr in items : ftracks . append ( { \"uri\" : self . _get_uri ( \"track\" , tr [ \"uri\" ]), \"positions\" : tr [ \"positions\" ], } ) payload = { \"tracks\" : ftracks } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"playlists/ %s /tracks\" % ( plid ), payload = payload )","title":"playlist_remove_specific_occurrences_of_items"},{"location":"reference/spotdl/utils/spotify/#playlist_reorder_items","text":"def playlist_reorder_items ( self , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None ) Reorder tracks in a playlist Parameters: - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID View Source def playlist_reorder_items ( self , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None , ): \"\"\" Reorder tracks in a playlist Parameters: - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) payload = { \"range_start\" : range_start , \"range_length\" : range_length , \"insert_before\" : insert_before , } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _put ( \"playlists/ %s /tracks\" % ( plid ), payload = payload )","title":"playlist_reorder_items"},{"location":"reference/spotdl/utils/spotify/#playlist_replace_items","text":"def playlist_replace_items ( self , playlist_id , items ) Replace all tracks/episodes in a playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to comprise playlist View Source def playlist_replace_items ( self , playlist_id , items ): \"\"\" Replace all tracks/episodes in a playlist Parameters: - playlist_id - the id of the playlist - items - list of track/episode ids to comprise playlist \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [ self . _get_uri ( \"track\" , tid ) for tid in items ] payload = { \"uris\" : ftracks } return self . _put ( \"playlists/ %s /tracks\" % ( plid ), payload = payload )","title":"playlist_replace_items"},{"location":"reference/spotdl/utils/spotify/#playlist_tracks","text":"def playlist_tracks ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( 'track' ,) ) Get full details of the tracks of a playlist. Parameters: - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166-1 alpha-2 country code. - additional_types - list of item types to return. valid types are: track and episode View Source def playlist_tracks ( self , playlist_id , fields = None , limit = 100 , offset = 0 , market = None , additional_types = ( \" track \" , ) ) : \"\"\" Get full details of the tracks of a playlist. Parameters : - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . - additional_types - list of item types to return . valid types are : track and episode \"\"\" warnings . warn ( \" You should use `playlist_items(playlist_id, ..., \" \" additional_types=('track',))` instead \" , DeprecationWarning , ) return self . playlist_items ( playlist_id , fields , limit , offset , market , additional_types )","title":"playlist_tracks"},{"location":"reference/spotdl/utils/spotify/#playlist_upload_cover_image","text":"def playlist_upload_cover_image ( self , playlist_id , image_b64 ) Replace the image used to represent a specific playlist Parameters: - playlist_id - the id of the playlist - image_b64 - image data as a Base64 encoded JPEG image string (maximum payload size is 256 KB) View Source def playlist_upload_cover_image ( self , playlist_id , image_b64 ): \"\"\" Replace the image used to represent a specific playlist Parameters: - playlist_id - the id of the playlist - image_b64 - image data as a Base64 encoded JPEG image string (maximum payload size is 256 KB) \"\"\" plid = self . _get_id ( \"playlist\" , playlist_id ) return self . _put ( \"playlists/{}/images\" . format ( plid ), payload = image_b64 , content_type = \"image/jpeg\" , )","title":"playlist_upload_cover_image"},{"location":"reference/spotdl/utils/spotify/#previous","text":"def previous ( self , result ) returns the previous result given a paged result Parameters: - result - a previously returned paged result View Source def previous ( self , result ) : \"\"\" returns the previous result given a paged result Parameters : - result - a previously returned paged result \"\"\" if result [ \" previous \" ]: return self . _get ( result [ \" previous \" ] ) else : return None","title":"previous"},{"location":"reference/spotdl/utils/spotify/#previous_track","text":"def previous_track ( self , device_id = None ) Skip user's playback to previous track. Parameters: - device_id - device target for playback View Source def previous_track ( self , device_id = None ) : \"\"\" Skip user's playback to previous track. Parameters : - device_id - device target for playback \"\"\" return self . _post ( self . _append_device_id ( \" me/player/previous \" , device_id ) )","title":"previous_track"},{"location":"reference/spotdl/utils/spotify/#recommendation_genre_seeds","text":"def recommendation_genre_seeds ( self ) Get a list of genres available for the recommendations function. View Source def recommendation_genre_seeds ( self ) : \"\"\" Get a list of genres available for the recommendations function. \"\"\" return self . _get ( \" recommendations/available-genre-seeds \" )","title":"recommendation_genre_seeds"},{"location":"reference/spotdl/utils/spotify/#recommendations","text":"def recommendations ( self , seed_artists = None , seed_genres = None , seed_tracks = None , limit = 20 , country = None , ** kwargs ) Get a list of recommended tracks for one to five seeds. (at least one of seed_artists , seed_tracks and seed_genres are needed) Parameters: - seed_artists - a list of artist IDs, URIs or URLs - seed_tracks - a list of track IDs, URIs or URLs - seed_genres - a list of genre names. Available genres for recommendations can be found by calling recommendation_genre_seeds - country - An ISO 3166 - 1 alpha - 2 country code . If provided , all results will be playable in this country . - limit - The maximum number of items to return . Default : 20 . Minimum : 1 . Maximum : 100 - min / max / target_ < attribute > - For the tuneable track attributes listed in the documentation , these values provide filters and targeting on results . View Source def recommendations ( self , seed_artists = None , seed_genres = None , seed_tracks = None , limit = 20 , country = None , ** kwargs ) : \" \"\" Get a list of recommended tracks for one to five seeds. (at least one of `seed_artists`, `seed_tracks` and `seed_genres` are needed) Parameters: - seed_artists - a list of artist IDs, URIs or URLs - seed_tracks - a list of track IDs, URIs or URLs - seed_genres - a list of genre names. Available genres for recommendations can be found by calling recommendation_genre_seeds - country - An ISO 3166-1 alpha-2 country code. If provided, all results will be playable in this country. - limit - The maximum number of items to return. Default: 20. Minimum: 1. Maximum: 100 - min/max/target_<attribute> - For the tuneable track attributes listed in the documentation, these values provide filters and targeting on results. \"\" \" params = dict ( limit = limit ) if seed_artists : params [ \"seed_artists\" ] = \",\" . join ( [ self . _get_id ( \"artist\" , a ) for a in seed_artists ] ) if seed_genres : params [ \"seed_genres\" ] = \",\" . join ( seed_genres ) if seed_tracks : params [ \"seed_tracks\" ] = \",\" . join ( [ self . _get_id ( \"track\" , t ) for t in seed_tracks ] ) if country : params [ \"market\" ] = country for attribute in [ \"acousticness\" , \"danceability\" , \"duration_ms\" , \"energy\" , \"instrumentalness\" , \"key\" , \"liveness\" , \"loudness\" , \"mode\" , \"popularity\" , \"speechiness\" , \"tempo\" , \"time_signature\" , \"valence\" , ] : for prefix in [ \"min_\" , \"max_\" , \"target_\" ] : param = prefix + attribute if param in kwargs : params [ param ] = kwargs [ param ] return self . _get ( \"recommendations\" , ** params )","title":"recommendations"},{"location":"reference/spotdl/utils/spotify/#repeat","text":"def repeat ( self , state , device_id = None ) Set repeat mode for playback. Parameters: - state - track , context , or off - device_id - device target for playback View Source def repeat ( self , state , device_id = None ) : \" \"\" Set repeat mode for playback. Parameters: - state - `track`, `context`, or `off` - device_id - device target for playback \"\" \" if state not in [ \"track\" , \"context\" , \"off\" ] : logger . warning ( \"Invalid state\" ) return self . _put ( self . _append_device_id ( \"me/player/repeat?state=%s\" % state , device_id ) )","title":"repeat"},{"location":"reference/spotdl/utils/spotify/#search","text":"def search ( self , q , limit = 10 , offset = 0 , type = 'track' , market = None ) searches for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied within each type, not on the total response. - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', and 'episode'. If multiple types are desired, pass in a comma separated string; e.g., 'track,album,episode'. - market - An ISO 3166-1 alpha-2 country code or the string from_token. View Source def search ( self , q , limit = 10 , offset = 0 , type = \"track\" , market = None ): \"\"\" searches for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). The limit is applied within each type, not on the total response. - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', and 'episode'. If multiple types are desired, pass in a comma separated string; e.g., 'track,album,episode'. - market - An ISO 3166-1 alpha-2 country code or the string from_token. \"\"\" return self . _get ( \"search\" , q = q , limit = limit , offset = offset , type = type , market = market )","title":"search"},{"location":"reference/spotdl/utils/spotify/#search_markets","text":"def search_markets ( self , q , limit = 10 , offset = 0 , type = 'track' , markets = None , total = None ) (experimental) Searches multiple markets for an item Parameters: - q - the search query (see how to write a query in the official documentation https://developer.spotify.com/documentation/web-api/reference/search/) # noqa - limit - the number of items to return (min = 1, default = 10, max = 50). If a search is to be done on multiple markets, then this limit is applied to each market. (e.g. search US, CA, MX each with a limit of 10). - offset - the index of the first item to return - type - the types of items to return. One or more of 'artist', 'album', 'track', 'playlist', 'show', or 'episode'. If multiple types are desired, pass in a comma separated string. - markets - A list of ISO 3166-1 alpha-2 country codes. Search all country markets by default. - total - the total number of results to return if multiple markets are supplied in the search. If multiple types are specified, this only applies to the first type. View Source def search_markets ( self , q , limit = 10 , offset = 0 , type = \" track \" , markets = None , total = None ) : \"\"\" (experimental) Searches multiple markets for an item Parameters : - q - the search query ( see how to write a query in the official documentation https : // developer . spotify . com / documentation / web - api / reference / search / ) # noqa - limit - the number of items to return ( min = 1 , default = 10 , max = 50 ) . If a search is to be done on multiple markets , then this limit is applied to each market . ( e . g . search US , CA , MX each with a limit of 10 ) . - offset - the index of the first item to return - type - the types of items to return . One or more of ' artist ' , ' album ' , ' track ' , ' playlist ' , ' show ' , or ' episode ' . If multiple types are desired , pass in a comma separated string . - markets - A list of ISO 3166 - 1 alpha - 2 country codes . Search all country markets by default . - total - the total number of results to return if multiple markets are supplied in the search . If multiple types are specified , this only applies to the first type . \"\"\" warnings . warn ( \" Searching multiple markets is an experimental feature. \" \" Please be aware that this method's inputs and outputs can change in the future. \" , UserWarning , ) if not markets : markets = self . country_codes if not ( isinstance ( markets , list ) or isinstance ( markets , tuple )) : markets = [] warnings . warn ( \" Searching multiple markets is poorly performing. \" , UserWarning , ) return self . _search_multiple_markets ( q , limit , offset , type , markets , total )","title":"search_markets"},{"location":"reference/spotdl/utils/spotify/#seek_track","text":"def seek_track ( self , position_ms , device_id = None ) Seek to position in current track. Parameters: - position_ms - position in milliseconds to seek to - device_id - device target for playback View Source def seek_track ( self , position_ms , device_id = None ) : \"\"\" Seek to position in current track. Parameters : - position_ms - position in milliseconds to seek to - device_id - device target for playback \"\"\" if not isinstance ( position_ms , int ) : logger . warning ( \" Position_ms must be an integer \" ) return return self . _put ( self . _append_device_id ( \" me/player/seek?position_ms=%s \" % position_ms , device_id ) )","title":"seek_track"},{"location":"reference/spotdl/utils/spotify/#set_auth","text":"def set_auth ( self , auth ) View Source def set_auth(self, auth): self._auth = auth","title":"set_auth"},{"location":"reference/spotdl/utils/spotify/#show","text":"def show ( self , show_id , market = None ) returns a single show given the show's ID, URIs or URL Parameters: - show_id - the show ID, URI or URL - market - an ISO 3166-1 alpha-2 country code. The show must be available in the given market. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def show ( self , show_id , market = None ) : \"\"\" returns a single show given the show's ID, URIs or URL Parameters : - show_id - the show ID , URI or URL - market - an ISO 3166 - 1 alpha - 2 country code . The show must be available in the given market . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" show \" , show_id ) return self . _get ( \" shows/ \" + trid , market = market )","title":"show"},{"location":"reference/spotdl/utils/spotify/#show_episodes","text":"def show_episodes ( self , show_id , limit = 50 , offset = 0 , market = None ) Get Spotify catalog information about a show's episodes Parameters: - show_id - the show ID, URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166-1 alpha-2 country code. Only episodes available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def show_episodes ( self , show_id , limit = 50 , offset = 0 , market = None ) : \"\"\" Get Spotify catalog information about a show's episodes Parameters : - show_id - the show ID , URI or URL - limit - the number of items to return - offset - the index of the first item to return - market - an ISO 3166 - 1 alpha - 2 country code . Only episodes available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" trid = self . _get_id ( \" show \" , show_id ) return self . _get ( \" shows/ \" + trid + \" /episodes/ \" , limit = limit , offset = offset , market = market )","title":"show_episodes"},{"location":"reference/spotdl/utils/spotify/#shows","text":"def shows ( self , shows , market = None ) returns a list of shows given the show IDs, URIs, or URLs Parameters: - shows - a list of show IDs, URIs or URLs - market - an ISO 3166-1 alpha-2 country code. Only shows available in the given market will be returned. If user-based authorization is in use, the user's country takes precedence. If neither market nor user country are provided, the content is considered unavailable for the client. View Source def shows ( self , shows , market = None ) : \"\"\" returns a list of shows given the show IDs, URIs, or URLs Parameters : - shows - a list of show IDs , URIs or URLs - market - an ISO 3166 - 1 alpha - 2 country code . Only shows available in the given market will be returned . If user - based authorization is in use , the user ' s country takes precedence . If neither market nor user country are provided , the content is considered unavailable for the client . \"\"\" tlist = [ self . _get_id ( \" show \" , s ) for s in shows ] return self . _get ( \" shows/?ids= \" + \" , \" . join ( tlist ) , market = market )","title":"shows"},{"location":"reference/spotdl/utils/spotify/#shuffle","text":"def shuffle ( self , state , device_id = None ) Toggle playback shuffling. Parameters: - state - true or false - device_id - device target for playback View Source def shuffle ( self , state , device_id = None ) : \"\"\" Toggle playback shuffling. Parameters : - state - true or false - device_id - device target for playback \"\"\" if not isinstance ( state , bool ) : logger . warning ( \" state must be a boolean \" ) return state = str ( state ) . lower () self . _put ( self . _append_device_id ( \" me/player/shuffle?state=%s \" % state , device_id ) )","title":"shuffle"},{"location":"reference/spotdl/utils/spotify/#start_playback","text":"def start_playback ( self , device_id = None , context_uri = None , uris = None , offset = None , position_ms = None ) Start or resume user's playback. Provide a context_uri to start playback or a album, artist, or playlist. Provide a uris list to start playback of one or more tracks. Provide offset as {\"position\": } or {\"uri\": \" \"} to start playback at a particular offset. Parameters: - device_id - device target for playback - context_uri - spotify context uri to play - uris - spotify track uris - offset - offset into context by index or track - position_ms - (optional) indicates from what position to start playback. Must be a positive number. Passing in a position that is greater than the length of the track will cause the player to start playing the next song. View Source def start_playback ( self , device_id = None , context_uri = None , uris = None , offset = None , position_ms = None ) : \" \"\" Start or resume user's playback. Provide a `context_uri` to start playback or a album, artist, or playlist. Provide a `uris` list to start playback of one or more tracks. Provide `offset` as {\" position \": <int>} or {\" uri \": \" < track uri > \"} to start playback at a particular offset. Parameters: - device_id - device target for playback - context_uri - spotify context uri to play - uris - spotify track uris - offset - offset into context by index or track - position_ms - (optional) indicates from what position to start playback. Must be a positive number. Passing in a position that is greater than the length of the track will cause the player to start playing the next song. \"\" \" if context_uri is not None and uris is not None : logger . warning ( \"Specify either context uri or uris, not both\" ) return if uris is not None and not isinstance ( uris , list ) : logger . warning ( \"URIs must be a list\" ) return data = {} if context_uri is not None : data [ \"context_uri\" ] = context_uri if uris is not None : data [ \"uris\" ] = uris if offset is not None : data [ \"offset\" ] = offset if position_ms is not None : data [ \"position_ms\" ] = position_ms return self . _put ( self . _append_device_id ( \"me/player/play\" , device_id ), payload = data )","title":"start_playback"},{"location":"reference/spotdl/utils/spotify/#track","text":"def track ( self , track_id , market = None ) returns a single track given the track's ID, URI or URL Parameters: - track_id - a spotify URI, URL or ID - market - an ISO 3166-1 alpha-2 country code. View Source def track ( self , track_id , market = None ) : \"\"\" returns a single track given the track's ID, URI or URL Parameters : - track_id - a spotify URI , URL or ID - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" trid = self . _get_id ( \" track \" , track_id ) return self . _get ( \" tracks/ \" + trid , market = market )","title":"track"},{"location":"reference/spotdl/utils/spotify/#tracks","text":"def tracks ( self , tracks , market = None ) returns a list of tracks given a list of track IDs, URIs, or URLs Parameters: - tracks - a list of spotify URIs, URLs or IDs. Maximum: 50 IDs. - market - an ISO 3166-1 alpha-2 country code. View Source def tracks ( self , tracks , market = None ) : \"\"\" returns a list of tracks given a list of track IDs, URIs, or URLs Parameters : - tracks - a list of spotify URIs , URLs or IDs . Maximum : 50 IDs . - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" tlist = [ self . _get_id ( \" track \" , t ) for t in tracks ] return self . _get ( \" tracks/?ids= \" + \" , \" . join ( tlist ) , market = market )","title":"tracks"},{"location":"reference/spotdl/utils/spotify/#transfer_playback","text":"def transfer_playback ( self , device_id , force_play = True ) Transfer playback to another device. Note that the API accepts a list of device ids, but only actually supports one. Parameters: - device_id - transfer playback to this device - force_play - true: after transfer, play. false: keep current state. View Source def transfer_playback ( self , device_id , force_play = True ) : \"\"\" Transfer playback to another device. Note that the API accepts a list of device ids, but only actually supports one. Parameters: - device_id - transfer playback to this device - force_play - true: after transfer, play. false: keep current state. \"\"\" data = { \"device_ids\" : [ device_id ] , \"play\" : force_play } return self . _put ( \"me/player\" , payload = data )","title":"transfer_playback"},{"location":"reference/spotdl/utils/spotify/#user","text":"def user ( self , user ) Gets basic profile information about a Spotify User Parameters: - user - the id of the usr View Source def user ( self , user ) : \"\"\" Gets basic profile information about a Spotify User Parameters : - user - the id of the usr \"\"\" return self . _get ( \" users/ \" + user )","title":"user"},{"location":"reference/spotdl/utils/spotify/#user_follow_artists","text":"def user_follow_artists ( self , ids = [] ) Follow one or more artists Parameters: - ids - a list of artist IDs View Source def user_follow_artists ( self , ids = [] ) : \"\"\" Follow one or more artists Parameters : - ids - a list of artist IDs \"\"\" return self . _put ( \" me/following?type=artist&ids= \" + \" , \" . join ( ids ))","title":"user_follow_artists"},{"location":"reference/spotdl/utils/spotify/#user_follow_users","text":"def user_follow_users ( self , ids = [] ) Follow one or more users Parameters: - ids - a list of user IDs View Source def user_follow_users ( self , ids = [] ) : \"\"\" Follow one or more users Parameters : - ids - a list of user IDs \"\"\" return self . _put ( \" me/following?type=user&ids= \" + \" , \" . join ( ids ))","title":"user_follow_users"},{"location":"reference/spotdl/utils/spotify/#user_playlist","text":"def user_playlist ( self , user , playlist_id = None , fields = None , market = None ) View Source def user_playlist ( self , user , playlist_id = None , fields = None , market = None ) : warnings . warn ( \" You should use `playlist(playlist_id)` instead \" , DeprecationWarning , ) \"\"\" Gets playlist of a user Parameters : - user - the id of the user - playlist_id - the id of the playlist - fields - which fields to return \"\"\" if playlist_id is None : return self . _get ( \" users/%s/starred \" % user ) return self . playlist ( playlist_id , fields = fields , market = market )","title":"user_playlist"},{"location":"reference/spotdl/utils/spotify/#user_playlist_add_tracks","text":"def user_playlist_add_tracks ( self , user , playlist_id , tracks , position = None ) View Source def user_playlist_add_tracks ( self , user , playlist_id , tracks , position = None ) : warnings . warn ( \" You should use `playlist_add_items(playlist_id, tracks)` instead \" , DeprecationWarning , ) \"\"\" Adds tracks to a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - a list of track URIs , URLs or IDs - position - the position to add the tracks \"\"\" return self . playlist_add_items ( playlist_id , tracks , position )","title":"user_playlist_add_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_change_details","text":"def user_playlist_change_details ( self , user , playlist_id , name = None , public = None , collaborative = None , description = None ) View Source def user_playlist_change_details ( self , user , playlist_id , name = None , public = None , collaborative = None , description = None , ) : warnings . warn ( \" You should use `playlist_change_details(playlist_id, ...)` instead \" , DeprecationWarning , ) \"\"\" Changes a playlist's name and/or public/private state Parameters : - user - the id of the user - playlist_id - the id of the playlist - name - optional name of the playlist - public - optional is the playlist public - collaborative - optional is the playlist collaborative - description - optional description of the playlist \"\"\" return self . playlist_change_details ( playlist_id , name , public , collaborative , description )","title":"user_playlist_change_details"},{"location":"reference/spotdl/utils/spotify/#user_playlist_create","text":"def user_playlist_create ( self , user , name , public = True , collaborative = False , description = '' ) Creates a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist - public - is the created playlist public - collaborative - is the created playlist collaborative - description - the description of the playlist View Source def user_playlist_create ( self , user , name , public = True , collaborative = False , description = \"\" ): \"\"\" Creates a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist - public - is the created playlist public - collaborative - is the created playlist collaborative - description - the description of the playlist \"\"\" data = { \"name\" : name , \"public\" : public , \"collaborative\" : collaborative , \"description\" : description } return self . _post ( \"users/ %s /playlists\" % ( user ,), payload = data )","title":"user_playlist_create"},{"location":"reference/spotdl/utils/spotify/#user_playlist_follow_playlist","text":"def user_playlist_follow_playlist ( self , playlist_owner_id , playlist_id ) Add the current authenticated user as a follower of a playlist. Parameters: - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist View Source def user_playlist_follow_playlist ( self , playlist_owner_id , playlist_id ) : \"\"\" Add the current authenticated user as a follower of a playlist . Parameters : - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist \"\"\" warnings . warn ( \" You should use `current_user_follow_playlist(playlist_id)` instead \" , DeprecationWarning , ) return self . current_user_follow_playlist ( playlist_id )","title":"user_playlist_follow_playlist"},{"location":"reference/spotdl/utils/spotify/#user_playlist_is_following","text":"def user_playlist_is_following ( self , playlist_owner_id , playlist_id , user_ids ) Check to see if the given users are following the given playlist Parameters: - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist. Maximum: 5 ids. View Source def user_playlist_is_following ( self , playlist_owner_id , playlist_id , user_ids ) : \"\"\" Check to see if the given users are following the given playlist Parameters : - playlist_owner_id - the user id of the playlist owner - playlist_id - the id of the playlist - user_ids - the ids of the users that you want to check to see if they follow the playlist . Maximum : 5 ids . \"\"\" warnings . warn ( \" You should use `playlist_is_following(playlist_id, user_ids)` instead \" , DeprecationWarning , ) return self . playlist_is_following ( playlist_id , user_ids )","title":"user_playlist_is_following"},{"location":"reference/spotdl/utils/spotify/#user_playlist_remove_all_occurrences_of_tracks","text":"def user_playlist_remove_all_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot View Source def user_playlist_remove_all_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) : \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to remove from the playlist - snapshot_id - optional id of the playlist snapshot \"\"\" warnings . warn ( \" You should use `playlist_remove_all_occurrences_of_items \" \" (playlist_id, tracks)` instead \" , DeprecationWarning , ) return self . playlist_remove_all_occurrences_of_items ( playlist_id , tracks , snapshot_id )","title":"user_playlist_remove_all_occurrences_of_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_remove_specific_occurrences_of_tracks","text":"def user_playlist_remove_specific_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ) Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - an array of objects containing Spotify URIs of the tracks to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot View Source def user_playlist_remove_specific_occurrences_of_tracks ( self , user , playlist_id , tracks , snapshot_id = None ): \"\"\" Removes all occurrences of the given tracks from the given playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - an array of objects containing Spotify URIs of the tracks to remove with their current positions in the playlist. For example: [ { \"uri\":\"4iV5W9uYEdYUVa79Axb7Rh\", \"positions\":[2] }, { \"uri\":\"1301WleyT98MSxVHPZCA6M\", \"positions\":[7] } ] - snapshot_id - optional id of the playlist snapshot \"\"\" warnings . warn ( \"You should use `playlist_remove_specific_occurrences_of_items\" \"(playlist_id, tracks)` instead\" , DeprecationWarning , ) plid = self . _get_id ( \"playlist\" , playlist_id ) ftracks = [] for tr in tracks : ftracks . append ( { \"uri\" : self . _get_uri ( \"track\" , tr [ \"uri\" ]), \"positions\" : tr [ \"positions\" ], } ) payload = { \"tracks\" : ftracks } if snapshot_id : payload [ \"snapshot_id\" ] = snapshot_id return self . _delete ( \"users/ %s /playlists/ %s /tracks\" % ( user , plid ), payload = payload )","title":"user_playlist_remove_specific_occurrences_of_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_reorder_tracks","text":"def user_playlist_reorder_tracks ( self , user , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None ) Reorder tracks in a playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered (default: 1) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist's snapshot ID View Source def user_playlist_reorder_tracks ( self , user , playlist_id , range_start , insert_before , range_length = 1 , snapshot_id = None , ) : \"\"\" Reorder tracks in a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - range_start - the position of the first track to be reordered - range_length - optional the number of tracks to be reordered ( default : 1 ) - insert_before - the position where the tracks should be inserted - snapshot_id - optional playlist ' s snapshot ID \"\"\" warnings . warn ( \" You should use `playlist_reorder_items(playlist_id, ...)` instead \" , DeprecationWarning , ) return self . playlist_reorder_items ( playlist_id , range_start , insert_before , range_length , snapshot_id )","title":"user_playlist_reorder_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_replace_tracks","text":"def user_playlist_replace_tracks ( self , user , playlist_id , tracks ) Replace all tracks in a playlist Parameters: - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to add to the playlist View Source def user_playlist_replace_tracks ( self , user , playlist_id , tracks ) : \"\"\" Replace all tracks in a playlist Parameters : - user - the id of the user - playlist_id - the id of the playlist - tracks - the list of track ids to add to the playlist \"\"\" warnings . warn ( \" You should use `playlist_replace_items(playlist_id, tracks)` instead \" , DeprecationWarning , ) return self . playlist_replace_items ( playlist_id , tracks )","title":"user_playlist_replace_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_tracks","text":"def user_playlist_tracks ( self , user = None , playlist_id = None , fields = None , limit = 100 , offset = 0 , market = None ) View Source def user_playlist_tracks ( self , user = None , playlist_id = None , fields = None , limit = 100 , offset = 0 , market = None , ) : warnings . warn ( \" You should use `playlist_tracks(playlist_id)` instead \" , DeprecationWarning , ) \"\"\" Get full details of the tracks of a playlist owned by a user. Parameters : - user - the id of the user - playlist_id - the id of the playlist - fields - which fields to return - limit - the maximum number of tracks to return - offset - the index of the first track to return - market - an ISO 3166 - 1 alpha - 2 country code . \"\"\" return self . playlist_tracks ( playlist_id , limit = limit , offset = offset , fields = fields , market = market , )","title":"user_playlist_tracks"},{"location":"reference/spotdl/utils/spotify/#user_playlist_unfollow","text":"def user_playlist_unfollow ( self , user , playlist_id ) Unfollows (deletes) a playlist for a user Parameters: - user - the id of the user - name - the name of the playlist View Source def user_playlist_unfollow ( self , user , playlist_id ) : \"\"\" Unfollows (deletes) a playlist for a user Parameters : - user - the id of the user - name - the name of the playlist \"\"\" warnings . warn ( \" You should use `current_user_unfollow_playlist(playlist_id)` instead \" , DeprecationWarning , ) return self . current_user_unfollow_playlist ( playlist_id )","title":"user_playlist_unfollow"},{"location":"reference/spotdl/utils/spotify/#user_playlists","text":"def user_playlists ( self , user , limit = 50 , offset = 0 ) Gets playlists of a user Parameters: - user - the id of the usr - limit - the number of items to return - offset - the index of the first item to return View Source def user_playlists ( self , user , limit = 50 , offset = 0 ) : \"\"\" Gets playlists of a user Parameters : - user - the id of the usr - limit - the number of items to return - offset - the index of the first item to return \"\"\" return self . _get ( \" users/%s/playlists \" % user , limit = limit , offset = offset )","title":"user_playlists"},{"location":"reference/spotdl/utils/spotify/#user_unfollow_artists","text":"def user_unfollow_artists ( self , ids = [] ) Unfollow one or more artists Parameters: - ids - a list of artist IDs View Source def user_unfollow_artists ( self , ids = [] ) : \"\"\" Unfollow one or more artists Parameters : - ids - a list of artist IDs \"\"\" return self . _delete ( \" me/following?type=artist&ids= \" + \" , \" . join ( ids ))","title":"user_unfollow_artists"},{"location":"reference/spotdl/utils/spotify/#user_unfollow_users","text":"def user_unfollow_users ( self , ids = [] ) Unfollow one or more users Parameters: - ids - a list of user IDs View Source def user_unfollow_users ( self , ids = [] ) : \"\"\" Unfollow one or more users Parameters : - ids - a list of user IDs \"\"\" return self . _delete ( \" me/following?type=user&ids= \" + \" , \" . join ( ids ))","title":"user_unfollow_users"},{"location":"reference/spotdl/utils/spotify/#volume","text":"def volume ( self , volume_percent , device_id = None ) Set playback volume. Parameters: - volume_percent - volume between 0 and 100 - device_id - device target for playback View Source def volume ( self , volume_percent , device_id = None ) : \"\"\" Set playback volume. Parameters : - volume_percent - volume between 0 and 100 - device_id - device target for playback \"\"\" if not isinstance ( volume_percent , int ) : logger . warning ( \" Volume must be an integer \" ) return if volume_percent < 0 or volume_percent > 100 : logger . warning ( \" Volume must be between 0 and 100, inclusive \" ) return self . _put ( self . _append_device_id ( \" me/player/volume?volume_percent=%s \" % volume_percent , device_id , ) )","title":"volume"},{"location":"reference/spotdl/utils/spotify/#spotifyerror","text":"class SpotifyError ( / , * args , ** kwargs ) View Source class SpotifyError ( Exception ): \"\"\" Base class for all exceptions related to SpotifyClient. \"\"\"","title":"SpotifyError"},{"location":"reference/spotdl/utils/spotify/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/spotdl/utils/spotify/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/spotdl/utils/spotify/#methods_2","text":"","title":"Methods"},{"location":"reference/spotdl/utils/spotify/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"}]}